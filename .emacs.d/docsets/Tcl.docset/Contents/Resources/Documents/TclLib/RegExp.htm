<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>Tcl_RegExpMatch manual page - Tcl Library Procedures</TITLE>
<link rel="stylesheet" href="../docs.css" type="text/css" media="all">
</HEAD>
<BODY><H2><a href="../contents.htm">Tcl8.6.0/Tk8.6.0 Documentation</a> <small>&gt;</small> <a href="contents.htm">Tcl C API, version 8.6.0</a> <small>&gt;</small> RegExp</H2>
<H3><A HREF="../UserCmd/contents.htm">Tcl/Tk Applications</A> | <A HREF="../TclCmd/contents.htm">Tcl Commands</A> | <A HREF="../TkCmd/contents.htm">Tk Commands</A> | <A HREF="../ItclCmd/contents.htm">[incr Tcl] Package Commands</A> | <A HREF="../Sqlite3Cmd/contents.htm">SQLite Package Commands</A> | <A HREF="../TdbcCmd/contents.htm">TDBC Package Commands</A> | <A HREF="../TdbcmysqlCmd/contents.htm">tdbc::mysql Package Commands</A> | <A HREF="../TdbcodbcCmd/contents.htm">tdbc::odbc Package Commands</A> | <A HREF="../TdbcpostgresCmd/contents.htm">tdbc::postgres Package Commands</A> | <A HREF="../Tdbcsqlite3Cmd/contents.htm">tdbc::sqlite3 Package Commands</A> | <A HREF="../ThreadCmd/contents.htm">Thread Package Commands</A> | <A HREF="../TclLib/contents.htm">Tcl C API</A> | <A HREF="../TkLib/contents.htm">Tk C API</A> | <A HREF="../ItclLib/contents.htm">[incr Tcl] Package C API</A> | <A HREF="../TdbcLib/contents.htm">TDBC Package C API</A></H3>
<DL>
<DD><A HREF="RegExp.htm#M2" NAME="L654">NAME</A>
<DL><DD>Tcl_RegExpMatch, Tcl_RegExpCompile, Tcl_RegExpExec, Tcl_RegExpRange, Tcl_GetRegExpFromObj, Tcl_RegExpMatchObj, Tcl_RegExpExecObj, Tcl_RegExpGetInfo &mdash; Pattern matching with regular expressions</DD></DL>
<DD><A HREF="RegExp.htm#M3" NAME="L655">SYNOPSIS</A>
<DL>
<DD><B>#include &lt;tcl.h&gt;</B>
<DD>int
<DD><B>Tcl_RegExpMatchObj</B>(<I>interp</I>, <I>textObj</I>, <I>patObj</I>)
<DD>int
<DD><B>Tcl_RegExpMatch</B>(<I>interp</I>, <I>text</I>, <I>pattern</I>)
<DD>Tcl_RegExp
<DD><B>Tcl_RegExpCompile</B>(<I>interp</I>, <I>pattern</I>)
<DD>int
<DD><B>Tcl_RegExpExec</B>(<I>interp</I>, <I>regexp</I>, <I>text</I>, <I>start</I>)
<DD>void
<DD><B>Tcl_RegExpRange</B>(<I>regexp</I>, <I>index</I>, <I>startPtr</I>, <I>endPtr</I>)
<DD>Tcl_RegExp
<DD><B>Tcl_GetRegExpFromObj</B>(<I>interp</I>, <I>patObj</I>, <I>cflags</I>)
<DD>int
<DD><B>Tcl_RegExpExecObj</B>(<I>interp</I>, <I>regexp</I>, <I>textObj</I>, <I>offset</I>, <I>nmatches</I>, <I>eflags</I>)
<DD>void
<DD><B>Tcl_RegExpGetInfo</B>(<I>regexp</I>, <I>infoPtr</I>)
</DL>
<DD><A HREF="RegExp.htm#M4" NAME="L656">ARGUMENTS</A>
<DL class="arguments">
</DL>
<DD><A HREF="RegExp.htm#M5" NAME="L657">DESCRIPTION</A>
<DL class="description">
<DD><A HREF="RegExp.htm#M6" NAME="L658"><B>TCL_REG_ADVANCED</B></A>
<DD><A HREF="RegExp.htm#M7" NAME="L659"><B>TCL_REG_EXTENDED</B></A>
<DD><A HREF="RegExp.htm#M8" NAME="L660"><B>TCL_REG_BASIC</B></A>
<DD><A HREF="RegExp.htm#M9" NAME="L661"><B>TCL_REG_EXPANDED</B></A>
<DD><A HREF="RegExp.htm#M10" NAME="L662"><B>TCL_REG_QUOTE</B></A>
<DD><A HREF="RegExp.htm#M11" NAME="L663"><B>TCL_REG_NOCASE</B></A>
<DD><A HREF="RegExp.htm#M12" NAME="L664"><B>TCL_REG_NEWLINE</B></A>
<DD><A HREF="RegExp.htm#M13" NAME="L665"><B>TCL_REG_NLSTOP</B></A>
<DD><A HREF="RegExp.htm#M14" NAME="L666"><B>TCL_REG_NLANCH</B></A>
<DD><A HREF="RegExp.htm#M15" NAME="L667"><B>TCL_REG_NOSUB</B></A>
<DD><A HREF="RegExp.htm#M16" NAME="L668"><B>TCL_REG_CANMATCH</B></A>
</DL>
<DL class="description">
<DD><A HREF="RegExp.htm#M17" NAME="L669"><B>TCL_REG_NOTBOL</B></A>
<DD><A HREF="RegExp.htm#M18" NAME="L670"><B>TCL_REG_NOTEOL</B></A>
</DL>
<DD><A HREF="RegExp.htm#M19" NAME="L671">SEE ALSO</A>
<DD><A HREF="RegExp.htm#M20" NAME="L672">KEYWORDS</A>
</DL>
<H3><A NAME="M2">NAME</A></H3>
Tcl_RegExpMatch, Tcl_RegExpCompile, Tcl_RegExpExec, Tcl_RegExpRange, Tcl_GetRegExpFromObj, Tcl_RegExpMatchObj, Tcl_RegExpExecObj, Tcl_RegExpGetInfo &mdash; Pattern matching with regular expressions
<H3><A NAME="M3">SYNOPSIS</A></H3>
<B>#include &lt;tcl.h&gt;</B><BR>
int<BR>
<B>Tcl_RegExpMatchObj</B>(<I>interp</I>, <I>textObj</I>, <I>patObj</I>)<BR>
int<BR>
<B>Tcl_RegExpMatch</B>(<I>interp</I>, <I>text</I>, <I>pattern</I>)<BR>
Tcl_RegExp<BR>
<B>Tcl_RegExpCompile</B>(<I>interp</I>, <I>pattern</I>)<BR>
int<BR>
<B>Tcl_RegExpExec</B>(<I>interp</I>, <I>regexp</I>, <I>text</I>, <I>start</I>)<BR>
void<BR>
<B>Tcl_RegExpRange</B>(<I>regexp</I>, <I>index</I>, <I>startPtr</I>, <I>endPtr</I>)<BR>
Tcl_RegExp<BR>
<B>Tcl_GetRegExpFromObj</B>(<I>interp</I>, <I>patObj</I>, <I>cflags</I>)<BR>
int<BR>
<B>Tcl_RegExpExecObj</B>(<I>interp</I>, <I>regexp</I>, <I>textObj</I>, <I>offset</I>, <I>nmatches</I>, <I>eflags</I>)<BR>
void<BR>
<B>Tcl_RegExpGetInfo</B>(<I>regexp</I>, <I>infoPtr</I>)<BR>
<H3><A NAME="M4">ARGUMENTS</A></H3>
<DL class="arguments">
<DT><A HREF="../TclLib/Interp.htm">Tcl_Interp</A> <B>*interp</B> (in)<DD>
Tcl interpreter to use for error reporting.  The interpreter may be
NULL if no error reporting is desired.
<P><DT><A HREF="../TclLib/Object.htm">Tcl_Obj</A> <B>*textObj</B> (in/out)<DD>
Refers to the value from which to get the text to search.  The
internal representation of the value may be converted to a form that
can be efficiently searched.
<P><DT><A HREF="../TclLib/Object.htm">Tcl_Obj</A> <B>*patObj</B> (in/out)<DD>
Refers to the value from which to get a regular expression. The
compiled regular expression is cached in the value.
<P><DT>char <B>*text</B> (in)<DD>
Text to search for a match with a regular expression.
<P><DT>const char <B>*pattern</B> (in)<DD>
String in the form of a regular expression pattern.
<P><DT>Tcl_RegExp <B><A HREF="../TclCmd/regexp.htm">regexp</A></B> (in)<DD>
Compiled regular expression.  Must have been returned previously
by <B>Tcl_GetRegExpFromObj</B> or <B>Tcl_RegExpCompile</B>.
<P><DT>char <B>*start</B> (in)<DD>
If <I>text</I> is just a portion of some other string, this argument
identifies the beginning of the larger string.
If it is not the same as <I>text</I>, then no
&#8220;<B>^</B>&#8221;
matches will be allowed.
<P><DT>int <B>index</B> (in)<DD>
Specifies which range is desired:  0 means the range of the entire
match, 1 or greater means the range that matched a parenthesized
sub-expression.
<P><DT>const char <B>**startPtr</B> (out)<DD>
The address of the first character in the range is stored here, or
NULL if there is no such range.
<P><DT>const char <B>**endPtr</B> (out)<DD>
The address of the character just after the last one in the range
is stored here, or NULL if there is no such range.
<P><DT>int <B>cflags</B> (in)<DD>
OR-ed combination of the compilation flags <B>TCL_REG_ADVANCED</B>,
<B>TCL_REG_EXTENDED</B>, <B>TCL_REG_BASIC</B>, <B>TCL_REG_EXPANDED</B>,
<B>TCL_REG_QUOTE</B>, <B>TCL_REG_NOCASE</B>, <B>TCL_REG_NEWLINE</B>,
<B>TCL_REG_NLSTOP</B>, <B>TCL_REG_NLANCH</B>, <B>TCL_REG_NOSUB</B>, and
<B>TCL_REG_CANMATCH</B>. See below for more information.
<P><DT>int <B>offset</B> (in)<DD>
The character offset into the text where matching should begin.
The value of the offset has no impact on <B>^</B> matches.  This
behavior is controlled by <I>eflags</I>.
<P><DT>int <B>nmatches</B> (in)<DD>
The number of matching subexpressions that should be remembered for
later use.  If this value is 0, then no subexpression match
information will be computed.  If the value is -1, then
all of the matching subexpressions will be remembered.  Any other
value will be taken as the maximum number of subexpressions to
remember.
<P><DT>int <B>eflags</B> (in)<DD>
OR-ed combination of the execution flags <B>TCL_REG_NOTBOL</B> and
<B>TCL_REG_NOTEOL</B>. See below for more information.
<P><DT>Tcl_RegExpInfo <B>*infoPtr</B> (out)<DD>
The address of the location where information about a previous match
should be stored by <B>Tcl_RegExpGetInfo</B>.
<P></DL>
<H3><A NAME="M5">DESCRIPTION</A></H3>
<B>Tcl_RegExpMatch</B> determines whether its <I>pattern</I> argument
matches <I>regexp</I>, where <I>regexp</I> is interpreted
as a regular expression using the rules in the <B><A HREF="../TclCmd/re_syntax.htm">re_syntax</A></B>
reference page. 
If there is a match then <B>Tcl_RegExpMatch</B> returns 1.
If there is no match then <B>Tcl_RegExpMatch</B> returns 0.
If an error occurs in the matching process (e.g. <I>pattern</I>
is not a valid regular expression) then <B>Tcl_RegExpMatch</B>
returns -1 and leaves an error message in the interpreter result.
<B>Tcl_RegExpMatchObj</B> is similar to <B>Tcl_RegExpMatch</B> except it
operates on the Tcl values <I>textObj</I> and <I>patObj</I> instead of
UTF strings. 
<B>Tcl_RegExpMatchObj</B> is generally more efficient than
<B>Tcl_RegExpMatch</B>, so it is the preferred interface.
<P>
<B>Tcl_RegExpCompile</B>, <B>Tcl_RegExpExec</B>, and <B>Tcl_RegExpRange</B>
provide lower-level access to the regular expression pattern matcher.
<B>Tcl_RegExpCompile</B> compiles a regular expression string into
the internal form used for efficient pattern matching.
The return value is a token for this compiled form, which can be
used in subsequent calls to <B>Tcl_RegExpExec</B> or <B>Tcl_RegExpRange</B>.
If an error occurs while compiling the regular expression then
<B>Tcl_RegExpCompile</B> returns NULL and leaves an error message
in the interpreter result.
Note:  the return value from <B>Tcl_RegExpCompile</B> is only valid
up to the next call to <B>Tcl_RegExpCompile</B>;  it is not safe to
retain these values for long periods of time.
<P>
<B>Tcl_RegExpExec</B> executes the regular expression pattern matcher.
It returns 1 if <I>text</I> contains a range of characters that
match <I>regexp</I>, 0 if no match is found, and
-1 if an error occurs.
In the case of an error, <B>Tcl_RegExpExec</B> leaves an error
message in the interpreter result.
When searching a string for multiple matches of a pattern,
it is important to distinguish between the start of the original
string and the start of the current search.
For example, when searching for the second occurrence of a
match, the <I>text</I> argument might point to the character
just after the first match;  however, it is important for the
pattern matcher to know that this is not the start of the entire string,
so that it does not allow
&#8220;<B>^</B>&#8221;
atoms in the pattern to match.
The <I>start</I> argument provides this information by pointing
to the start of the overall string containing <I>text</I>.
<I>Start</I> will be less than or equal to <I>text</I>;  if it
is less than <I>text</I> then no <B>^</B> matches will be allowed.
<P>
<B>Tcl_RegExpRange</B> may be invoked after <B>Tcl_RegExpExec</B>
returns;  it provides detailed information about what ranges of
the string matched what parts of the pattern.
<B>Tcl_RegExpRange</B> returns a pair of pointers in <I>*startPtr</I>
and <I>*endPtr</I> that identify a range of characters in
the source string for the most recent call to <B>Tcl_RegExpExec</B>.
<I>Index</I> indicates which of several ranges is desired:
if <I>index</I> is 0, information is returned about the overall range
of characters that matched the entire pattern;  otherwise,
information is returned about the range of characters that matched the
<I>index</I>'th parenthesized subexpression within the pattern.
If there is no range corresponding to <I>index</I> then NULL
is stored in <I>*startPtr</I> and <I>*endPtr</I>.
<P>
<B>Tcl_GetRegExpFromObj</B>, <B>Tcl_RegExpExecObj</B>, and
<B>Tcl_RegExpGetInfo</B> are value interfaces that provide the most
direct control of Henry Spencer's regular expression library.  For
users that need to modify compilation and execution options directly,
it is recommended that you use these interfaces instead of calling the
internal regexp functions.  These interfaces handle the details of UTF
to Unicode translations as well as providing improved performance
through caching in the pattern and string values.
<P>
<B>Tcl_GetRegExpFromObj</B> attempts to return a compiled regular
expression from the <I>patObj</I>.  If the value does not already
contain a compiled regular expression it will attempt to create one
from the string in the value and assign it to the internal
representation of the <I>patObj</I>.  The return value of this function
is of type <B>Tcl_RegExp</B>.  The return value is a token for this
compiled form, which can be used in subsequent calls to
<B>Tcl_RegExpExecObj</B> or <B>Tcl_RegExpGetInfo</B>.  If an error
occurs while compiling the regular expression then
<B>Tcl_GetRegExpFromObj</B> returns NULL and leaves an error message in
the interpreter result.  The regular expression token can be used as
long as the internal representation of <I>patObj</I> refers to the
compiled form.  The <I>cflags</I> argument is a bit-wise OR of
zero or more of the following flags that control the compilation of
<I>patObj</I>:
<P>
<DL class="description">
<DT><A NAME="M6"><B>TCL_REG_ADVANCED</B></A><DD>
Compile advanced regular expressions
(&#8220;ARE&#8221;s).
This mode corresponds to
the normal regular expression syntax accepted by the Tcl <B><A HREF="../TclCmd/regexp.htm">regexp</A></B> and
<B><A HREF="../TclCmd/regsub.htm">regsub</A></B> commands.
<P><DT><A NAME="M7"><B>TCL_REG_EXTENDED</B></A><DD>
Compile extended regular expressions
(&#8220;ERE&#8221;s).
This mode corresponds
to the regular expression syntax recognized by Tcl 8.0 and earlier
versions. 
<P><DT><A NAME="M8"><B>TCL_REG_BASIC</B></A><DD>
Compile basic regular expressions
(&#8220;BRE&#8221;s).
This mode corresponds
to the regular expression syntax recognized by common Unix utilities
like <B>sed</B> and <B>grep</B>.  This is the default if no flags are
specified.
<P><DT><A NAME="M9"><B>TCL_REG_EXPANDED</B></A><DD>
Compile the regular expression (basic, extended, or advanced) using an
expanded syntax that allows comments and whitespace.  This mode causes
non-backslashed non-bracket-expression white
space and #-to-end-of-line comments to be ignored.
<P><DT><A NAME="M10"><B>TCL_REG_QUOTE</B></A><DD>
Compile a literal string, with all characters treated as ordinary characters.
<P><DT><A NAME="M11"><B>TCL_REG_NOCASE</B></A><DD>
Compile for matching that ignores upper/lower case distinctions.
<P><DT><A NAME="M12"><B>TCL_REG_NEWLINE</B></A><DD>
Compile for newline-sensitive matching.  By default, newline is a
completely ordinary character with no special meaning in either
regular expressions or strings.  With this flag,
&#8220;[^&#8221;
bracket expressions and
&#8220;.&#8221;
never match newline,
&#8220;^&#8221;
matches an empty string
after any newline in addition to its normal function, and
&#8220;$&#8221;
matches
an empty string before any newline in addition to its normal function.
<B>REG_NEWLINE</B> is the bit-wise OR of <B>REG_NLSTOP</B> and
<B>REG_NLANCH</B>.
<P><DT><A NAME="M13"><B>TCL_REG_NLSTOP</B></A><DD>
Compile for partial newline-sensitive matching,
with the behavior of
&#8220;[^&#8221;
bracket expressions and
&#8220;.&#8221;
affected, but not the behavior of
&#8220;^&#8221;
and
&#8220;$&#8221;.
In this mode,
&#8220;[^&#8221;
bracket expressions and
&#8220;.&#8221;
never match newline.
<P><DT><A NAME="M14"><B>TCL_REG_NLANCH</B></A><DD>
Compile for inverse partial newline-sensitive matching,
with the behavior of
&#8220;^&#8221;
and
&#8220;$&#8221;
(the
&#8220;anchors&#8221;)
affected, but not the behavior of
&#8220;[^&#8221;
bracket expressions and
&#8220;.&#8221;.
In this mode
&#8220;^&#8221;
matches an empty string
after any newline in addition to its normal function, and
&#8220;$&#8221;
matches
an empty string before any newline in addition to its normal function.
<P><DT><A NAME="M15"><B>TCL_REG_NOSUB</B></A><DD>
Compile for matching that reports only success or failure,
not what was matched.  This reduces compile overhead and may improve
performance.  Subsequent calls to <B>Tcl_RegExpGetInfo</B> or
<B>Tcl_RegExpRange</B> will not report any match information.
<P><DT><A NAME="M16"><B>TCL_REG_CANMATCH</B></A><DD>
Compile for matching that reports the potential to complete a partial
match given more text (see below).
<P></DL>
<P>
Only one of
<B>TCL_REG_EXTENDED</B>,
<B>TCL_REG_ADVANCED</B>,
<B>TCL_REG_BASIC</B>, and
<B>TCL_REG_QUOTE</B> may be specified.
<P>
<B>Tcl_RegExpExecObj</B> executes the regular expression pattern
matcher.  It returns 1 if <I>objPtr</I> contains a range of characters
that match <I>regexp</I>, 0 if no match is found, and -1 if an error
occurs.  In the case of an error, <B>Tcl_RegExpExecObj</B> leaves an
error message in the interpreter result.  The <I>nmatches</I> value
indicates to the matcher how many subexpressions are of interest.  If
<I>nmatches</I> is 0, then no subexpression match information is
recorded, which may allow the matcher to make various optimizations.
If the value is -1, then all of the subexpressions in the pattern are
remembered.  If the value is a positive integer, then only that number
of subexpressions will be remembered.  Matching begins at the
specified Unicode character index given by <I>offset</I>.  Unlike
<B>Tcl_RegExpExec</B>, the behavior of anchors is not affected by the
offset value.  Instead the behavior of the anchors is explicitly
controlled by the <I>eflags</I> argument, which is a bit-wise OR of
zero or more of the following flags:
<P>
<DL class="description">
<DT><A NAME="M17"><B>TCL_REG_NOTBOL</B></A><DD>
The starting character will not be treated as the beginning of a
line or the beginning of the string, so
&#8220;^&#8221;
will not match there.
Note that this flag has no effect on how
&#8220;<B>&#92;A</B>&#8221;
matches.
<P><DT><A NAME="M18"><B>TCL_REG_NOTEOL</B></A><DD>
The last character in the string will not be treated as the end of a
line or the end of the string, so
&#8220;$&#8221;
will not match there.
Note that this flag has no effect on how
&#8220;<B>&#92;Z</B>&#8221;
matches.
<P></DL>
<P>
<B>Tcl_RegExpGetInfo</B> retrieves information about the last match
performed with a given regular expression <I>regexp</I>.  The
<I>infoPtr</I> argument contains a pointer to a structure that is
defined as follows:
<P>
<PRE>typedef struct Tcl_RegExpInfo {
    int <I>nsubs</I>;
    Tcl_RegExpIndices *<I>matches</I>;
    long <I>extendStart</I>;
} <B>Tcl_RegExpInfo</B>;</PRE>
<P>
The <I>nsubs</I> field contains a count of the number of parenthesized
subexpressions within the regular expression.  If the <B>TCL_REG_NOSUB</B>
was used, then this value will be zero.  The <I>matches</I> field
points to an array of <I>nsubs</I>+1 values that indicate the bounds of each
subexpression matched.  The first element in the array refers to the
range matched by the entire regular expression, and subsequent elements
refer to the parenthesized subexpressions in the order that they
appear in the pattern.  Each element is a structure that is defined as
follows:
<P>
<PRE>typedef struct Tcl_RegExpIndices {
    long <I>start</I>;
    long <I>end</I>;
} <B>Tcl_RegExpIndices</B>;</PRE>
<P>
The <I>start</I> and <I>end</I> values are Unicode character indices
relative to the offset location within <I>objPtr</I> where matching began.
The <I>start</I> index identifies the first character of the matched
subexpression.  The <I>end</I> index identifies the first character
after the matched subexpression.  If the subexpression matched the
empty string, then <I>start</I> and <I>end</I> will be equal.  If the
subexpression did not participate in the match, then <I>start</I> and
<I>end</I> will be set to -1.
<P>
The <I>extendStart</I> field in <B>Tcl_RegExpInfo</B> is only set if the
<B>TCL_REG_CANMATCH</B> flag was used.  It indicates the first
character in the string where a match could occur.  If a match was
found, this will be the same as the beginning of the current match.
If no match was found, then it indicates the earliest point at which a
match might occur if additional text is appended to the string.  If it
is no match is possible even with further text, this field will be set 
to -1.
<H3><A NAME="M19">SEE ALSO</A></H3>
<B><A HREF="../TclCmd/re_syntax.htm">re_syntax</A></B>
<H3><A NAME="M20">KEYWORDS</A></H3>
<A href="../Keywords/M.htm#match">match</A>, <A href="../Keywords/P.htm#pattern">pattern</A>, <A href="../Keywords/R.htm#regular expression">regular expression</A>, <A href="../Keywords/S.htm#string">string</A>, <A href="../Keywords/S.htm#subexpression">subexpression</A>, <A href="../Keywords/T.htm#Tcl_RegExpIndices">Tcl_RegExpIndices</A>, <A href="../Keywords/T.htm#Tcl_RegExpInfo">Tcl_RegExpInfo</A>
<div class="copy">Copyright &copy; 1994 The Regents of the University of California.
Copyright &copy; 1994-1996 Sun Microsystems, Inc.
Copyright &copy; 1998-1999 Scriptics Corporation
</div>
</BODY></HTML>
