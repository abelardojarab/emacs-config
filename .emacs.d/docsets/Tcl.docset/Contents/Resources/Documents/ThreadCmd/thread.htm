<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>thread manual page - Threading</TITLE>
<link rel="stylesheet" href="../docs.css" type="text/css" media="all">
</HEAD>
<BODY><H2><a href="../contents.htm">Tcl8.6.0/Tk8.6.0 Documentation</a> <small>&gt;</small> <a href="contents.htm">Thread Package Commands, version 2.7.0</a> <small>&gt;</small> thread</H2>
<H3><A HREF="../UserCmd/contents.htm">Tcl/Tk Applications</A> | <A HREF="../TclCmd/contents.htm">Tcl Commands</A> | <A HREF="../TkCmd/contents.htm">Tk Commands</A> | <A HREF="../ItclCmd/contents.htm">[incr Tcl] Package Commands</A> | <A HREF="../Sqlite3Cmd/contents.htm">SQLite Package Commands</A> | <A HREF="../TdbcCmd/contents.htm">TDBC Package Commands</A> | <A HREF="../TdbcmysqlCmd/contents.htm">tdbc::mysql Package Commands</A> | <A HREF="../TdbcodbcCmd/contents.htm">tdbc::odbc Package Commands</A> | <A HREF="../TdbcpostgresCmd/contents.htm">tdbc::postgres Package Commands</A> | <A HREF="../Tdbcsqlite3Cmd/contents.htm">tdbc::sqlite3 Package Commands</A> | <A HREF="../ThreadCmd/contents.htm">Thread Package Commands</A> | <A HREF="../TclLib/contents.htm">Tcl C API</A> | <A HREF="../TkLib/contents.htm">Tk C API</A> | <A HREF="../ItclLib/contents.htm">[incr Tcl] Package C API</A> | <A HREF="../TdbcLib/contents.htm">TDBC Package C API</A></H3>
<DL>
<DD><A HREF="thread.htm#M2" NAME="L2">NAME</A>
<DL><DD>thread &mdash; Extension for script access to Tcl threading</DD></DL>
<DD><A HREF="thread.htm#M3" NAME="L3">SYNOPSIS</A>
<DL>
</DL>
<DD><A HREF="thread.htm#M4" NAME="L4">DESCRIPTION</A>
<DD><A HREF="thread.htm#M5" NAME="L5">COMMANDS</A>
<DL class="commands">
<DD><A HREF="thread.htm#M6" NAME="L6"><B>thread::create</B> ?-joinable? ?-preserved? ?script?</A>
</DL>
<DL class="commands">
<DD><A HREF="thread.htm#M7" NAME="L7"><B>thread::preserve</B> ?id?</A>
<DD><A HREF="thread.htm#M8" NAME="L8"><B>thread::release</B> ?-wait? ?id?</A>
<DD><A HREF="thread.htm#M9" NAME="L9"><B>thread::id</B></A>
<DD><A HREF="thread.htm#M10" NAME="L10"><B>thread::errorproc</B> ?procname?</A>
</DL>
<DL class="commands">
<DD><A HREF="thread.htm#M11" NAME="L11"><B>thread::unwind</B></A>
<DD><A HREF="thread.htm#M12" NAME="L12"><B>thread::exit</B></A>
<DD><A HREF="thread.htm#M13" NAME="L13"><B>thread::names</B></A>
<DD><A HREF="thread.htm#M14" NAME="L14"><B>thread::exists</B> <I>id</I></A>
<DD><A HREF="thread.htm#M15" NAME="L15"><B>thread::send</B> ?-async? ?-head? <I>id</I> <I>script</I> ?varname?</A>
</DL>
<DL class="commands">
<DD><A HREF="thread.htm#M16" NAME="L16"><B>thread::broadcast</B> <I>id</I> <I>script</I></A>
<DD><A HREF="thread.htm#M17" NAME="L17"><B>thread::wait</B></A>
</DL>
<DL class="commands">
<DD><A HREF="thread.htm#M18" NAME="L18"><B>thread::eval</B> ?-lock mutex? <I>arg</I> ?arg ...?</A>
<DD><A HREF="thread.htm#M19" NAME="L19"><B>thread::join</B> <I>id</I></A>
<DD><A HREF="thread.htm#M20" NAME="L20"><B>thread::configure</B> <I>id</I> ?option? ?value? ?...?</A>
<DD><A HREF="thread.htm#M21" NAME="L21"><B>thread::transfer</B> <I>id</I> <I>channel</I></A>
</DL>
<DL class="commands">
<DD><A HREF="thread.htm#M22" NAME="L22"><B>thread::detach</B> <I>channel</I></A>
<DD><A HREF="thread.htm#M23" NAME="L23"><B>thread::attach</B> <I>channel</I></A>
<DD><A HREF="thread.htm#M24" NAME="L24"><B>thread::mutex</B></A>
<DL class="commands">
<DD><A HREF="thread.htm#M25" NAME="L25"><B>thread::mutex</B> <B>create</B> ?-recursive?</A>
<DD><A HREF="thread.htm#M26" NAME="L26"><B>thread::mutex</B> <B>destroy</B> <I>mutex</I></A>
<DD><A HREF="thread.htm#M27" NAME="L27"><B>thread::mutex</B> <B>lock</B> <I>mutex</I></A>
<DD><A HREF="thread.htm#M28" NAME="L28"><B>thread::mutex</B> <B>unlock</B> <I>mutex</I></A>
</DL>
<DD><A HREF="thread.htm#M29" NAME="L29"><B>thread::rwmutex</B></A>
<DL class="commands">
<DD><A HREF="thread.htm#M30" NAME="L30"><B>thread::rwmutex</B> <B>create</B></A>
<DD><A HREF="thread.htm#M31" NAME="L31"><B>thread::rwmutex</B> <B>destroy</B> <I>mutex</I></A>
<DD><A HREF="thread.htm#M32" NAME="L32"><B>thread::rwmutex</B> <B>rlock</B> <I>mutex</I></A>
<DD><A HREF="thread.htm#M33" NAME="L33"><B>thread::rwmutex</B> <B>wlock</B> <I>mutex</I></A>
<DD><A HREF="thread.htm#M34" NAME="L34"><B>thread::rwmutex</B> <B>unlock</B> <I>mutex</I></A>
</DL>
<DD><A HREF="thread.htm#M35" NAME="L35"><B>thread::cond</B></A>
<DL class="commands">
<DD><A HREF="thread.htm#M36" NAME="L36"><B>thread::cond</B> <B>create</B></A>
<DD><A HREF="thread.htm#M37" NAME="L37"><B>thread::cond</B> <B>destroy</B> <I>cond</I></A>
<DD><A HREF="thread.htm#M38" NAME="L38"><B>thread::cond</B> <B>notify</B> <I>cond</I></A>
<DD><A HREF="thread.htm#M39" NAME="L39"><B>thread::cond</B> <B>wait</B> <I>cond</I> <I>mutex</I> ?ms?</A>
</DL>
</DL>
<DD><A HREF="thread.htm#M40" NAME="L40">DISCUSSION</A>
<DD><A HREF="thread.htm#M41" NAME="L41">SEE ALSO</A>
<DD><A HREF="thread.htm#M42" NAME="L42">KEYWORDS</A>
</DL>
<H3><A NAME="M2">NAME</A></H3>
thread &mdash; Extension for script access to Tcl threading
<H3><A NAME="M3">SYNOPSIS</A></H3>
package require <B>Tcl  8.4</B><BR>
package require <B>Thread  ?2.7?</B><BR>
<B>thread::create</B> ?-joinable? ?-preserved? ?script?<BR>
<B>thread::preserve</B> ?id?<BR>
<B>thread::release</B> ?-wait? ?id?<BR>
<B>thread::id</B><BR>
<B>thread::errorproc</B> ?procname?<BR>
<B>thread::unwind</B><BR>
<B>thread::exit</B><BR>
<B>thread::names</B><BR>
<B>thread::exists</B> <I>id</I><BR>
<B>thread::send</B> ?-async? ?-head? <I>id</I> <I>script</I> ?varname?<BR>
<B>thread::broadcast</B> <I>id</I> <I>script</I><BR>
<B>thread::wait</B><BR>
<B>thread::eval</B> ?-lock mutex? <I>arg</I> ?arg ...?<BR>
<B>thread::join</B> <I>id</I><BR>
<B>thread::configure</B> <I>id</I> ?option? ?value? ?...?<BR>
<B>thread::transfer</B> <I>id</I> <I>channel</I><BR>
<B>thread::detach</B> <I>channel</I><BR>
<B>thread::attach</B> <I>channel</I><BR>
<B>thread::mutex</B><BR>
<B>thread::mutex</B> <B>create</B> ?-recursive?<BR>
<B>thread::mutex</B> <B><A HREF="../TkCmd/destroy.htm">destroy</A></B> <I>mutex</I><BR>
<B>thread::mutex</B> <B>lock</B> <I>mutex</I><BR>
<B>thread::mutex</B> <B>unlock</B> <I>mutex</I><BR>
<B>thread::rwmutex</B><BR>
<B>thread::rwmutex</B> <B>create</B><BR>
<B>thread::rwmutex</B> <B><A HREF="../TkCmd/destroy.htm">destroy</A></B> <I>mutex</I><BR>
<B>thread::rwmutex</B> <B>rlock</B> <I>mutex</I><BR>
<B>thread::rwmutex</B> <B>wlock</B> <I>mutex</I><BR>
<B>thread::rwmutex</B> <B>unlock</B> <I>mutex</I><BR>
<B>thread::cond</B><BR>
<B>thread::cond</B> <B>create</B><BR>
<B>thread::cond</B> <B><A HREF="../TkCmd/destroy.htm">destroy</A></B> <I>cond</I><BR>
<B>thread::cond</B> <B>notify</B> <I>cond</I><BR>
<B>thread::cond</B> <B>wait</B> <I>cond</I> <I>mutex</I> ?ms?<BR>
<H3><A NAME="M4">DESCRIPTION</A></H3>
The <B>thread</B> extension creates threads that contain Tcl
interpreters, and it lets you send scripts to those threads for
evaluation.
Additionaly, it provides script-level access to basic thread
synchronization primitives, like mutexes and condition variables.
<H3><A NAME="M5">COMMANDS</A></H3>
This section describes commands for creating and destroying threads
and sending scripts to threads for evaluation.
<P>
<DL class="commands">
<DT><A NAME="M6"><B>thread::create</B> ?-joinable? ?-preserved? ?script?</A><DD>
This command creates a thread that contains a Tcl interpreter.
The Tcl interpreter either evaluates the optional <B>script</B>, if
specified, or it waits in the event loop for scripts that arrive via
the <B>thread::send</B> command. The result, if any, of the
optional <B>script</B> is never returned to the caller.
The result of <B>thread::create</B> is the ID of the thread. This is
the opaque handle which identifies the newly created thread for
all other package commands. The handle of the thread goes out of scope
automatically when thread is marked for exit
(see the <B>thread::release</B> command below).
<P>
If the optional <B>script</B> argument contains the <B>thread::wait</B>
command the thread will enter into the event loop. If such command is not
found  in the <B>script</B> the thread will run the <B>script</B> to
the end and exit. In that case, the handle may be safely ignored since it
refers to a thread which does not exists any more at the time when the
command returns.
<P>
Using flag <B>-joinable</B> it is possible to create a joinable
thread, i.e. one upon whose exit can be waited upon by using
<B>thread::join</B> command.
Note that failure to join a thread created with <B>-joinable</B> flag
results in resource and memory leaks.
<P>
Threads created by the <B>thread::create</B> cannot be destroyed
forcefully. Consequently, there is no corresponding thread destroy
command. A thread may only be released using the <B>thread::release</B>
and if its internal reference count drops to zero, the thread is
marked for exit. This kicks the thread out of the event loop
servicing and the thread continues to execute commands passed in
the <B>script</B> argument, following the <B>thread::wait</B>
command. If this was the last command in the script, as usualy the
case, the thread will exit.
<P>
It is possible to create a situation in which it may be impossible
to terminate the thread, for example by putting some endless loop
after the <B>thread::wait</B> or entering the event loop again by
doing an vwait-type of command. In such cases, the thread may never
exit. This is considered to be a bad practice and should be avoided
if possible. This is best illustrated by the example below:
<P></DL>
# You should never do ...<BR>
    set tid [thread::create {<BR>
        package require Http<BR>
        thread::wait<BR>
        vwait forever ; # &lt;-- this!<BR>
    }]<BR>
The thread created in the above example will never be able to exit.
After it has been released with the last matching <B>thread::release</B>
call, the thread will jump out of the <B>thread::wait</B> and continue
to execute commands following. It will enter <B><A HREF="../TclCmd/vwait.htm">vwait</A></B> command and
wait endlessly for events. There is no way one can terminate such thread,
so you wouldn't want to do this!
<P>
Each newly created has its internal reference counter set to 0 (zero),
i.e. it is unreserved. This counter gets incremented by a call to
<B>thread::preserve</B> and decremented by a call to <B>thread::release</B>
command. These two commands implement simple but effective thread
reservation system and offer predictable and controllable thread
termination capabilities. It is however possible to create initialy
preserved threads by using flag <B>-preserved</B> of the
<B>thread::create</B> command. Threads created with this flag have the
initial value of the reference counter of 1 (one), and are thus
initially marked reserved.
<P>
<DL class="commands">
<DT><A NAME="M7"><B>thread::preserve</B> ?id?</A><DD>
This command increments the thread reference counter. Each call
to this command increments the reference counter by one (1).
Command returns the value of the reference counter after the increment.
If called with the optional thread <B>id</B>, the command preserves
the given thread. Otherwise the current thread is preserved.
<P>
With reference counting, one can implement controlled access to a
shared Tcl thread. By incrementing the reference counter, the
caller signalizes that he/she wishes to use the thread for a longer
period of time. By decrementing the counter, caller signalizes that
he/she has finished using the thread.
<P><DT><A NAME="M8"><B>thread::release</B> ?-wait? ?id?</A><DD>
This command decrements the thread reference counter. Each call to
this command decrements the reference counter by one (1).
If called with the optional thread <B>id</B>, the command releases
the given thread. Otherwise, the current thread is released.
Command returns the value of the reference counter after the decrement.
When the reference counter reaches zero (0), the target thread is
marked for termination. You should not reference the thread after the
<B>thread::release</B> command returns zero or negative integer.
The handle of the thread goes out of scope and should not be used any
more. Any following reference to the same thread handle will result
in Tcl error.
<P>
Optional flag <B>-wait</B> instructs the caller thread to wait for
the target thread to exit, if the effect of the command would result
in termination of the target thread, i.e. if the return result would
be zero (0). Without the flag, the caller thread does not wait for
the target thread to exit. Care must be taken when using the
<B>-wait</B>, since this may block the caller thread indefinitely.
This option has been implemented for some special uses of the extension
and is deprecated for regular use. Regular users should create joinable
threads by using the <B>-joinable</B> option of the <B>thread::create</B>
command and the <B>thread::join</B> to wait for thread to exit.
<P><DT><A NAME="M9"><B>thread::id</B></A><DD>
This command returns the ID of the current thread.
<P><DT><A NAME="M10"><B>thread::errorproc</B> ?procname?</A><DD>
This command sets a handler for errors that occur in scripts sent
asynchronously, using the <B>-async</B> flag of the
<B>thread::send</B> command, to other threads. If no handler
is specified, the current handler is returned. The empty string
resets the handler to default (unspecified) value.
An uncaught error in a thread causes an error message to be sent
to the standard error channel. This default reporting scheme can
be changed by registering a procedure which is called to report
the error. The <I>procname</I> is called in the interpreter that
invoked the <B>thread::errorproc</B> command. The <I>procname</I>
is called like this:
<P></DL>
myerrorproc thread_id errorInfo<BR>
<P>
<DL class="commands">
<DT><A NAME="M11"><B>thread::unwind</B></A><DD>
Use of this command is deprecated in favour of more advanced thread
reservation system implemented with <B>thread::preserve</B> and
<B>thread::release</B> commands. Support for <B>thread::unwind</B>
command will dissapear in some future major release of the extension.
<P>
This command stops a prior <B>thread::wait</B> command. Execution of
the script passed to newly created thread will continue from the
<B>thread::wait</B> command. If <B>thread::wait</B> was the last command
in the script, the thread will exit. The command returns empty result
but may trigger Tcl error with the message &quot;target thread died&quot; in some
situations.
<P><DT><A NAME="M12"><B>thread::exit</B></A><DD>
Use of this command is deprecated in favour of more advanced thread
reservation system implemented with <B>thread::preserve</B> and
<B>thread::release</B> commands. Support for <B>thread::exit</B>
command will dissapear in some future major release of the extension.
<P>
This command forces a thread stuck in the <B>thread::wait</B>
command to unconditionaly exit. The execution of <B>thread::exit</B>
command is guaranteed to leave the program memory in the unconsistent
state, produce memory leaks and otherwise affect other subsytem(s)
of the Tcl application in an unpredictable manner. The command
returns empty result but may trigger Tcl error with the message
&quot;target thread died&quot; in some situations.
<P><DT><A NAME="M13"><B>thread::names</B></A><DD>
This command returns a list of thread IDs. These are only for
threads that have been created via <B>thread::create</B> command.
If your application creates other threads at the C level, they
are not reported by this command.
<P><DT><A NAME="M14"><B>thread::exists</B> <I>id</I></A><DD>
Returns true (1) if thread given by the <I>id</I> parameter exists,
false (0) otherwise. This applies only for threads that have
been created via <B>thread::create</B> command.
<P><DT><A NAME="M15"><B>thread::send</B> ?-async? ?-head? <I>id</I> <I>script</I> ?varname?</A><DD>
This command passes a <I>script</I> to another thread and, optionally,
waits for the result. If the <B>-async</B> flag is specified, the
command does not wait for the result and it returns empty string.
The target thread must enter it's event loop in order to receive
scripts sent via this command. This is done by default for threads
created without a startup script. Threads can enter the event loop
explicitly by calling <B>thread::wait</B> or any other relevant Tcl/Tk
command, like <B><A HREF="../TclCmd/update.htm">update</A></B>, <B><A HREF="../TclCmd/vwait.htm">vwait</A></B>, etc.
<P>
Optional <B>varname</B> specifies name of the variable to store
the result of the <I>script</I>. Without the <B>-async</B> flag,
the command returns the evaluation code, similarily to the standard
Tcl <B><A HREF="../TclCmd/catch.htm">catch</A></B> command. If, however, the <B>-async</B> flag is
specified, the command returns immediately and caller can later
<B><A HREF="../TclCmd/vwait.htm">vwait</A></B> on ?varname? to get the result of the passed <I>script</I>
<P></DL>
set t1 [thread::create]<BR>
    set t2 [thread::create]<BR>
    thread::send -async $t1 &quot;set a 1&quot; result<BR>
    thread::send -async $t2 &quot;set b 2&quot; result<BR>
    for {set i 0} {$i &lt; 2} {incr i} {<BR>
        vwait result<BR>
    }<BR>
In the above example, two threads were fed work and both of them were
instructed to signalize the same variable &quot;result&quot; in the calling thread.
The caller entered the event loop twice to get both results. Note,
however, that the order of the received results may vary, depending on
the current system load, type of work done, etc, etc.
<P>
Many threads can simultaneously send scripts to the target thread for
execution. All of them are entered into the event queue of the target
thread and executed on the FIFO basis, intermingled with optional other
events pending in the event queue of the target thread.
Using the optional ?-head? switch, scripts posted to the thread's
event queue can be placed on the head, instead on the tail of the queue,
thus being executed in the LIFO fashion.
<P>
<DL class="commands">
<DT><A NAME="M16"><B>thread::broadcast</B> <I>id</I> <I>script</I></A><DD>
This command passes a <I>script</I> to all threads created by the
package for execution. It does not wait for response from any of
the threads.
<P><DT><A NAME="M17"><B>thread::wait</B></A><DD>
This enters the event loop so a thread can receive messages from
the <B>thread::send</B> command. This command should only be used
within the script passed to the <B>thread::create</B>. It should
be the very last command in the script. If this is not the case,
the exiting thread will continue executing the script lines pass
the <B>thread::wait</B> which is usually not what you want and/or
expect.
<P></DL>
set t1 [thread::create {<BR>
        #<BR>
        # Do some initialization work here<BR>
        #<BR>
        thread::wait ; # Enter the event loop<BR>
    }]<BR>
<P>
<DL class="commands">
<DT><A NAME="M18"><B>thread::eval</B> ?-lock mutex? <I>arg</I> ?arg ...?</A><DD>
This command concatenates passed arguments and evaluates the
resulting script under the mutex protection. If no mutex is
specified by using the ?-lock mutex? optional argument,
the internal static mutex is used.
<P><DT><A NAME="M19"><B>thread::join</B> <I>id</I></A><DD>
This command waits for the thread with ID <I>id</I> to exit and
then returns it's exit code. Errors will be returned for threads
which are not joinable or already waited upon by another thread.
Upon the join the handle of the thread has gone out of scope and
should not be used any more.
<P><DT><A NAME="M20"><B>thread::configure</B> <I>id</I> ?option? ?value? ?...?</A><DD>
This command configures various low-level aspects of the thread with
ID <I>id</I> in the similar way as the standard Tcl command
<B><A HREF="../TclCmd/fconfigure.htm">fconfigure</A></B> configures some Tcl channel options. Options currently
supported are: <B>-eventmark</B> and <B>-unwindonerror</B>.
<P>
The <B>-eventmark</B> option, when set, limits the number of
asynchronously posted scripts to the thread event loop.
The <B>thread::send -async</B> command will block until the number
of pending scripts in the event loop does not drop below the value
configured with <B>-eventmark</B>. Default value for the
<B>-eventmark</B> is 0 (zero) which effectively disables the checking,
i.e. allows for unlimited number of posted scripts.
<P>
The <B>-unwindonerror</B> option, when set, causes the
target thread to unwind if the result of the script processing
resulted in error. Default value for the <B>-unwindonerror</B>
is 0 (false), i.e. thread continues to process scripts after one
of the posted scripts fails.
<P><DT><A NAME="M21"><B>thread::transfer</B> <I>id</I> <I>channel</I></A><DD>
This moves the specified <I>channel</I> from the current thread
and interpreter to the main interpreter of the thread with the
given <I>id</I>. After the move the current interpreter has no
access to the channel any more, but the main interpreter of the
target thread will be able to use it from now on.
The command waits until the other thread has incorporated the
channel. Because of this it is possible to deadlock the
participating threads by commanding the other through a
synchronous <B>thread::send</B> to transfer a channel to us.
This easily extends into longer loops of threads waiting for
each other. Other restrictions: the channel in question must
not be shared among multiple interpreters running in the
sending thread. This automatically excludes the special channels
for standard input, output and error.
<P>
Due to the internal Tcl core implementation and the restriction on
transferring shared channels, one has to take extra measures when
transferring socket channels created by accepting the connection
out of the <B><A HREF="../TclCmd/socket.htm">socket</A></B> commands callback procedures:
<P></DL>
socket -server _Accept 2200<BR>
    proc _Accept {s ipaddr port} {<BR>
        after idle [list Accept $s $ipaddr $port]<BR>
    }<BR>
    proc Accept {s ipaddr port} {<BR>
        set tid [thread::create]<BR>
        thread::transfer $tid $s<BR>
    }<BR>
<P>
<DL class="commands">
<DT><A NAME="M22"><B>thread::detach</B> <I>channel</I></A><DD>
This detaches the specified <I>channel</I> from the current thread and
interpreter. After that, the current interpreter has no access to the
channel any more. The channel is in the parked state until some other
(or the same) thread attaches the channel again with <B>thread::attach</B>.
Restrictions: same as for transferring shared channels with the
<B>thread::transfer</B> command.
<P><DT><A NAME="M23"><B>thread::attach</B> <I>channel</I></A><DD>
This attaches the previously detached <I>channel</I> in the
current thread/interpreter. For already existing channels,
the command does nothing, i.e. it is not an error to attach the
same channel more than once. The first operation will actualy
perform the operation, while all subsequent operation will just
do nothing. Command throws error if the <I>channel</I> cannot be
found in the list of detached channels and/or in the current
interpreter.
<P><DT><A NAME="M24"><B>thread::mutex</B></A><DD>
Mutexes are most common thread synchronization primitives.
They are used to synchronize access from two or more threads to one or
more shared resources. This command provides script-level access to
exclusive and/or recursive mutexes. Exclusive mutexes can be locked
only once by one thread, while recursive mutexes can be locked many
times by the same thread. For recursive mutexes, number of lock and
unlock operations must match, otherwise, the mutex will never be
released, which would lead to various deadlock situations.
<P>
Care has to be taken when using mutexes in an multithreading program.
Improper use of mutexes may lead to various deadlock situations,
especially when using exclusive mutexes.
<P>
The <B>thread::mutex</B> command supports following subcommands and options:
<P>
<DL class="commands">
<DT><A NAME="M25"><B>thread::mutex</B> <B>create</B> ?-recursive?</A><DD>
Creates the mutex and returns it's opaque handle. This handle
should be used for any future reference to the newly created mutex.
If no optional ?-recursive? argument was specified, the command
creates the exclusive mutex. With the ?-recursive? argument,
the command creates a recursive mutex.
<P><DT><A NAME="M26"><B>thread::mutex</B> <B>destroy</B> <I>mutex</I></A><DD>
Destroys the <I>mutex</I>. Mutex should be in unlocked state before
the destroy attempt. If the mutex is locked, the command will throw
Tcl error.
<P><DT><A NAME="M27"><B>thread::mutex</B> <B>lock</B> <I>mutex</I></A><DD>
Locks the <I>mutex</I>. Locking the exclusive mutex may throw Tcl
error if on attempt to lock the same mutex twice from the same
thread. If your program logic forces you to lock the same mutex
twice or more from the same thread (this may happen in recursive
procedure invocations) you should consider using the recursive mutexes.
<P><DT><A NAME="M28"><B>thread::mutex</B> <B>unlock</B> <I>mutex</I></A><DD>
Unlocks the <I>mutex</I> so some other thread may lock it again.
Attempt to unlock the already unlocked mutex will throw Tcl error.
<P></DL>
<P>
<P><DT><A NAME="M29"><B>thread::rwmutex</B></A><DD>
This command creates many-readers/single-writer mutexes. Reader/writer
mutexes allow you to serialize access to a shared resource more optimally.
In situations where a shared resource gets mostly read and seldom modified,
you might gain some performace by using reader/writer mutexes instead of
exclusive or recursive mutexes.
<P>
For reading the resource, thread should obtain a read lock on the resource.
Read lock is non-exclusive, meaning that more than one thread can
obtain a read lock to the same resource, without waiting on other readers.
For changing the resource, however, a thread must obtain a exclusive
write lock. This lock effectively blocks all threads from gaining the
read-lock while the resource is been modified by the writer thread.
Only after the write lock has been released, the resource may be read-locked
again.
<P>
The <B>thread::rwmutex</B> command supports following subcommands and options:
<P>
<DL class="commands">
<DT><A NAME="M30"><B>thread::rwmutex</B> <B>create</B></A><DD>
Creates the reader/writer mutex and returns it's opaque handle.
This handle should be used for any future reference to the newly
created mutex.
<P><DT><A NAME="M31"><B>thread::rwmutex</B> <B>destroy</B> <I>mutex</I></A><DD>
Destroys the reader/writer <I>mutex</I>. If the mutex is already locked,
attempt to destroy it will throw Tcl error.
<P><DT><A NAME="M32"><B>thread::rwmutex</B> <B>rlock</B> <I>mutex</I></A><DD>
Locks the <I>mutex</I> for reading. More than one thread may read-lock
the same <I>mutex</I> at the same time.
<P><DT><A NAME="M33"><B>thread::rwmutex</B> <B>wlock</B> <I>mutex</I></A><DD>
Locks the <I>mutex</I> for writing. Only one thread may write-lock
the same <I>mutex</I> at the same time. Attempt to write-lock same
<I>mutex</I> twice from the same thread will throw Tcl error.
<P><DT><A NAME="M34"><B>thread::rwmutex</B> <B>unlock</B> <I>mutex</I></A><DD>
Unlocks the <I>mutex</I> so some other thread may lock it again.
Attempt to unlock already unlocked <I>mutex</I> will throw Tcl error.
<P></DL>
<P>
<P><DT><A NAME="M35"><B>thread::cond</B></A><DD>
This command provides script-level access to condition variables.
A condition variable creates a safe environment for the program
to test some condition, sleep on it when false and be awakened
when it might have become true. A condition variable is always
used in the conjuction with an exclusive mutex. If you attempt
to use other type of mutex in conjuction with the condition
variable, a Tcl error will be thrown.
<P>
The command supports following subcommands and options:
<P>
<DL class="commands">
<DT><A NAME="M36"><B>thread::cond</B> <B>create</B></A><DD>
Creates the condition variable and returns it's opaque handle.
This handle should be used for any future reference to newly
created condition variable.
<P><DT><A NAME="M37"><B>thread::cond</B> <B>destroy</B> <I>cond</I></A><DD>
Destroys condition variable <I>cond</I>. Extreme care has to be taken
that nobody is using (i.e. waiting on) the condition variable,
otherwise unexpected errors may happen.
<P><DT><A NAME="M38"><B>thread::cond</B> <B>notify</B> <I>cond</I></A><DD>
Wakes up all threads waiting on the condition variable <I>cond</I>.
<P><DT><A NAME="M39"><B>thread::cond</B> <B>wait</B> <I>cond</I> <I>mutex</I> ?ms?</A><DD>
This command is used to suspend program execution until the condition
variable <I>cond</I> has been signalled or the optional timer has expired.
The exclusive <I>mutex</I> must be locked by the calling thread on entrance
to this command. If the mutex is not locked, Tcl error is thrown.
While waiting on the <I>cond</I>, the command releases <I>mutex</I>.
Before returning to the calling thread, the command re-acquires the
<I>mutex</I> again. Unlocking the <I>mutex</I> and waiting on the
condition variable <I>cond</I> is done atomically.
<P>
The <B>ms</B> command option, if given, must be an integer specifying
time interval in milliseconds the command waits to be signalled.
Otherwise the command waits on condition notify forever.
<P>
In multithreading programs, there are many situations where a thread has
to wait for some event to happen until it is allowed to proceed.
This is usually accomplished by repeatedly testing a condition under the
mutex protection and waiting on the condition variable until the condition
evaluates to true:
<P></DL>
<DL><DD>
set mutex [thread::mutex create]<BR>
    set cond  [thread::cond  create]<BR>
<BR>
    thread::mutex lock $mutex<BR>
    while {&lt;some_condition_is_true&gt;} {<BR>
        thread::cond wait $cond $mutex<BR>
    }<BR>
    # Do some work under mutex protection<BR>
    thread::mutex unlock $mutex<BR>
Repeated testing of the condition is needed since the condition variable
may get signalled without the condition being actually changed (spurious
thread wake-ups, for example).
</DL>
<P></DL>
<H3><A NAME="M40">DISCUSSION</A></H3>
The fundamental threading model in Tcl is that there can be one or
more Tcl interpreters per thread, but each Tcl interpreter should
only be used by a single thread which created it.
A &quot;shared memory&quot; abstraction is awkward to provide in Tcl because
Tcl makes assumptions about variable and data ownership. Therefore
this extension supports a simple form of threading where the main
thread can manage several background, or &quot;worker&quot; threads.
For example, an event-driven server can pass requests to worker
threads, and then await responses from worker threads or new client
requests. Everything goes through the common Tcl event loop, so
message passing between threads works naturally with event-driven I/O,
<B><A HREF="../TclCmd/vwait.htm">vwait</A></B> on variables, and so forth. For the transfer of bulk
information it is possible to move channels between the threads.
<P>
For advanced multithreading scripts, script-level access to two
basic synchronization primitives, mutex and condition variables,
is also supported.
<H3><A NAME="M41">SEE ALSO</A></H3>
<B><I><A HREF="http://www.tcl.tk/doc/howto/thread_model.html">http://www.tcl.tk/doc/howto/thread_model.html</A></I></B>, <B><A HREF="../ThreadCmd/tpool.htm">tpool</A></B>, <B><A HREF="../ThreadCmd/tsv.htm">tsv</A></B>, <B><A HREF="../ThreadCmd/ttrace.htm">ttrace</A></B>
<H3><A NAME="M42">KEYWORDS</A></H3>
<A href="../Keywords/E.htm#events">events</A>, <A href="../Keywords/M.htm#message passing">message passing</A>, <A href="../Keywords/M.htm#mutex">mutex</A>, <A href="../Keywords/S.htm#synchronization">synchronization</A>, <A href="../Keywords/T.htm#thread">thread</A>
<div class="copy"></div>
</BODY></HTML>
