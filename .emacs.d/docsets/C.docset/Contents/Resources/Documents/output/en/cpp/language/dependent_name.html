<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html class="client-nojs" dir="ltr" lang="en"><head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<title>Dependent names</title>
<meta charset="UTF-8">
<meta content="MediaWiki 1.21.2" name="generator">


<link href="../../../favicon.ico" rel="shortcut icon">



<link href="../../../common/ext.css" rel="stylesheet">
<meta content="" name="ResourceLoaderDynamicStyles">
<link href="../../../common/site_modules.css" rel="stylesheet">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/dependent_name","wgTitle":"cpp/language/dependent name","wgCurRevisionId":81903,"wgArticleId":9611,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Todo with reason"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/dependent_name","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:ca03345b1e2c4d90a25d968753a73b92 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
</head><body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_dependent_name skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 class="firstHeading" id="firstHeading">Dependent names</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>&lrm; | <a href="../language.1.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en">
<div class="t-navbar" style="">
<div class="t-navbar-sep">&nbsp;</div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div><table cellpadding="0" class="t-nv-begin" style="line-height:1.1em;">
<tbody><tr class="t-nv"><td colspan="5"> <a href="../language.1.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept.html" title="cpp/concept"> Concepts</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem"> Filesystem library</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical Specifications</a> </td></tr>
</tbody></table></div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep">&nbsp;</div>
<div class="t-navbar-head"><a href="../language.1.html" title="cpp/language"> C++ language</a></div>
<div class="t-navbar-sep">&nbsp;</div>
<div class="t-navbar-head">
<a href="templates.html" title="cpp/language/templates"> Templates</a><div class="t-navbar-menu"><div>
<div style="display:inline-block">
<div><table cellpadding="0" class="t-nv-begin" style="">
<tbody><tr class="t-nv"><td colspan="5"> <a href="template_parameters.html" title="cpp/language/template parameters"> parameters and arguments</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class_template.html" title="cpp/language/class template"> class templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function_template.html" title="cpp/language/function template"> function templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="member_template.html" title="cpp/language/member template"> class member templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="variable_template.html" title="cpp/language/variable template"> variable templates</a><span class="t-mark-rev t-since-cxx14">(C++14)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_argument_deduction.html" title="cpp/language/template argument deduction"> template argument deduction</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_specialization.html" title="cpp/language/template specialization"> explicit (full) specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="partial_specialization.html" title="cpp/language/partial specialization"> partial specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink"> dependent names</strong> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="parameter_pack.html" title="cpp/language/parameter pack"> parameter packs</a><span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table">
<div><a href="sizeof....html" title="cpp/language/sizeof..."><span class="t-lines"><span>sizeof...</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="fold.html" title="cpp/language/fold"> fold-expressions</a><span class="t-mark-rev t-since-cxx17">(C++17)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="sfinae.html" title="cpp/language/sfinae"> SFINAE</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="concepts.html" title="cpp/language/constraints"> Constraints and concepts</a><span class="t-mark-rev t-since-concepts-ts t-mark-ts">(concepts TS)</span> </td></tr>
</tbody></table></div>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep">&nbsp;</div>
</div>
<p>Inside the definition of a <a href="templates.html" title="cpp/language/templates">template</a> (both <a href="class_template.html" title="cpp/language/class template">class template</a> and <a href="function_template.html" title="cpp/language/function template">function template</a>), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may depend on types of type template parameters and values of non-type template parameters.
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> X <span class="sy4">:</span> B<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="co1">// &quot;B&lt;T&gt;&quot; is dependent on T</span>
<span class="br0">{</span>
    <span class="kw1">typename</span> T<span class="sy4">::</span><span class="me2">A</span><span class="sy2">*</span> pa<span class="sy4">;</span> <span class="co1">// &quot;T::A&quot; is dependent on T</span>
                       <span class="co1">// (see below for the meaning of this use of &quot;typename&quot;)</span>
    <span class="kw4">void</span> f<span class="br0">(</span>B<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy2">*</span> pb<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw4">static</span> <span class="kw4">int</span> i <span class="sy1">=</span> B<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span><span class="sy4">;</span> <span class="co1">// &quot;B&lt;T&gt;::i&quot; is dependent on T</span>
        pb<span class="sy2">-</span><span class="sy1">&gt;</span>j<span class="sy2">++</span><span class="sy4">;</span> <span class="co1">// &quot;pb-&gt;j&quot; is dependent on T</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>Name lookup and binding are different for <i>dependent names</i> and non-<i>dependent names</i>
</p>
<table class="toc" id="toc"><tbody><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="dependent_name.html#Binding_rules"><span class="tocnumber">1</span> <span class="toctext">Binding rules</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="dependent_name.html#Lookup_rules"><span class="tocnumber">2</span> <span class="toctext">Lookup rules</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="dependent_name.html#Dependent_types"><span class="tocnumber">3</span> <span class="toctext">Dependent types</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="dependent_name.html#Type-dependent_expressions"><span class="tocnumber">4</span> <span class="toctext">Type-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="dependent_name.html#Value-dependent_expressions"><span class="tocnumber">5</span> <span class="toctext">Value-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="dependent_name.html#Dependent_names"><span class="tocnumber">6</span> <span class="toctext">Dependent names</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="dependent_name.html#Current_instantiation"><span class="tocnumber">7</span> <span class="toctext">Current instantiation</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="dependent_name.html#Unknown_specializations"><span class="tocnumber">8</span> <span class="toctext">Unknown specializations</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="dependent_name.html#The_typename_disambiguator_for_dependent_names"><span class="tocnumber">9</span> <span class="toctext">The <span><span><span>typename</span></span></span> disambiguator for dependent names</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="dependent_name.html#The_template_disambiguator_for_dependent_names"><span class="tocnumber">10</span> <span class="toctext">The <span><span><span>template</span></span></span> disambiguator for dependent names</span></a></li>
</ul>
</td></tr></tbody></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Binding rules">edit</a>]</span> <span class="mw-headline" id="Binding_rules">Binding rules</span>
</h3>
<p>Non-dependent names are looked up and bound at the point of template definition. This binding holds even if at the point of template instantiation there is a better match: 
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1552">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;g(double)<span class="es1">\n</span>&quot;</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span>
        g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// &quot;g&quot; is a non-dependent name, bound now</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1552">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;g(int)<span class="es1">\n</span>&quot;</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(int)</span>
&nbsp;
    S<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(double)</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>If the meaning of a <i>non-dependent name</i> changes between the definition context and the point of instantiation of a specialization of the template, the program is ill-formed, no diagnostic required. This is possible in the following situations:
</p>
<ul>
<li> a type used in a non-dependent name is <a class="mw-redirect" href="incomplete_type.html" title="cpp/language/incomplete type">incomplete</a> at the point of definition but complete at the point of instantiation
</li>
<li> <span class="t-mark-rev t-since-cxx17">(C++17)</span> an instantiation uses a default argument or default template argument that had not been defined at the point of definition
</li>
<li> <span class="t-mark-rev t-since-cxx17">(C++17)</span> a <a href="constant_expression.html" title="cpp/language/constant expression">constant expression</a> at the point of instantiation uses the value of a const object of integral or unscoped enum type, the value of a constexpr object, the value of a reference, or the definition of a constexpr function, and that object/reference/function was not defined at the point of definition
</li>
<li> <span class="t-mark-rev t-since-cxx17">(C++17)</span> the template uses a non-dependent class template specialization or variable template specialization at the point of instantiation, and this template it uses is either instantiated from a partial specialization that was not defined at the point of definition or names an explicit specialization that was not declared at the point of definition
</li>
</ul>
<p>Binding of <i>dependent names</i> is postponed until lookup takes place.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Lookup rules">edit</a>]</span> <span class="mw-headline" id="Lookup_rules">Lookup rules</span>
</h3>
<p>As discussed in <a href="lookup.html" title="cpp/language/lookup">lookup</a>, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time
</p>
<ul>
<li> non-ADL lookup examines function declarations with external linkage that are visible from the <i>template definition</i> context
</li>
<li> <a href="adl.html" title="cpp/language/adl">ADL</a> examines function declarations with external linkage that are visible from both the <i>template definition</i> context and the <i>template instantiation</i> context
</li>
</ul>
<p>(in other words, adding a new function declaration after template definition does not make it visible, except via ADL).
</p>
<p>The purpose of this is rule is to help guard against violations of the <a href="definition.html#One_Definition_Rule" title="cpp/language/definition">ODR</a> for template instantiations:
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// an external libary</span>
<span class="kw1">namespace</span> E <span class="br0">{</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
  <span class="kw4">void</span> writeObject<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> t<span class="br0">)</span> <span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1552">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;Value = &quot;</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <span class="st0">&#39;<span class="es1">\n</span>&#39;</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// translation unit 1:</span>
<span class="co1">// Programmer 1 wants to allow E::writeObject to work with vector&lt;int&gt;</span>
<span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">&#39; &#39;</span><span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P1::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// translation unit 2:</span>
<span class="co1">// Programmer 2 wants to allow E::writeObject to work with vector&lt;int&gt;</span>
<span class="kw1">namespace</span> P2 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span><span class="st0">&#39;:&#39;</span><span class="sy4">;</span> <span class="kw1">return</span> os <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;[]&quot;</span><span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomethingElse<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P2::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>In the above example, if non-ADL lookup for operator&lt;&lt; were allowed from the instantiation context, the instantiation of <span class="t-c"><span class="mw-geshi cpp source-cpp">E<span class="sy4">::</span><span class="me2">writeObject</span><span class="sy1">&lt;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;&gt;</span></span></span> would have two different definitions: one using <span class="t-c"><span class="mw-geshi cpp source-cpp">P1<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span></span> and one using <span class="t-c"><span class="mw-geshi cpp source-cpp">P2<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span></span>. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.
</p>
<p>To make ADL examine a user-defined namespace, either <code>std::vector</code> should be replaced by a user-defined class or its element type should be a user-defined class:
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <span class="co1">// if C is a class defined in the P1 namespace</span>
  <a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>C<span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span>C n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n<span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>C<span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: instantiates writeObject(std::vector&lt;P1::C&gt;)</span>
                       <span class="co1">//     which finds P1::operator&lt;&lt; via ADL</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Note: this rule makes it impractical to overload operators for standard library types
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iterator&gt;</span>
<span class="co2">#include &lt;utility&gt;</span>
&nbsp;
<span class="co1">// Bad idea: operator in global namespace, but its arguments are in std::</span>
<a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1523">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <a href="../utility/pair.html"><span class="kw1014">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">double</span><span class="sy1">&gt;</span> p<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> os <span class="sy1">&lt;&lt;</span> p.<span class="me1">first</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&#39;,&#39;</span> <span class="sy1">&lt;&lt;</span> p.<span class="me1">second</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">typedef</span> <a href="../utility/pair.html"><span class="kw1014">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">double</span><span class="sy1">&gt;</span> elem_t<span class="sy4">;</span>
    <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>elem_t<span class="sy1">&gt;</span> v<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1552">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> v<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&#39;<span class="es1">\n</span>&#39;</span><span class="sy4">;</span> <span class="co1">// OK, ordinary lookup finds&nbsp;::operator&lt;&lt;</span>
    <a href="../algorithm/copy.html"><span class="kw1386">std::<span class="me2">copy</span></span></a><span class="br0">(</span>v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, v.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>,
              <a href="../iterator/ostream_iterator.html"><span class="kw647">std::<span class="me2">ostream_iterator</span></span></a><span class="sy1">&lt;</span>elem_t<span class="sy1">&gt;</span><span class="br0">(</span><a href="../io/cout.html"><span class="kw1552">std::<span class="me2">cout</span></span></a>, <span class="st0">&quot; &quot;</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Error: both ordinary </span>
    <span class="co1">// lookup from the point of definition of std::ostream_iterator and ADL will </span>
    <span class="co1">// only consider the std namespace, and will find many overloads of</span>
    <span class="co1">// std::operator&lt;&lt;, so the lookup will be done. Overload resolution will then</span>
    <span class="co1">// fail to find operator&lt;&lt; for elem_t in the set found by the lookup.</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>Note: limited lookup (but not binding) of dependent names also takes place at template definition time, as needed to distinguish them from non-dependent names and also to determine whether they are members of the current instantiation or members of unknown specialization. The information obtained by this lookup can be used to detect errors, see below.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Dependent types">edit</a>]</span> <span class="mw-headline" id="Dependent_types">Dependent types</span>
</h3>
<p>The following types are dependent types:
</p>
<ul>
<li> template parameter
</li>
<li> a member of an <i>unknown specialization</i> (see below)
</li>
<li> a nested class/enum that is a dependent member of <i>unknown specialization</i> (see below)
</li>
<li> a cv-qualified version of a dependent type
</li>
<li> a compound type constructed from a dependent type
</li>
<li> an array type whose element type is dependent or whose bound (if any) is value-dependent
</li>
<li> a template-id where either
</li>
</ul>
<dl><dd>
<ul>
<li> the template name is a template parameter, or
</li>
<li> any of template arguments is type-dependent, value-dependent, or is a pack expansion
</li>
</ul>
</dd></dl>
<ul><li> the result of <a href="decltype.html" title="cpp/language/decltype">decltype</a> applied to a type-dependent expression
</li></ul>
<p>Note: a typedef member of a current instantiation is only dependent when the type it refers to is.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Type-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Type-dependent_expressions">Type-dependent expressions</span>
</h3>
<p>The following expressions are type-dependent
</p>
<ul>
<li> an expression whose any subexpression is a type-dependent expression
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">this</span></span>, if the class is a dependent type.
</li>
<li> an <a href="name.html" title="cpp/language/identifiers">id-expression</a> that
</li>
</ul>
<dl><dd>
<ul>
<li> contains an identifier for which name lookup finds at least one dependent declaration
</li>
<li> contains a dependent template-id
</li>
<li> contains the special identifier <code>__func__</code> (if some enclosing function is a template, a non-template member of a class template<span class="t-rev-inl t-since-cxx14"><span>, or a generic lambda</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>)
</li>
<li> contains the name of <a href="cast_operator.html" title="cpp/language/cast operator">conversion function</a> to a dependent type
</li>
<li> contains a nested name specifier or <a href="name.html" title="cpp/language/identifiers">qualified-id</a> that is a member of <i>unknown specialization</i>
</li>
<li> names a dependent member of the <i>current instantiation</i> which is a static data member of type &quot;array of unknown bound&quot;
</li>
</ul>
</dd></dl>
<ul>
<li> any cast expression to a dependent type
</li>
<li> <a href="new.html" title="cpp/language/new">new-expression</a> that creates an object of a dependent type
</li>
<li> member access expression that refers to a member of the <i>current instantiation</i> whose type is dependent
</li>
<li> member access expression that refers to a member of <i>unknown specialization</i>
</li>
</ul>
 <table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17">
<td>
<ul><li> <a href="fold.html" title="cpp/language/fold">fold-expression</a>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr>
</tbody></table>
<p>Note: literals, pseudo-destructor calls, <a href="sizeof.html" title="cpp/language/sizeof">sizeof</a>, <a href="alignof.html" title="cpp/language/alignof">alignof</a>, <a href="typeid.html" title="cpp/language/typeid">typeid</a>, <a href="delete.html" title="cpp/language/delete">delete</a>-expressions, <a href="throw.html" title="cpp/language/throw">throw</a>-expressions, and <a href="noexcept.html" title="cpp/language/noexcept">noexcept</a>-expressions are never type-dependent because the types of these expressions cannot be.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Value-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Value-dependent_expressions">Value-dependent expressions</span>
</h3>
<ul>
<li> an expression used in context where <a href="constant_expression.html" title="cpp/language/constant expression">constant expression</a> is required, and whose any subexpression is value-dependent
</li>
<li> an <a href="name.html" title="cpp/language/identifiers">id-expression</a> that
</li>
</ul>
<dl><dd>
<ul>
<li> is a name declared with a dependent type
</li>
<li> is a name of a non-type template parameter
</li>
<li> names a member of <i>unknown specialization</i>
</li>
</ul>
</dd></dl>
 <table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx14">
<td>
<dl><dd>
<ul>
<li> names a static data member that is a dependent member of the <i>current instantiation</i> and is not initialized.
</li>
<li> names a static member function that is a depndent member of the <i>current instantiation</i>
</li>
</ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</tbody></table>
<dl><dd>
<ul><li> is a constant with a literal type, initialized from a value-dependent expression
</li></ul>
</dd></dl>
<ul>
<li> <a href="sizeof.html" title="cpp/language/sizeof">sizeof</a>, <a href="alignof.html" title="cpp/language/alignof">alignof</a>, <a href="typeid.html" title="cpp/language/typeid">typeid</a>, <a href="noexcept.html" title="cpp/language/noexcept">noexcept</a>-expressions where the argument is a type-dependent expression or a dependent type-id
</li>
<li> any cast expression to a dependent type or from a value-dependent expression
</li>
</ul>
 <table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx14">
<td>
<ul><li> address-of expression where the argument is <a href="name.html" title="cpp/language/identifiers">qualified-id</a> that names a dependent member of the <i>current instantiation</i>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</tbody></table>
 <table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17">
<td>
<ul><li> <a href="fold.html" title="cpp/language/fold">fold-expression</a>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr>
</tbody></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Dependent names">edit</a>]</span> <span class="mw-headline" id="Dependent_names"> Dependent names </span>
</h3>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: the lede from [temp.dep], which is missing (id-expression followed by parenthesized list... </td>
</tr></tbody></table>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: reword to maybe make it more clear (or at least less intimidating), and while at ait, apply CWG issue 591 </td>
</tr></tbody></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Current instantiation">edit</a>]</span> <span class="mw-headline" id="Current_instantiation"> Current instantiation </span>
</h3>
<p>Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the <i>current instantiation</i>. This allows certain errors to be detected at the point of definition, rather than instantiation, and removes the requirement on the <code>typename</code> and <code>template</code> disambiguators for dependent names, see below. 
</p>
<p>Only the following names can refer to the current instantiation:
</p>
<ul><li> in a class template definition:
</li></ul>
<dl><dd>
<ul><li> a nested class, a member of class template, a member of a nested class, the injected-class-name of the template, the injected-class-name of a nested class
</li></ul>
</dd></dl>
<ul><li> in a primary class template definition or in the definition of its member: 
</li></ul>
<dl><dd>
<ul><li> name of the class template followed by template argument list (or an equivalent alias template specialization) for the primary template where each argument is equivalent to its corresponding parameter. Note that if an expression is used as a non-type template argument (e.g. N+0 where N is the parameter), it does not name the current instantiation even if its value matches.
</li></ul>
</dd></dl>
<ul><li> in the definition of a nested class or class template:
</li></ul>
<dl><dd>
<ul><li> name of the nested class used as a member of the current instantiation
</li></ul>
</dd></dl>
<ul><li> in the definition of a partial specialization or of a member of a partial specialization
</li></ul>
<dl><dd>
<ul><li> the name of the class template followed by template argument list for the partial specialization, where each argument is equivalent to its corresponding parameter
</li></ul>
</dd></dl>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">class</span> A <span class="br0">{</span>
    A<span class="sy2">*</span> p1<span class="sy4">;</span>    <span class="co1">// A is the current instantiation</span>
    A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy2">*</span> p2<span class="sy4">;</span> <span class="co1">// A&lt;T&gt; is the current instantiation</span>
    <span class="sy4">::</span><span class="me2">A</span><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy2">*</span> p4<span class="sy4">;</span> <span class="co1">//&nbsp;::A&lt;T&gt; is the current instantiation</span>
    A<span class="sy1">&lt;</span>T<span class="sy2">*</span><span class="sy1">&gt;</span> p3<span class="sy4">;</span> <span class="co1">// A&lt;T*&gt; is not the current instantiation</span>
    <span class="kw1">class</span> B <span class="br0">{</span>
        B<span class="sy2">*</span> p1<span class="sy4">;</span> <span class="co1">// B is the current instantiation</span>
        A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">B</span><span class="sy2">*</span> p2<span class="sy4">;</span> <span class="co1">// A&lt;T&gt;::B is the current instantiation</span>
        <span class="kw1">typename</span> A<span class="sy1">&lt;</span>T<span class="sy2">*</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">B</span><span class="sy2">*</span> p3<span class="sy4">;</span> <span class="co1">// A&lt;T*&gt;::B is not the current instantiation</span>
    <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">class</span> A<span class="sy1">&lt;</span>T<span class="sy2">*</span><span class="sy1">&gt;</span> <span class="br0">{</span>
    A<span class="sy1">&lt;</span>T<span class="sy2">*</span><span class="sy1">&gt;</span><span class="sy2">*</span> p1<span class="sy4">;</span>  <span class="co1">// A&lt;T*&gt; is the current instantiation</span>
    A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy2">*</span> p2<span class="sy4">;</span>   <span class="co1">// A&lt;T&gt; is not the current instantiation</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw1">struct</span> B <span class="br0">{</span>
    <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> my_I <span class="sy1">=</span> I<span class="sy4">;</span>
    <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> my_I2 <span class="sy1">=</span> I<span class="sy2">+</span><span class="nu0">0</span><span class="sy4">;</span>
    <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> my_I3 <span class="sy1">=</span> my_I<span class="sy4">;</span>
    B<span class="sy1">&lt;</span>my_I<span class="sy1">&gt;</span><span class="sy2">*</span> b3<span class="sy4">;</span>  <span class="co1">// Bm&lt;y_I&gt; is the current instantiation</span>
    B<span class="sy1">&lt;</span>my_I2<span class="sy1">&gt;</span><span class="sy2">*</span> b4<span class="sy4">;</span> <span class="co1">// B&lt;my_I2&gt; is not the current instantiation</span>
    B<span class="sy1">&lt;</span>my_I3<span class="sy1">&gt;</span><span class="sy2">*</span> b5<span class="sy4">;</span> <span class="co1">// B&lt;my_I3&gt; is the current instantiation</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>Note that a base class can be the current instantiation if a nested class derives from its enclosing class template. Base classes that are dependent types but aren&#39;t the current instantiation are <i>dependent base classes</i>
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> A <span class="br0">{</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> M<span class="sy4">;</span>
    <span class="kw1">struct</span> B <span class="br0">{</span>
        <span class="kw1">typedef</span> <span class="kw4">void</span> M<span class="sy4">;</span>
        <span class="kw1">struct</span> C<span class="sy4">;</span>
    <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">B</span><span class="sy4">::</span><span class="me2">C</span> <span class="sy4">:</span> A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="br0">{</span>
    M m<span class="sy4">;</span> <span class="co1">// OK, A&lt;T&gt;::M</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>A name is classified as a member of the current instantiation if it is
</p>
<ul>
<li> an unqualified name that is found by <a href="unqualified_lookup.html" title="cpp/language/unqualified lookup">unqualified lookup</a> in the current instantiation or in its non-dependenent base.
</li>
<li> <a href="qualified_lookup.html" title="cpp/language/qualified lookup">qualified name</a>, if the qualifier (the name to the left of <code><b>::</b></code>) names the current instantiation and lookup finds the name in the current instantiation or in its non-dependent base
</li>
<li> a name used in a class member access expression (<code>y</code> in <code>x.y</code> or <code>xp-&gt;y</code>), where the object expression (<code>x</code> or <code>*xp</code>) is the current instantiation and lookup finds the name in the current instantiation or in its non-dependent base
</li>
</ul>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">class</span> A <span class="br0">{</span>
   <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
   <span class="kw4">int</span> n1<span class="br0">[</span>i<span class="br0">]</span><span class="sy4">;</span>       <span class="co1">// i refers to a member of the current instantiation</span>
   <span class="kw4">int</span> n2<span class="br0">[</span>A<span class="sy4">::</span><span class="me2">i</span><span class="br0">]</span><span class="sy4">;</span>    <span class="co1">// A::i refers to a member of the current instantiation</span>
   <span class="kw4">int</span> n3<span class="br0">[</span>A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// A&lt;T&gt;::i refers to a member of the current instantiation</span>
   <span class="kw4">int</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">int</span> A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">f</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="kw1">return</span> i<span class="sy4">;</span> <span class="co1">// i refers to a member of the current instantiation</span>
<span class="br0">}</span></pre></div></div>
<p>Members of the current instantiation may be both dependent and non-dependent.
</p>
<p>If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation:
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span> <span class="kw4">int</span> m<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> B <span class="br0">{</span> <span class="kw4">int</span> m<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> C <span class="sy4">:</span> A, T <span class="br0">{</span>
  <span class="kw4">int</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> this<span class="sy2">-</span><span class="sy1">&gt;</span>m<span class="sy4">;</span> <span class="br0">}</span><span class="co1">// finds A::m in the template definition context</span>
  <span class="kw4">int</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> m<span class="sy4">;</span> <span class="br0">}</span>      <span class="co1">// finds A::m in the template definition context</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span> <span class="kw4">int</span> C<span class="sy1">&lt;</span>B<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: finds both A::m and B::m</span>
&nbsp;
<span class="kw1">template</span> <span class="kw4">int</span> C<span class="sy1">&lt;</span>B<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">g</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: transformation to class member access syntax</span>
                        <span class="co1">// does not occur in the template definition context</span></pre></div></div>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Unknown specializations">edit</a>]</span> <span class="mw-headline" id="Unknown_specializations"> Unknown specializations </span>
</h3>
<p>Within a template definition, certain names are deduced to belong to an <i>unknown specialization</i>, in particular,
</p>
<ul>
<li> a <a href="qualified_lookup.html" title="cpp/language/qualified lookup">qualified name</a>, if any name that appears to the left of <code><b>::</b></code> is a <i>dependent type</i> that is not a member of the <i>current instantiation</i>
</li>
<li> a <a href="qualified_lookup.html" title="cpp/language/qualified lookup">qualified name</a>, whose qualifier is the <i>current instantiation</i>, and the name is not found in the current instantiation or any of its non-dependent base classes, and there is a dependent base class
</li>
<li> a name of a member in a class member access expression (the <code>y</code> in <code>x.y</code> or <code>xp-&gt;y</code>), if the type of the object expression (<code>x</code> or <code>*xp</code>) is a <i>dependent type</i> and is not the <i>current instantiation</i>
</li>
<li> a name of a member in a class member access expression (the <code>y</code> in <code>x.y</code> or <code>xp-&gt;y</code>), if the type of the object expression  (<code>x</code> or <code>*xp</code>) is the <i>current instantiation</i>, and the name is not found in the current instantiation or any of its non-dependent base classes, and there is a dependent base class
</li>
</ul>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="co1">// Derived&lt;T&gt; refers to current instantiation</span>
        <span class="co1">// there is no &#39;unknown_type&#39; in the current instantiation</span>
        <span class="co1">// but there is a dependent base (Base&lt;T&gt;)</span>
        <span class="co1">// Therefore, unknown_type is a member of unknown specialization</span>
        <span class="kw1">typename</span> Derived<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">unknown_type</span> z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span> <span class="kw1">struct</span> Base<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">{</span> <span class="co1">// this specialization provides it</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> unknown_type<span class="sy4">;</span> 
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><br>
This classification allows the following errors to be detected at the point of template definition (rather than instantiation):
</p>
<ul><li> If any template definition has a <a href="qualified_lookup.html" title="cpp/language/qualified lookup">qualified name</a> in which the qualifier refers to the <i>current instantiation</i> and the name is neither a member of <i>current instantiation</i> nor a member of <i>unknown specialization</i>, the program is ill-formed (no diagnostic required) even if the template is never instantiated.
</li></ul>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">class</span> A <span class="br0">{</span>
  <span class="kw1">typedef</span> <span class="kw4">int</span> type<span class="sy4">;</span>
  <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> i<span class="sy4">;</span> <span class="co1">// OK: &#39;type&#39; is a member of the current instantiation</span>
    <span class="kw1">typename</span> A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">other</span> j<span class="sy4">;</span> <span class="co1">// Error:</span>
    <span class="co1">// &#39;other&#39; is not a member of the current instantiation</span>
    <span class="co1">// and it is not a member of an unknown specialization</span>
    <span class="co1">// because A&lt;T&gt; (which names the current instantiation),</span>
    <span class="co1">// has no dependent bases for &#39;other&#39; to hide in.</span>
<span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<ul><li> If any template definition has a member acess expression where the object expression is the <i>current instantiation</i>, but the name is neither a member of <i>current instantiation</i> nor a member of <i>unknown specialization</i>, the program is ill-formed even if the template is never instantiated.
</li></ul>
<p>Members of unknown specialization are always dependent, and are looked up and bound at the point of instantiation as all dependent names (see above)
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: The typename disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_typename_disambiguator_for_dependent_names">The <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> disambiguator for dependent names</span>
</h3>
<p>In a declaration or a definition of a template, including alias template, a name that is not a member of the <i>current instantiation</i> and is dependent on a template parameter is not considered to be a type unless the keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> is used or unless it was already established as a type name, e.g. with a typedef declaration or by being used to name a base class.
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<span class="kw4">int</span> p <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> foo<span class="br0">(</span><span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;</span>v<span class="br0">)</span>
<span class="br0">{</span>
&nbsp;
    <span class="co1">// std::vector&lt;T&gt;::const_iterator is a dependent name,</span>
    <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> it <span class="sy1">=</span> v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    <span class="co1">// without &#39;typename&#39;, the following is parsed as multiplication </span>
    <span class="co1">// of the type-dependent member variable &#39;const_iterator&#39; </span>
    <span class="co1">// and some variable &#39;p&#39;. Since there is a global &#39;p&#39; visible</span>
    <span class="co1">// at this point, this template definition compiles.</span>
    <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy2">*</span> p<span class="sy4">;</span> 
&nbsp;
    <span class="kw1">typedef</span> <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> iter_t<span class="sy4">;</span>
    iter_t <span class="sy2">*</span> p2<span class="sy4">;</span> <span class="co1">// iter_t is a dependent name, but it&#39;s known to be a type name</span>
<span class="br0">}</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> value_t<span class="sy4">;</span> <span class="co1">// member of current instantiation</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_t</span> n<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// S&lt;T&gt; is dependenent, but &#39;typename&#39; not needed</span>
        <a href="../io/cout.html"><span class="kw1552">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">&#39;<span class="es1">\n</span>&#39;</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    foo<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// template instantiation fails: there is no member variable</span>
            <span class="co1">// called &#39;const_iterator&#39; in the type std::vector&lt;int&gt;</span>
    S<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> may only be used in this way before qualified names (e.g. <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy4">::</span><span class="me2">x</span></span></span>), but the names need not be dependent.
</p>
<p>Usual <a href="qualified_lookup.html" title="cpp/language/qualified lookup">qualified name lookup</a> is used for the identifier prefixed by <code>typename</code>. Unlike the case with <a href="elaborated_type_specifier.html" title="cpp/language/elaborated type specifier">elaborated type specifier</a>, the lookup rules do not change despite the qualifier:
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span> <span class="co1">// A has a nested variable X and a nested type struct X</span>
   <span class="kw1">struct</span> X <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
   <span class="kw4">int</span> X<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> B <span class="br0">{</span>
    <span class="kw1">struct</span> X <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// B has a nested type struct X</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">typename</span> T<span class="sy4">::</span><span class="me2">X</span> x<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">void</span> foo<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    A a<span class="sy4">;</span>
    B b<span class="sy4">;</span>
    f<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: instantiates f&lt;B&gt;, T::X refers to B::X</span>
    f<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: cannot instantiate f&lt;A&gt;:</span>
          <span class="co1">// because qualified name lookup for A::X finds the data member</span>
<span class="br0">}</span></pre></div></div>
 <table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx11">
<td>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> must only be used in template declarations and definitions and only in contexts in which dependent names can be used. This excludes explicit specialization declarations and explicit instantiation declarations. 
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr>
<tr class="t-rev t-since-cxx11">
<td>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> can be used even outside of templates.
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">typedef</span> <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> iter_t<span class="sy4">;</span> <span class="co1">// OK in C++11</span>
    <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1159">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span> <span class="co1">// also OK in C++11</span>
&nbsp;
<span class="br0">}</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr>
</tbody></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: The template disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_template_disambiguator_for_dependent_names">The <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> disambiguator for dependent names</span>
</h3>
<p>Similarly, in a template definition, a dependent name that is not a member of the <i>current instantiation</i> is not considered to be a template name unless the disambiguation keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> is used or unless it was already established as a template name:
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> U<span class="sy1">&gt;</span> <span class="kw4">void</span> foo<span class="br0">(</span><span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> bar<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">foo</span><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: &lt; parsed as less than operator</span>
    s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> may only be used in this way after operators <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy4">::</span></span></span> (scope resolution), <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">-</span><span class="sy1">&gt;</span></span></span> (member access through pointer), and <span class="t-c"><span class="mw-geshi cpp source-cpp">.</span></span> (member access), the following are all valid examples:
</p>
<ul>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy4">::</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">this<span class="sy2">-</span><span class="sy1">&gt;</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span> T<span class="sy4">::</span><span class="kw1">template</span> iterator<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_type</span> v<span class="sy4">;</span></span></span>
</li>
</ul>
<p>As is the case with <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span>, the <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> prefix is allowed even if the name is not dependent<span class="t-rev-inl t-since-cxx11"><span> or the use does not appear in the scope of a template</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.
</p>
 <table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17">
<td>
<p>Even if the name to the left of <code><b>::</b></code> refers to a namespace, the template disambiguator is allowed:
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span><span class="sy1">&gt;</span> <span class="kw1">struct</span> s <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="sy4">::</span><span class="kw1">template</span> s<span class="sy1">&lt;</span><span class="kw4">void</span><span class="sy1">&gt;</span> q<span class="sy4">;</span> <span class="co1">// allowed, but unnecessary</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr>
</tbody></table>
<p>Due to the special rules for <a href="unqualified_lookup.html" title="cpp/language/unqualified lookup">unqualified name lookup</a> for template names in member access expressions, when a non-dependent template name appears in a member access expression (after <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">-</span><span class="sy1">&gt;</span></span></span> or after <span class="t-c"><span class="mw-geshi cpp source-cpp">.</span></span>), the disambiguator is unnecessary if there is a <span class="t-rev-inl t-since-cxx11"><span>class</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> template with the same name found by ordinary lookup in the context of the expression. <span class="t-rev-inl t-until-cxx11"><span>However, if the template found by lookup in the context of the expression differs from the one found in the context of the class, the program is ill-formed</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>
</p>
<!-- 
NewPP limit report
Preprocessor visited node count: 2999/1000000
Preprocessor generated node count: 8908/1000000
Post‐expand include size: 44764/2097152 bytes
Template argument size: 20512/2097152 bytes
Highest expansion depth: 17/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9611-0!*!0!!en!*!* and timestamp 20160323160043 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from &quot;<a href="http://en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&amp;oldid=81903</a>&quot;                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div class="catlinks" id="catlinks"><div class="mw-normal-catlinks" id="mw-normal-catlinks">
<a href="http://en.cppreference.com/w/Special%3ACategories" title="Special:Categories">Category</a>: <ul><li><a href="http://en.cppreference.com/w/Category%3ATodo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul>
</div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 5.712 secs. -->
	</body>



<!-- Cached 20160323160043 -->

</html>