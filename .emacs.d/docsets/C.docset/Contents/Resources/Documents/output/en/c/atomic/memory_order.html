<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html class="client-nojs" dir="ltr" lang="en"><head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<title>memory_order</title>
<meta charset="UTF-8">
<meta content="MediaWiki 1.21.2" name="generator">


<link href="../../../favicon.ico" rel="shortcut icon">



<link href="../../../common/ext.css" rel="stylesheet">
<meta content="" name="ResourceLoaderDynamicStyles">
<link href="../../../common/site_modules.css" rel="stylesheet">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"c/atomic/memory_order","wgTitle":"c/atomic/memory order","wgCurRevisionId":77531,"wgArticleId":9269,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Todo with reason","Todo no example"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"c/atomic/memory_order","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:ca03345b1e2c4d90a25d968753a73b92 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #0000dd;}
.c.source-c .kw2 {color: #0000ff;}
.c.source-c .kw3 {color: #0000dd;}
.c.source-c .kw4 {color: #0000ff;}
.c.source-c .co1 {color: #909090;}
.c.source-c .co2 {color: #339900;}
.c.source-c .coMULTI {color: #ff0000; font-style: italic;}
.c.source-c .es0 {color: #008000; font-weight: bold;}
.c.source-c .es1 {color: #008000; font-weight: bold;}
.c.source-c .es2 {color: #008000; font-weight: bold;}
.c.source-c .es3 {color: #008000; font-weight: bold;}
.c.source-c .es4 {color: #008000; font-weight: bold;}
.c.source-c .es5 {color: #008000; font-weight: bold;}
.c.source-c .br0 {color: #008000;}
.c.source-c .sy0 {color: #008000;}
.c.source-c .sy1 {color: #000080;}
.c.source-c .sy2 {color: #000040;}
.c.source-c .sy3 {color: #000040;}
.c.source-c .sy4 {color: #008080;}
.c.source-c .st0 {color: #008000;}
.c.source-c .nu0 {color: #000080;}
.c.source-c .nu6 {color:#000080;}
.c.source-c .nu8 {color:#000080;}
.c.source-c .nu12 {color:#000080;}
.c.source-c .nu16 {color:#000080;}
.c.source-c .nu17 {color:#000080;}
.c.source-c .nu18 {color:#000080;}
.c.source-c .nu19 {color:#000080;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
</head><body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-c_atomic_memory_order skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 class="firstHeading" id="firstHeading">memory_order</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../c.html" title="c">c</a>&lrm; | <a href="../atomic.html" title="c/atomic">atomic</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en">
<div class="t-navbar" style="">
<div class="t-navbar-sep">&nbsp;</div>
<div class="t-navbar-head">
<a href="../../c.html" title="c"> C</a><div class="t-navbar-menu"><div>
<div><table cellpadding="0" class="t-nv-begin" style="line-height:1.1em;">
<tbody><tr class="t-nv"><td colspan="5"> <a href="../language.1.html" title="c/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="c/header"> headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../types.html" title="c/types"> Type support</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../memory.html" title="c/memory"> Dynamic memory management</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="c/error"> Error handling</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../program.html" title="c/program"> Program utilities</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../variadic.html" title="c/variadic"> Variadic function support</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../chrono.html" title="c/chrono"> Date and time utilities</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="c/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="c/algorithm"> Algorithms</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="c/numeric"> Numerics</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="c/io"> Input/output support</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="c/locale"> Localization support</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="c/thread"> Thread support</a> <span class="t-mark-rev t-since-c11">(C11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="c/atomic"> Atomic operations</a> <span class="t-mark-rev t-since-c11">(C11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="../experimental.html" title="c/experimental"><span class="t-lines"><span>Technical Specifications</span></span></a></div></div></td></tr>
</tbody></table></div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep">&nbsp;</div>
<div class="t-navbar-head">
<a href="../atomic.html" title="c/atomic"> Atomic operations library</a><div class="t-navbar-menu"><div>
<div><table cellpadding="0" class="t-nv-begin" style="">
<tbody><tr class="t-nv-h2"><td colspan="5"> Types </td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><strong class="selflink"><span class="t-lines"><span>memory_order</span></span></strong></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_flag.html" title="c/atomic/atomic flag"><span class="t-lines"><span>atomic_flag</span></span></a></div></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> Macros </td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="ATOMIC_LOCK_FREE_consts.html" title="c/atomic/ATOMIC LOCK FREE consts"><span class="t-lines"><span>ATOMIC_***_LOCK_FREE</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="ATOMIC_FLAG_INIT.html" title="c/atomic/ATOMIC FLAG INIT"><span class="t-lines"><span>ATOMIC_FLAG_INIT</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="ATOMIC_VAR_INIT.html" title="c/atomic/ATOMIC VAR INIT"><span class="t-lines"><span>ATOMIC_VAR_INIT</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="kill_dependency.html" title="c/atomic/kill dependency"><span class="t-lines"><span>kill_dependency</span></span></a></div></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> Functions </td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_flag_test_and_set.html" title="c/atomic/atomic flag test and set"><span class="t-lines"><span>atomic_flag_test_and_set</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_flag_clear.html" title="c/atomic/atomic flag clear"><span class="t-lines"><span>atomic_flag_clear</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_init.html" title="c/atomic/atomic init"><span class="t-lines"><span>atomic_init</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_is_lock_free.html" title="c/atomic/atomic is lock free"><span class="t-lines"><span>atomic_is_lock_free</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_store.html" title="c/atomic/atomic store"><span class="t-lines"><span>atomic_store</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_load.html" title="c/atomic/atomic load"><span class="t-lines"><span>atomic_load</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_exchange.html" title="c/atomic/atomic exchange"><span class="t-lines"><span>atomic_exchange</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_compare_exchange.html" title="c/atomic/atomic compare exchange"><span class="t-lines"><span>atomic_compare_exchange</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_fetch_add.html" title="c/atomic/atomic fetch add"><span class="t-lines"><span>atomic_fetch_add</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_fetch_sub.html" title="c/atomic/atomic fetch sub"><span class="t-lines"><span>atomic_fetch_sub</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_fetch_or.html" title="c/atomic/atomic fetch or"><span class="t-lines"><span>atomic_fetch_or</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_fetch_xor.html" title="c/atomic/atomic fetch xor"><span class="t-lines"><span>atomic_fetch_xor</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_fetch_and.html" title="c/atomic/atomic fetch and"><span class="t-lines"><span>atomic_fetch_and</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_thread_fence.html" title="c/atomic/atomic thread fence"><span class="t-lines"><span>atomic_thread_fence</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="atomic_signal_fence.html" title="c/atomic/atomic signal fence"><span class="t-lines"><span>atomic_signal_fence</span></span></a></div></div></td></tr>
</tbody></table></div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep">&nbsp;</div>
</div>
<table class="t-dcl-begin"><tbody>
<tr class="t-dsc-header">
<td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code>
 </div>
</td>
<td></td>
<td></td>
</tr>
<tr class="t-dcl t-since-c11">
<td> <div><span class="mw-geshi c source-c"><span class="kw2">enum</span> memory_order <span class="br0">{</span><br>
<p>&nbsp; &nbsp; memory_order_relaxed,<br>
&nbsp; &nbsp; memory_order_consume,<br>
&nbsp; &nbsp; memory_order_acquire,<br>
&nbsp; &nbsp; memory_order_release,<br>
&nbsp; &nbsp; memory_order_acq_rel,<br>
&nbsp; &nbsp; memory_order_seq_cst<br>
</p>
<span class="br0">}</span><span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-c11">(since C11)</span> </td>
</tr>
<tr class="t-dcl-sep">
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>memory_order</code> specifies how regular, non-atomic memory accesses are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.
</p>
<p>The default behavior of all atomic operations in the <a href="../language/atomic.html" title="c/language/atomic">language</a> and the library provides for <i>sequentially consistent ordering</i> (see discussion below). That default can hurt performance, but the library&#39;s atomic operations can be given an additional <code>memory_order</code> argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.
</p>
<table class="toc" id="toc"><tbody><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="memory_order.html#Constants"><span class="tocnumber">1</span> <span class="toctext">Constants</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="memory_order.html#Relaxed_ordering"><span class="tocnumber">1.1</span> <span class="toctext">Relaxed ordering</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="memory_order.html#Release-Consume_ordering"><span class="tocnumber">1.2</span> <span class="toctext">Release-Consume ordering</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="memory_order.html#Release_sequence"><span class="tocnumber">1.3</span> <span class="toctext">Release sequence</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="memory_order.html#Release-Acquire_ordering"><span class="tocnumber">1.4</span> <span class="toctext">Release-Acquire ordering</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="memory_order.html#Sequentially-consistent_ordering"><span class="tocnumber">1.5</span> <span class="toctext">Sequentially-consistent ordering</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="memory_order.html#Relationship_with_volatile"><span class="tocnumber">2</span> <span class="toctext">Relationship with volatile</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="memory_order.html#Examples"><span class="tocnumber">3</span> <span class="toctext">Examples</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="memory_order.html#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="memory_order.html#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="memory_order.html#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
</td></tr></tbody></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Constants">edit</a>]</span> <span class="mw-headline" id="Constants">Constants</span>
</h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc-header">
<td colspan="2"> <div>Defined in header <code>&lt;atomic&gt;</code> </div>
</td>
</tr>

<tr class="t-dsc-hitem">
<td>  Value
</td>
<td>  Explanation
</td>
</tr>


<tr class="t-dsc">
<td>  <code>memory_order_relaxed</code>
</td>
<td>  Relaxed operation: there are no synchronization or ordering constraints, only atomicity is required of this operation.
</td>
</tr>


<tr class="t-dsc">
<td>  <code>memory_order_consume</code>
</td>
<td>  A load operation with this memory order performs a <i>consume operation</i> on the affected memory location: no reads in the current thread dependent on the value currently loaded can be reordered before this load. This ensures that writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only.
</td>
</tr>


<tr class="t-dsc">
<td>  <code>memory_order_acquire</code>
</td>
<td>  A load operation with this memory order performs the <i>acquire operation</i> on the affected memory location: no memory accesses in the current thread can be reordered before this load. This ensures that all writes in other threads that release the same atomic variable are visible in the current thread.
</td>
</tr>


<tr class="t-dsc">
<td>  <code>memory_order_release</code>
</td>
<td>  A store operation with this memory order performs the <i>release operation</i>: no memory accesses in the current thread can be reordered after this store. This ensures that all writes in the current thread are visible in other threads that acquire the same atomic variable and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic.
</td>
</tr>


<tr class="t-dsc">
<td>  <code>memory_order_acq_rel</code>
</td>
<td>  A read-modify-write operation with this memory order is both an <i>acquire operation</i> and a <i>release operation</i>. No memory accesses in the current thread can be reordered before this load, and no memory accesses in the current thread can be reordered after this store. It is ensured that all writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.
</td>
</tr>


<tr class="t-dsc">
<td>  <code>memory_order_seq_cst</code>
</td>
<td>  Any operation with this memory order is both an <i>acquire operation</i> and a <i>release operation</i>, plus a single total order exists in which all threads observe all modifications (see below) in the same order.
</td>
</tr>

</tbody></table>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: happens-before and other concepts, as in C++, but keep modification orders and the four consistencies in <a href="../language/atomic.html" title="c/language/atomic">c/language/atomic</a> </td>
</tr></tbody></table>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Relaxed ordering">edit</a>]</span> <span class="mw-headline" id="Relaxed_ordering">Relaxed ordering</span>
</h4>
<p>Atomic operations tagged <span class="t-c"><span class="mw-geshi c source-c">memory_order_relaxed</span></span> are not synchronization operations, they do not order memory. They only guarantee atomicity and  modification order consistency.
</p>
<p>For example, with <code>x</code> and <code>y</code> initially zero,
</p>
<p><span class="t-c"><span class="mw-geshi c source-c"><span class="co1">// Thread 1:</span><br>
r1 <span class="sy1">=</span> <a href="atomic_load.html"><span class="kw933">atomic_load_explicit</span></a><span class="br0">(</span>y, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// A</span><br>
<a href="atomic_store.html"><span class="kw931">atomic_store_explicit</span></a><span class="br0">(</span>x, r1, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// B</span><br>
<span class="co1">// Thread 2:</span><br>
r2 <span class="sy1">=</span> <a href="atomic_load.html"><span class="kw933">atomic_load_explicit</span></a><span class="br0">(</span>x, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// C</span><br>
<a href="atomic_store.html"><span class="kw931">atomic_store_explicit</span></a><span class="br0">(</span>y, <span class="nu0">42</span>, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// D</span></span></span>
</p>
<p>is allowed to produce <code>r1 == r2 == 42</code> because, although A is <i>sequenced-before</i> B within thread 1 and C is <i>sequenced before</i> D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in Thread 1  while the side effect of B on x could be visible to the load C in Thread 2.
</p>
<p><br>
</p>
<p>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor)
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release-Consume ordering">edit</a>]</span> <span class="mw-headline" id="Release-Consume_ordering">Release-Consume ordering</span>
</h4>
<p>If an atomic store in thread A is tagged <span class="t-c"><span class="mw-geshi c source-c">memory_order_release</span></span> and an atomic load in thread B from the same variable is tagged <span class="t-c"><span class="mw-geshi c source-c">memory_order_consume</span></span>, all memory writes (non-atomic and relaxed atomic) that are <i>dependency-ordered-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> within those operations in thread B into which the load operation <i>carries dependency</i>, that is, once the atomic load is completed, those operators and functions in thread B that use the value obtained from the load are guaranteed to see what thread A wrote to memory.
</p>
<p>The synchronization is established only between the threads <i>releasing</i> and <i>consuming</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</p>
<p>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain). 
</p>
<p>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is <a class="extiw" href="http://en.wikipedia.com/wiki/Read-copy-update" title="enwiki:Read-copy-update">rcu_dereference</a>.
</p>
<p><br>
</p>
<p>Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release sequence">edit</a>]</span> <span class="mw-headline" id="Release_sequence">Release sequence</span>
</h4>
<p>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a &quot;release sequence&quot; is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no <code>memory_order_release</code> semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release-Acquire ordering">edit</a>]</span> <span class="mw-headline" id="Release-Acquire_ordering">Release-Acquire ordering</span>
</h4>
<p>If an atomic store in thread A is tagged <span class="t-c"><span class="mw-geshi c source-c">memory_order_release</span></span> and an atomic load in thread B from the same variable is tagged <span class="t-c"><span class="mw-geshi c source-c">memory_order_acquire</span></span>, all memory writes (non-atomic and relaxed atomic) that <i>happened-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to memory.
</p>
<p>The synchronization is established only between the threads <i>releasing</i> and <i>acquiring</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</p>
<p>On strongly-ordered systems (x86, SPARC TSO, IBM mainframe), release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from moving non-atomic stores past the atomic store-release or perform non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions have to be used.
</p>
<p>Mutual exclusion locks (such as <a href="../thread.html#Mutual_exclusion" title="c/thread">mutexes</a> or <a href="atomic_flag_test_and_set.html" title="c/atomic/atomic flag test and set">atomic spinlock</a>) are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Sequentially-consistent ordering">edit</a>]</span> <span class="mw-headline" id="Sequentially-consistent_ordering">Sequentially-consistent ordering</span>
</h4>
<p>Atomic operations tagged <span class="t-c"><span class="mw-geshi c source-c">memory_order_seq_cst</span></span> not only order memory the same way as release/acquire ordering (everything that <i>happened-before</i> a store in one thread becomes a <i>visible side effect</i> in the thread that did a load), but also establish a <i>single total modification order</i> of all atomic operations that are so tagged.
</p>
<p>Formally,
</p>
<p>Each <code>memory_order_seq_cst</code> operation B that loads from atomic variable M, observes one of the following:
</p>
<ul>
<li> the result of the last operation A that modified M, which appears before B in the single total order
</li>
<li> OR, if there was such an A, B may observe the result of some modification on M that is not <code>memory_order_seq_cst</code> and does not <i>happen-before</i> A
</li>
<li> OR, if there wasn&#39;t such an A, B may observe the result of some unrelated modification of M that is not <code>memory_order_seq_cst</code>
</li>
</ul>
<p>If there was a <code>memory_order_seq_cst</code> <span class="t-lc">std::atomic_thread_fence</span> operation X <i>sequenced-before</i> B, then B observes one of the following:
</p>
<ul>
<li> the last <code>memory_order_seq_cst</code> modification of M that appears before X in the single total order
</li>
<li> some unrelated modification of M that appears later in M&#39;s modification order
</li>
</ul>
<p>For a pair of atomic operations on M called A and B, where A writes and B reads M&#39;s value, if there are two <code>memory_order_seq_cst</code> <span class="t-lc">std::atomic_thread_fence</span>s X and Y, and if A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order, then B observes either:
</p>
<ul>
<li> the effect of A
</li>
<li> some unrelated modification of M that appears after A in M&#39;s modification order
</li>
</ul>
<p>For a pair of atomic modifications of M called A and B, B occurs after A in M&#39;s modification order if 
</p>
<ul>
<li> there is a <code>memory_order_seq_cst</code> <span class="t-lc">std::atomic_thread_fence</span> X such that A is <i>sequenced-before</i> X and X appears before B in the Single Total Order
</li>
<li> or, there is a <code>memory_order_seq_cst</code> <span class="t-lc">std::atomic_thread_fence</span> Y such that Y is <i>sequenced-before</i> B and A appears before Y in the Single Total Order
</li>
<li> or, there are <code>memory_order_seq_cst</code> <span class="t-lc">std::atomic_thread_fence</span>s X and Y such that A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order.
</li>
</ul>
<p>Note that the means that:
</p>
<div class="t-li1">
<span class="t-li">1)</span> as soon as atomic operations that are not tagged <code>memory_order_seq_cst</code> enter the picture, the sequential consistency is lost</div>
<div class="t-li1">
<span class="t-li">2)</span> the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (<i>sequenced-before</i> is not a cross-thread relationship, unlike <i>happens-before</i>)</div>
<p>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.
</p>
<p>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Relationship with volatile">edit</a>]</span> <span class="mw-headline" id="Relationship_with_volatile">Relationship with volatile</span>
</h3>
<p>Within a thread of execution, accesses (reads and writes) to all <a href="../language/volatile.html" title="c/language/volatile">volatile objects</a> are guaranteed to not be reordered relative to each other, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.
</p>
<p>In addition, volatile accesses are not atomic (concurrent read and write is a <a href="../language/memory_model.html" title="c/language/memory model">data race</a>) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).
</p>
<p>One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (<a class="external text" href="http://msdn.microsoft.com/en-us/library/12a04hfd%28v%3Dvs.100%29.aspx" rel="nofollow">MSDN</a>), and thus volatiles may be used for inter-thread synchronization. Standard <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">volatile</span></span></span> semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a <span class="t-lc"><a href="../program/signal.html" title="c/program/signal">signal</a></span> handler.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Examples">edit</a>]</span> <span class="mw-headline" id="Examples">Examples</span>
</h3>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: no example </td>
</tr></tbody></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: References">edit</a>]</span> <span class="mw-headline" id="References">References</span>
</h3>
<div class="t-ref-std-11">
<ul><li> C11 standard (ISO/IEC 9899:2011): 
</li></ul>
<dl><dd>
<ul><li> 7.17.1/4 memory_order (p: 273)
</li></ul>
</dd></dl>
<dl><dd>
<ul><li> 7.17.3 Order and consistency (p: 275-277)
</li></ul>
</dd></dl>
</div>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span>
</h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see">
<span><a href="../../cpp/atomic/memory_order.html" title="cpp/atomic/memory order">C++ documentation</a></span> for <span class="t-dsc-see-tt"><span>memory order</span></span>
</div>
</td>
</tr>

</tbody></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: External links">edit</a>]</span> <span class="mw-headline" id="External_links">External links</span>
</h3>
<ul><li> <a class="extiw" href="http://en.wikipedia.com/wiki/MOESI_protocol" title="enwiki:MOESI protocol">MOESI protocol</a>
</li></ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: let&#39;s find good refs on QPI, MOESI, and maybe Dragon </td>
</tr></tbody></table>
<ul>
<li> <a class="external text" href="http://www.cl.cam.ac.uk/%7Epes20/weakmemory/cacm.pdf" rel="nofollow">x86-TSO: A Rigorous and Usable Programmer&rsquo;s Model for x86 Multiprocessors</a> P. Sewell et. al., 2010
</li>
<li> <a class="external text" href="http://www.cl.cam.ac.uk/%7Epes20/ppc-supplemental/test7.pdf" rel="nofollow">A Tutorial Introduction to the ARM and POWER Relaxed Memory Models</a> P. Sewell et al, 2012
</li>
<li> <a class="external text" href="https%3A//researchspace.auckland.ac.nz/bitstream/handle/2292/11594/MESIF-2009.pdf%3Fsequence%3D6" rel="nofollow">MESIF: A Two-Hop Cache Coherency Protocol for Point-to-Point Interconnects</a>  J.R. Goodman, H.H.J. Hum, 2009
</li>
</ul>

<!-- 
NewPP limit report
Preprocessor visited node count: 3082/1000000
Preprocessor generated node count: 9313/1000000
Post‐expand include size: 70651/2097152 bytes
Template argument size: 13503/2097152 bytes
Highest expansion depth: 19/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9269-0!*!0!!en!*!* and timestamp 20160106161613 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from &quot;<a href="http://en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=c/atomic/memory_order&amp;oldid=77531</a>&quot;                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div class="catlinks" id="catlinks"><div class="mw-normal-catlinks" id="mw-normal-catlinks">
<a href="http://en.cppreference.com/w/Special%3ACategories" title="Special:Categories">Categories</a>: <ul>
<li><a href="http://en.cppreference.com/w/Category%3ATodo_with_reason" title="Category:Todo with reason">Todo with reason</a></li>
<li><a href="http://en.cppreference.com/w/Category%3ATodo_no_example" title="Category:Todo no example">Todo no example</a></li>
</ul>
</div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 1.017 secs. -->
	</body>



<!-- Cached 20160106161613 -->

</html>