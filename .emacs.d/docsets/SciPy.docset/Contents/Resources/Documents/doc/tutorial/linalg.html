<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Linear Algebra (scipy.linalg)</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.16.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="top" title="SciPy v0.16.0 Reference Guide" href="../index.html" >
    <link rel="up" title="SciPy Tutorial" href="index.html" >
    <link rel="next" title="Sparse Eigenvalue Problems with ARPACK" href="arpack.html" >
    <link rel="prev" title="Signal Processing (scipy.signal)" href="signal.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">SciPy v0.16.0 Reference Guide</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">SciPy Tutorial</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="../scipy-optimize-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="arpack.html" title="Sparse Eigenvalue Problems with ARPACK"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="signal.html" title="Signal Processing (scipy.signal)"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/scipyshiny_small.png" alt="Logo">
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Linear Algebra (<tt class="docutils literal"><span class="pre">scipy.linalg</span></tt>)</a><ul>
<li><a class="reference internal" href="#scipy-linalg-vs-numpy-linalg">scipy.linalg vs numpy.linalg</a></li>
<li><a class="reference internal" href="#numpy-matrix-vs-2d-numpy-ndarray">numpy.matrix vs 2D numpy.ndarray</a></li>
<li><a class="reference internal" href="#basic-routines">Basic routines</a><ul>
<li><a class="reference internal" href="#finding-inverse">Finding Inverse</a></li>
<li><a class="reference internal" href="#solving-linear-system">Solving linear system</a></li>
<li><a class="reference internal" href="#finding-determinant">Finding Determinant</a></li>
<li><a class="reference internal" href="#computing-norms">Computing norms</a></li>
<li><a class="reference internal" href="#solving-linear-least-squares-problems-and-pseudo-inverses">Solving linear least-squares problems and pseudo-inverses</a></li>
<li><a class="reference internal" href="#generalized-inverse">Generalized inverse</a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompositions">Decompositions</a><ul>
<li><a class="reference internal" href="#eigenvalues-and-eigenvectors">Eigenvalues and eigenvectors</a></li>
<li><a class="reference internal" href="#singular-value-decomposition">Singular value decomposition</a></li>
<li><a class="reference internal" href="#lu-decomposition">LU decomposition</a></li>
<li><a class="reference internal" href="#cholesky-decomposition">Cholesky decomposition</a></li>
<li><a class="reference internal" href="#qr-decomposition">QR decomposition</a></li>
<li><a class="reference internal" href="#schur-decomposition">Schur decomposition</a></li>
<li><a class="reference internal" href="#interpolative-decomposition">Interpolative Decomposition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-functions">Matrix Functions</a><ul>
<li><a class="reference internal" href="#exponential-and-logarithm-functions">Exponential and logarithm functions</a></li>
<li><a class="reference internal" href="#trigonometric-functions">Trigonometric functions</a></li>
<li><a class="reference internal" href="#hyperbolic-trigonometric-functions">Hyperbolic trigonometric functions</a></li>
<li><a class="reference internal" href="#arbitrary-function">Arbitrary function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-matrices">Special matrices</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="signal.html"
                        title="previous chapter">Signal Processing (<tt class="docutils literal"><span class="pre">scipy.signal</span></tt>)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="arpack.html"
                        title="next chapter">Sparse Eigenvalue Problems with ARPACK</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="linear-algebra-scipy-linalg">
<h1>Linear Algebra (<a class="reference internal" href="../linalg.html#module-scipy.linalg" title="scipy.linalg"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg</span></tt></a>)<a class="headerlink" href="#linear-algebra-scipy-linalg" title="Permalink to this headline">¶</a></h1>
<p>When SciPy is built using the optimized ATLAS LAPACK and BLAS
libraries, it has very fast linear algebra capabilities. If you dig
deep enough, all of the raw lapack and blas libraries are available
for your use for even more speed. In this section, some easier-to-use
interfaces to these routines are described.</p>
<p>All of these linear algebra routines expect an object that can be
converted into a 2-dimensional array. The output of these routines is
also a two-dimensional array.</p>
<div class="section" id="scipy-linalg-vs-numpy-linalg">
<h2>scipy.linalg vs numpy.linalg<a class="headerlink" href="#scipy-linalg-vs-numpy-linalg" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">scipy.linalg</span></tt> contains all the functions in <tt class="docutils literal"><span class="pre">numpy.linalg</span></tt>.
plus some other more advanced ones not contained in <tt class="docutils literal"><span class="pre">numpy.linalg</span></tt></p>
<p>Another advantage of using <tt class="docutils literal"><span class="pre">scipy.linalg</span></tt> over <tt class="docutils literal"><span class="pre">numpy.linalg</span></tt> is that
it is always compiled with BLAS/LAPACK support, while for numpy this is
optional. Therefore, the scipy version might be faster depending on how
numpy was installed.</p>
<p>Therefore, unless you don&#8217;t want to add <tt class="docutils literal"><span class="pre">scipy</span></tt> as a dependency to
your <tt class="docutils literal"><span class="pre">numpy</span></tt> program, use <tt class="docutils literal"><span class="pre">scipy.linalg</span></tt> instead of <tt class="docutils literal"><span class="pre">numpy.linalg</span></tt></p>
</div>
<div class="section" id="numpy-matrix-vs-2d-numpy-ndarray">
<h2>numpy.matrix vs 2D numpy.ndarray<a class="headerlink" href="#numpy-matrix-vs-2d-numpy-ndarray" title="Permalink to this headline">¶</a></h2>
<p>The classes that represent matrices, and basic operations such as
matrix multiplications and transpose are a part of <tt class="docutils literal"><span class="pre">numpy</span></tt>.
For convenience, we summarize the differences between <tt class="docutils literal"><span class="pre">numpy.matrix</span></tt>
and <tt class="docutils literal"><span class="pre">numpy.ndarray</span></tt> here.</p>
<p><tt class="docutils literal"><span class="pre">numpy.matrix</span></tt> is matrix class that has a more convenient interface
than <tt class="docutils literal"><span class="pre">numpy.ndarray</span></tt> for matrix operations. This class supports for
example MATLAB-like creation syntax via the, has matrix multiplication
as default for the <tt class="docutils literal"><span class="pre">*</span></tt> operator, and contains <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt> members
that serve as shortcuts for inverse and transpose:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s">&#39;[1 2;3 4]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">I</span>
<span class="go">matrix([[-2. ,  1. ],</span>
<span class="go">        [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s">&#39;[5 6]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">matrix([[5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="go">matrix([[5],</span>
<span class="go">        [6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">*</span><span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="go">matrix([[17],</span>
<span class="go">        [39]])</span>
</pre></div>
</div>
<p>Despite its convenience, the use of the <tt class="docutils literal"><span class="pre">numpy.matrix</span></tt> class is
discouraged, since it adds nothing that cannot be accomplished
with 2D <tt class="docutils literal"><span class="pre">numpy.ndarray</span></tt> objects, and may lead to a confusion of which class
is being used. For example, the above code can be rewritten as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[-2. ,  1. ],</span>
<span class="go">      [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span> <span class="c">#2D array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[5],</span>
<span class="go">      [6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">*</span><span class="n">b</span> <span class="c">#not matrix multiplication!</span>
<span class="go">array([[ 5, 12],</span>
<span class="go">      [15, 24]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c">#matrix multiplication</span>
<span class="go">array([[17],</span>
<span class="go">      [39]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span> <span class="c">#1D array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">T</span>  <span class="c">#not matrix transpose!</span>
<span class="go">array([5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c">#does not matter for multiplication</span>
<span class="go">array([17, 39])</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">scipy.linalg</span></tt> operations can be applied equally to
<tt class="docutils literal"><span class="pre">numpy.matrix</span></tt> or to 2D <tt class="docutils literal"><span class="pre">numpy.ndarray</span></tt> objects.</p>
</div>
<div class="section" id="basic-routines">
<h2>Basic routines<a class="headerlink" href="#basic-routines" title="Permalink to this headline">¶</a></h2>
<div class="section" id="finding-inverse">
<h3>Finding Inverse<a class="headerlink" href="#finding-inverse" title="Permalink to this headline">¶</a></h3>
<p>The inverse of a matrix <span class="math">\(\mathbf{A}\)</span> is the matrix
<span class="math">\(\mathbf{B}\)</span> such that <span class="math">\(\mathbf{AB}=\mathbf{I}\)</span> where
<span class="math">\(\mathbf{I}\)</span> is the identity matrix consisting of ones down the
main diagonal.  Usually <span class="math">\(\mathbf{B}\)</span> is denoted
<span class="math">\(\mathbf{B}=\mathbf{A}^{-1}\)</span> . In SciPy, the matrix inverse of
the Numpy array, A, is obtained using <tt class="xref py py-obj docutils literal"><span class="pre">linalg.inv</span></tt> <tt class="docutils literal"><span class="pre">(A)</span></tt> , or
using <tt class="docutils literal"><span class="pre">A.I</span></tt> if <tt class="docutils literal"><span class="pre">A</span></tt> is a Matrix. For example, let</p>
<div class="math">
\[\begin{split}\mathbf{A} = \left[\begin{array}{ccc} 1 &amp; 3 &amp; 5\\ 2 &amp; 5 &amp; 1\\ 2 &amp; 3 &amp; 8\end{array}\right]\end{split}\]</div>
<p>then</p>
<div class="math">
\[\begin{split}\mathbf{A^{-1}} = \frac{1}{25}
    \left[\begin{array}{ccc} -37 &amp; 9 &amp; 22 \\
                              14 &amp; 2 &amp; -9 \\
                              4 &amp; -3 &amp; 1
          \end{array}\right] = %
     \left[\begin{array}{ccc} -1.48 &amp; 0.36 &amp; 0.88  \\
                               0.56 &amp; 0.08 &amp; -0.36 \\
                               0.16 &amp; -0.12 &amp; 0.04
           \end{array}\right].\end{split}\]</div>
<p>The following example demonstrates this computation in SciPy</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[-2. ,  1. ],</span>
<span class="go">      [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="c">#double check</span>
<span class="go">array([[  1.00000000e+00,   0.00000000e+00],</span>
<span class="go">      [  4.44089210e-16,   1.00000000e+00]])</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-linear-system">
<h3>Solving linear system<a class="headerlink" href="#solving-linear-system" title="Permalink to this headline">¶</a></h3>
<p>Solving linear systems of equations is straightforward using the scipy
command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.solve</span></tt>. This command expects an input matrix and
a right-hand-side vector. The solution vector is then computed. An
option for entering a symmetrix matrix is offered which can speed up
the processing when applicable.  As an example, suppose it is desired
to solve the following simultaneous equations:</p>
<div class="math">
\[ \begin{eqnarray*} x + 3y + 5z & = & 10 \\
                   2x + 5y + z & = & 8  \\
                   2x + 3y + 8z & = & 3
 \end{eqnarray*}\]</div><p>We could find the solution vector using a matrix inverse:</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c} x\\ y\\ z\end{array}\right]=\left[\begin{array}{ccc} 1 &amp; 3 &amp; 5\\ 2 &amp; 5 &amp; 1\\ 2 &amp; 3 &amp; 8\end{array}\right]^{-1}\left[\begin{array}{c} 10\\ 8\\ 3\end{array}\right]=\frac{1}{25}\left[\begin{array}{c} -232\\ 129\\ 19\end{array}\right]=\left[\begin{array}{c} -9.28\\ 5.16\\ 0.76\end{array}\right].\end{split}\]</div>
<p>However, it is better to use the linalg.solve command which can be
faster and more numerically stable. In this case it however gives the
same answer as shown in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[5],</span>
<span class="go">      [6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c">#slow</span>
<span class="go">array([[-4. ],</span>
<span class="go">      [ 4.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">-</span><span class="n">b</span> <span class="c">#check</span>
<span class="go">array([[  8.88178420e-16],</span>
<span class="go">      [  2.66453526e-15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="c">#fast</span>
<span class="go">array([[-4. ],</span>
<span class="go">      [ 4.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="o">-</span><span class="n">b</span> <span class="c">#check</span>
<span class="go">array([[ 0.],</span>
<span class="go">      [ 0.]])</span>
</pre></div>
</div>
</div>
<div class="section" id="finding-determinant">
<h3>Finding Determinant<a class="headerlink" href="#finding-determinant" title="Permalink to this headline">¶</a></h3>
<p>The determinant of a square matrix <span class="math">\(\mathbf{A}\)</span> is often denoted
<span class="math">\(\left|\mathbf{A}\right|\)</span> and is a quantity often used in linear
algebra. Suppose <span class="math">\(a_{ij}\)</span> are the elements of the matrix
<span class="math">\(\mathbf{A}\)</span> and let <span class="math">\(M_{ij}=\left|\mathbf{A}_{ij}\right|\)</span>
be the determinant of the matrix left by removing the
<span class="math">\(i^{\textrm{th}}\)</span> row and <span class="math">\(j^{\textrm{th}}\)</span> column from
<span class="math">\(\mathbf{A}\)</span> . Then for any row <span class="math">\(i,\)</span></p>
<div class="math">
\[\left|\mathbf{A}\right|=\sum_{j}\left(-1\right)^{i+j}a_{ij}M_{ij}.\]</div>
<p>This is a recursive way to define the determinant where the base case
is defined by accepting that the determinant of a <span class="math">\(1\times1\)</span> matrix is the only matrix element. In SciPy the determinant can be
calculated with <tt class="xref py py-obj docutils literal"><span class="pre">linalg.det</span></tt> . For example, the determinant of</p>
<div class="math">
\[\begin{split}\mathbf{A=}\left[\begin{array}{ccc} 1 &amp; 3 &amp; 5\\ 2 &amp; 5 &amp; 1\\ 2 &amp; 3 &amp; 8\end{array}\right]\end{split}\]</div>
<p>is</p>
<div class="math">
\[ \begin{eqnarray*} \left|\mathbf{A}\right| & = & 1\left|\begin{array}{cc} 5 & 1\\ 3 & 8\end{array}\right|-3\left|\begin{array}{cc} 2 & 1\\ 2 & 8\end{array}\right|+5\left|\begin{array}{cc} 2 & 5\\ 2 & 3\end{array}\right|\\  & = & 1\left(5\cdot8-3\cdot1\right)-3\left(2\cdot8-2\cdot1\right)+5\left(2\cdot3-2\cdot5\right)=-25.\end{eqnarray*}\]</div><p>In SciPy this is computed as shown in this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">-2.0</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-norms">
<h3>Computing norms<a class="headerlink" href="#computing-norms" title="Permalink to this headline">¶</a></h3>
<p>Matrix and vector norms can also be computed with SciPy. A wide range
of norm definitions are available using different parameters to the
order argument of <tt class="xref py py-obj docutils literal"><span class="pre">linalg.norm</span></tt> . This function takes a rank-1
(vectors) or a rank-2 (matrices) array and an optional order argument
(default is 2). Based on these inputs a vector or matrix norm of the
requested order is computed.</p>
<p>For vector <em>x</em> , the order parameter can be any real number including
<tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt>. The computed norm is</p>
<div class="math">
\[\begin{split}\left\Vert \mathbf{x}\right\Vert =\left\{ \begin{array}{cc} \max\left|x_{i}\right| &amp; \textrm{ord}=\textrm{inf}\\ \min\left|x_{i}\right| &amp; \textrm{ord}=-\textrm{inf}\\ \left(\sum_{i}\left|x_{i}\right|^{\textrm{ord}}\right)^{1/\textrm{ord}} &amp; \left|\textrm{ord}\right|&lt;\infty.\end{array}\right.\end{split}\]</div>
<p>For matrix <span class="math">\(\mathbf{A}\)</span> the only valid values for norm are <span class="math">\(\pm2,\pm1,\)</span> <span class="math">\(\pm\)</span> inf, and &#8216;fro&#8217; (or &#8216;f&#8217;) Thus,</p>
<div class="math">
\[\begin{split}\left\Vert \mathbf{A}\right\Vert =\left\{ \begin{array}{cc} \max_{i}\sum_{j}\left|a_{ij}\right| &amp; \textrm{ord}=\textrm{inf}\\ \min_{i}\sum_{j}\left|a_{ij}\right| &amp; \textrm{ord}=-\textrm{inf}\\ \max_{j}\sum_{i}\left|a_{ij}\right| &amp; \textrm{ord}=1\\ \min_{j}\sum_{i}\left|a_{ij}\right| &amp; \textrm{ord}=-1\\ \max\sigma_{i} &amp; \textrm{ord}=2\\ \min\sigma_{i} &amp; \textrm{ord}=-2\\ \sqrt{\textrm{trace}\left(\mathbf{A}^{H}\mathbf{A}\right)} &amp; \textrm{ord}=\textrm{'fro'}\end{array}\right.\end{split}\]</div>
<p>where <span class="math">\(\sigma_{i}\)</span> are the singular values of <span class="math">\(\mathbf{A}\)</span> .</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">5.4772255750516612</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="s">&#39;fro&#39;</span><span class="p">)</span> <span class="c"># frobenius norm is the default</span>
<span class="go">5.4772255750516612</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c"># L1 norm (max column sum)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">inf</span><span class="p">)</span> <span class="c"># L inf norm (max row sum)</span>
<span class="go">7</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-linear-least-squares-problems-and-pseudo-inverses">
<h3>Solving linear least-squares problems and pseudo-inverses<a class="headerlink" href="#solving-linear-least-squares-problems-and-pseudo-inverses" title="Permalink to this headline">¶</a></h3>
<p>Linear least-squares problems occur in many branches of applied
mathematics. In this problem a set of linear scaling coefficients is
sought that allow a model to fit data. In particular it is assumed
that data <span class="math">\(y_{i}\)</span> is related to data <span class="math">\(\mathbf{x}_{i}\)</span>
through a set of coefficients <span class="math">\(c_{j}\)</span> and model functions
<span class="math">\(f_{j}\left(\mathbf{x}_{i}\right)\)</span> via the model</p>
<div class="math">
\[y_{i}=\sum_{j}c_{j}f_{j}\left(\mathbf{x}_{i}\right)+\epsilon_{i}\]</div>
<p>where <span class="math">\(\epsilon_{i}\)</span> represents uncertainty in the data. The
strategy of least squares is to pick the coefficients <span class="math">\(c_{j}\)</span> to
minimize</p>
<div class="math">
\[J\left(\mathbf{c}\right)=\sum_{i}\left|y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right|^{2}.\]</div>
<p>Theoretically, a global minimum will occur when</p>
<div class="math">
\[\frac{\partial J}{\partial c_{n}^{*}}=0=\sum_{i}\left(y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right)\left(-f_{n}^{*}\left(x_{i}\right)\right)\]</div>
<p>or</p>
<div class="math">
\[ \begin{eqnarray*} \sum_{j}c_{j}\sum_{i}f_{j}\left(x_{i}\right)f_{n}^{*}\left(x_{i}\right) & = & \sum_{i}y_{i}f_{n}^{*}\left(x_{i}\right)\\ \mathbf{A}^{H}\mathbf{Ac} & = & \mathbf{A}^{H}\mathbf{y}\end{eqnarray*}\]</div><p>where</p>
<div class="math">
\[\left\{ \mathbf{A}\right\} _{ij}=f_{j}\left(x_{i}\right).\]</div>
<p>When <span class="math">\(\mathbf{A^{H}A}\)</span> is invertible, then</p>
<div class="math">
\[\mathbf{c}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H}\mathbf{y}=\mathbf{A}^{\dagger}\mathbf{y}\]</div>
<p>where <span class="math">\(\mathbf{A}^{\dagger}\)</span> is called the pseudo-inverse of
<span class="math">\(\mathbf{A}.\)</span> Notice that using this definition of
<span class="math">\(\mathbf{A}\)</span> the model can be written</p>
<div class="math">
\[\mathbf{y}=\mathbf{Ac}+\boldsymbol{\epsilon}.\]</div>
<p>The command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.lstsq</span></tt> will solve the linear least squares
problem for <span class="math">\(\mathbf{c}\)</span> given <span class="math">\(\mathbf{A}\)</span> and
<span class="math">\(\mathbf{y}\)</span> . In addition <tt class="xref py py-obj docutils literal"><span class="pre">linalg.pinv</span></tt> or
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.pinv2</span></tt> (uses a different method based on singular value
decomposition) will find <span class="math">\(\mathbf{A}^{\dagger}\)</span> given
<span class="math">\(\mathbf{A}.\)</span></p>
<p>The following example and figure demonstrate the use of
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.lstsq</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">linalg.pinv</span></tt> for solving a data-fitting
problem. The data shown below were generated using the model:</p>
<div class="math">
\[y_{i}=c_{1}e^{-x_{i}}+c_{2}x_{i}\]</div>
<p>where <span class="math">\(x_{i}=0.1i\)</span> for <span class="math">\(i=1\ldots10\)</span> , <span class="math">\(c_{1}=5\)</span> ,
and <span class="math">\(c_{2}=4.\)</span> Noise is added to <span class="math">\(y_{i}\)</span> and the
coefficients <span class="math">\(c_{1}\)</span> and <span class="math">\(c_{2}\)</span> are estimated using
linear least squares.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yi</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">*</span><span class="n">xi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zi</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">+</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xi</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">xi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mf">0.1</span><span class="p">:</span><span class="mf">1.0</span><span class="p">:</span><span class="mi">100j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yi2</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xi2</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xi2</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">zi</span><span class="p">,</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">xi2</span><span class="p">,</span><span class="n">yi2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">5.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;$x_i$&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Data fitting with linalg.lstsq&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../tutorial/linalg-1.py">Source code</a>)</p>
<div class="figure">
<img alt="../_images/linalg-1.png" src="../_images/linalg-1.png" />
</div>
</div>
<div class="section" id="generalized-inverse">
<h3>Generalized inverse<a class="headerlink" href="#generalized-inverse" title="Permalink to this headline">¶</a></h3>
<p>The generalized inverse is calculated using the command
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.pinv</span></tt> or <tt class="xref py py-obj docutils literal"><span class="pre">linalg.pinv2</span></tt>. These two commands differ
in how they compute the generalized inverse.  The first uses the
linalg.lstsq algorithm while the second uses singular value
decomposition. Let <span class="math">\(\mathbf{A}\)</span> be an <span class="math">\(M\times N\)</span> matrix,
then if <span class="math">\(M&gt;N\)</span> the generalized inverse is</p>
<div class="math">
\[\mathbf{A}^{\dagger}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H}\]</div>
<p>while if <span class="math">\(M&lt;N\)</span> matrix the generalized inverse is</p>
<div class="math">
\[\mathbf{A}^{\#}=\mathbf{A}^{H}\left(\mathbf{A}\mathbf{A}^{H}\right)^{-1}.\]</div>
<p>In both cases for <span class="math">\(M=N\)</span> , then</p>
<div class="math">
\[\mathbf{A}^{\dagger}=\mathbf{A}^{\#}=\mathbf{A}^{-1}\]</div>
<p>as long as <span class="math">\(\mathbf{A}\)</span> is invertible.</p>
</div>
</div>
<div class="section" id="decompositions">
<h2>Decompositions<a class="headerlink" href="#decompositions" title="Permalink to this headline">¶</a></h2>
<p>In many applications it is useful to decompose a matrix using other
representations. There are several decompositions supported by SciPy.</p>
<div class="section" id="eigenvalues-and-eigenvectors">
<h3>Eigenvalues and eigenvectors<a class="headerlink" href="#eigenvalues-and-eigenvectors" title="Permalink to this headline">¶</a></h3>
<p>The eigenvalue-eigenvector problem is one of the most commonly
employed linear algebra operations. In one popular form, the
eigenvalue-eigenvector problem is to find for some square matrix
<span class="math">\(\mathbf{A}\)</span> scalars <span class="math">\(\lambda\)</span> and corresponding vectors
<span class="math">\(\mathbf{v}\)</span> such that</p>
<div class="math">
\[\mathbf{Av}=\lambda\mathbf{v}.\]</div>
<p>For an <span class="math">\(N\times N\)</span> matrix, there are <span class="math">\(N\)</span> (not necessarily
distinct) eigenvalues &#8212; roots of the (characteristic) polynomial</p>
<div class="math">
\[\left|\mathbf{A}-\lambda\mathbf{I}\right|=0.\]</div>
<p>The eigenvectors, <span class="math">\(\mathbf{v}\)</span> , are also sometimes called right
eigenvectors to distinguish them from another set of left eigenvectors
that satisfy</p>
<div class="math">
\[\mathbf{v}_{L}^{H}\mathbf{A}=\lambda\mathbf{v}_{L}^{H}\]</div>
<p>or</p>
<div class="math">
\[\mathbf{A}^{H}\mathbf{v}_{L}=\lambda^{*}\mathbf{v}_{L}.\]</div>
<p>With it&#8217;s default optional arguments, the command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.eig</span></tt>
returns <span class="math">\(\lambda\)</span> and <span class="math">\(\mathbf{v}.\)</span> However, it can also
return <span class="math">\(\mathbf{v}_{L}\)</span> and just <span class="math">\(\lambda\)</span> by itself (
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.eigvals</span></tt> returns just <span class="math">\(\lambda\)</span> as well).</p>
<p>In addition, <tt class="xref py py-obj docutils literal"><span class="pre">linalg.eig</span></tt> can also solve the more general eigenvalue problem</p>
<div class="math">
\[ \begin{eqnarray*} \mathbf{Av} & = & \lambda\mathbf{Bv}\\ \mathbf{A}^{H}\mathbf{v}_{L} & = & \lambda^{*}\mathbf{B}^{H}\mathbf{v}_{L}\end{eqnarray*}\]</div><p>for square matrices <span class="math">\(\mathbf{A}\)</span> and <span class="math">\(\mathbf{B}.\)</span> The
standard eigenvalue problem is an example of the general eigenvalue
problem for <span class="math">\(\mathbf{B}=\mathbf{I}.\)</span> When a generalized
eigenvalue problem can be solved, then it provides a decomposition of
<span class="math">\(\mathbf{A}\)</span> as</p>
<div class="math">
\[\mathbf{A}=\mathbf{BV}\boldsymbol{\Lambda}\mathbf{V}^{-1}\]</div>
<p>where <span class="math">\(\mathbf{V}\)</span> is the collection of eigenvectors into
columns and <span class="math">\(\boldsymbol{\Lambda}\)</span> is a diagonal matrix of
eigenvalues.</p>
<p>By definition, eigenvectors are only defined up to a constant scale
factor. In SciPy, the scaling factor for the eigenvectors is chosen so
that <span class="math">\(\left\Vert \mathbf{v}\right\Vert
^{2}=\sum_{i}v_{i}^{2}=1.\)</span></p>
<p>As an example, consider finding the eigenvalues and eigenvectors of
the matrix</p>
<div class="math">
\[\begin{split}\mathbf{A}=\left[\begin{array}{ccc} 1 &amp; 5 &amp; 2\\ 2 &amp; 4 &amp; 1\\ 3 &amp; 6 &amp; 2\end{array}\right].\end{split}\]</div>
<p>The characteristic polynomial is</p>
<div class="math">
\[ \begin{eqnarray*} \left|\mathbf{A}-\lambda\mathbf{I}\right| & = & \left(1-\lambda\right)\left[\left(4-\lambda\right)\left(2-\lambda\right)-6\right]-\\  &  & 5\left[2\left(2-\lambda\right)-3\right]+2\left[12-3\left(4-\lambda\right)\right]\\  & = & -\lambda^{3}+7\lambda^{2}+8\lambda-3.\end{eqnarray*}\]</div><p>The roots of this polynomial are the eigenvalues of <span class="math">\(\mathbf{A}\)</span> :</p>
<div class="math">
\[ \begin{eqnarray*} \lambda_{1} & = & 7.9579\\ \lambda_{2} & = & -1.2577\\ \lambda_{3} & = & 0.2997.\end{eqnarray*}\]</div><p>The eigenvectors corresponding to each eigenvalue can be found using
the original equation. The eigenvectors associated with these
eigenvalues can then be found.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">la</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span> <span class="o">=</span> <span class="n">la</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span>  <span class="c">#eigenvalues</span>
<span class="go">(-0.372281323269+0j) (5.37228132327+0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c">#first eigenvector</span>
<span class="go">[-0.82456484  0.56576746]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>  <span class="c">#second eigenvector</span>
<span class="go">[-0.41597356 -0.90937671]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c">#eigenvectors are unitary</span>
<span class="go">[ 1.  1. ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">-</span><span class="n">l1</span><span class="o">*</span><span class="n">v1</span><span class="p">)</span> <span class="c">#check the computation</span>
<span class="go">3.23682852457e-16</span>
</pre></div>
</div>
</div>
<div class="section" id="singular-value-decomposition">
<h3>Singular value decomposition<a class="headerlink" href="#singular-value-decomposition" title="Permalink to this headline">¶</a></h3>
<p>Singular Value Decomposition (SVD) can be thought of as an extension of
the eigenvalue problem to matrices that are not square. Let
<span class="math">\(\mathbf{A}\)</span> be an <span class="math">\(M\times N\)</span> matrix with <span class="math">\(M\)</span> and
<span class="math">\(N\)</span> arbitrary. The matrices <span class="math">\(\mathbf{A}^{H}\mathbf{A}\)</span> and
<span class="math">\(\mathbf{A}\mathbf{A}^{H}\)</span> are square hermitian matrices <a class="footnote-reference" href="#id3" id="id1">[1]</a> of
size <span class="math">\(N\times N\)</span> and <span class="math">\(M\times M\)</span> respectively. It is known
that the eigenvalues of square hermitian matrices are real and
non-negative. In addition, there are at most
<span class="math">\(\min\left(M,N\right)\)</span> identical non-zero eigenvalues of
<span class="math">\(\mathbf{A}^{H}\mathbf{A}\)</span> and <span class="math">\(\mathbf{A}\mathbf{A}^{H}.\)</span>
Define these positive eigenvalues as <span class="math">\(\sigma_{i}^{2}.\)</span> The
square-root of these are called singular values of <span class="math">\(\mathbf{A}.\)</span>
The eigenvectors of <span class="math">\(\mathbf{A}^{H}\mathbf{A}\)</span> are collected by
columns into an <span class="math">\(N\times N\)</span> unitary <a class="footnote-reference" href="#id4" id="id2">[2]</a> matrix
<span class="math">\(\mathbf{V}\)</span> while the eigenvectors of
<span class="math">\(\mathbf{A}\mathbf{A}^{H}\)</span> are collected by columns in the
unitary matrix <span class="math">\(\mathbf{U}\)</span> , the singular values are collected
in an <span class="math">\(M\times N\)</span> zero matrix
<span class="math">\(\mathbf{\boldsymbol{\Sigma}}\)</span> with main diagonal entries set to
the singular values. Then</p>
<div class="math">
\[\mathbf{A=U}\boldsymbol{\Sigma}\mathbf{V}^{H}\]</div>
<p>is the singular-value decomposition of <span class="math">\(\mathbf{A}.\)</span> Every
matrix has a singular value decomposition. Sometimes, the singular
values are called the spectrum of <span class="math">\(\mathbf{A}.\)</span> The command
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.svd</span></tt> will return <span class="math">\(\mathbf{U}\)</span> ,
<span class="math">\(\mathbf{V}^{H}\)</span> , and <span class="math">\(\sigma_{i}\)</span> as an array of the
singular values. To obtain the matrix <span class="math">\(\mathbf{\Sigma}\)</span> use
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.diagsvd</span></tt>. The following example illustrates the use of
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.svd</span></tt> .</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">      [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">diagsvd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span>
<span class="go">array([[-0.3863177 , -0.92236578],</span>
<span class="go">      [-0.92236578,  0.3863177 ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span>
<span class="go">array([[ 9.508032  ,  0.        ,  0.        ],</span>
<span class="go">      [ 0.        ,  0.77286964,  0.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Vh</span>
<span class="go">array([[-0.42866713, -0.56630692, -0.7039467 ],</span>
<span class="go">      [ 0.80596391,  0.11238241, -0.58119908],</span>
<span class="go">      [ 0.40824829, -0.81649658,  0.40824829]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vh</span><span class="p">))</span> <span class="c">#check computation</span>
<span class="go">array([[ 1.,  2.,  3.],</span>
<span class="go">      [ 4.,  5.,  6.]])</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>A hermitian matrix <span class="math">\(\mathbf{D}\)</span> satisfies <span class="math">\(\mathbf{D}^{H}=\mathbf{D}.\)</span></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>A unitary matrix <span class="math">\(\mathbf{D}\)</span> satisfies <span class="math">\(\mathbf{D}^{H}\mathbf{D}=\mathbf{I}=\mathbf{D}\mathbf{D}^{H}\)</span> so that <span class="math">\(\mathbf{D}^{-1}=\mathbf{D}^{H}.\)</span></td></tr>
</tbody>
</table>
</div>
<div class="section" id="lu-decomposition">
<h3>LU decomposition<a class="headerlink" href="#lu-decomposition" title="Permalink to this headline">¶</a></h3>
<p>The LU decomposition finds a representation for the <span class="math">\(M\times N\)</span>
matrix <span class="math">\(\mathbf{A}\)</span> as</p>
<div class="math">
\[\mathbf{A}=\mathbf{P}\,\mathbf{L}\,\mathbf{U}\]</div>
<p>where <span class="math">\(\mathbf{P}\)</span> is an <span class="math">\(M\times M\)</span> permutation matrix (a
permutation of the rows of the identity matrix), <span class="math">\(\mathbf{L}\)</span> is
in <span class="math">\(M\times K\)</span> lower triangular or trapezoidal matrix (
<span class="math">\(K=\min\left(M,N\right)\)</span> ) with unit-diagonal, and
<span class="math">\(\mathbf{U}\)</span> is an upper triangular or trapezoidal matrix. The
SciPy command for this decomposition is <tt class="xref py py-obj docutils literal"><span class="pre">linalg.lu</span></tt> .</p>
<p>Such a decomposition is often useful for solving many simultaneous
equations where the left-hand-side does not change but the right hand
side does. For example, suppose we are going to solve</p>
<div class="math">
\[\mathbf{A}\mathbf{x}_{i}=\mathbf{b}_{i}\]</div>
<p>for many different <span class="math">\(\mathbf{b}_{i}\)</span> . The LU decomposition allows this to be written as</p>
<div class="math">
\[\mathbf{PLUx}_{i}=\mathbf{b}_{i}.\]</div>
<p>Because <span class="math">\(\mathbf{L}\)</span> is lower-triangular, the equation can be
solved for <span class="math">\(\mathbf{U}\mathbf{x}_{i}\)</span> and finally
<span class="math">\(\mathbf{x}_{i}\)</span> very rapidly using forward- and
back-substitution. An initial time spent factoring <span class="math">\(\mathbf{A}\)</span>
allows for very rapid solution of similar systems of equations in the
future. If the intent for performing LU decomposition is for solving
linear systems then the command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.lu_factor</span></tt> should be used
followed by repeated applications of the command
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.lu_solve</span></tt> to solve the system for each new
right-hand-side.</p>
</div>
<div class="section" id="cholesky-decomposition">
<h3>Cholesky decomposition<a class="headerlink" href="#cholesky-decomposition" title="Permalink to this headline">¶</a></h3>
<p>Cholesky decomposition is a special case of LU decomposition
applicable to Hermitian positive definite matrices. When
<span class="math">\(\mathbf{A}=\mathbf{A}^{H}\)</span> and
<span class="math">\(\mathbf{x}^{H}\mathbf{Ax}\geq0\)</span> for all <span class="math">\(\mathbf{x}\)</span> ,
then decompositions of <span class="math">\(\mathbf{A}\)</span> can be found so that</p>
<div class="math">
\[ \begin{eqnarray*} \mathbf{A} & = & \mathbf{U}^{H}\mathbf{U}\\ \mathbf{A} & = & \mathbf{L}\mathbf{L}^{H}\end{eqnarray*}\]</div><p>where <span class="math">\(\mathbf{L}\)</span> is lower-triangular and <span class="math">\(\mathbf{U}\)</span> is
upper triangular. Notice that <span class="math">\(\mathbf{L}=\mathbf{U}^{H}.\)</span> The
command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.cholesky</span></tt> computes the cholesky
factorization. For using cholesky factorization to solve systems of
equations there are also <tt class="xref py py-obj docutils literal"><span class="pre">linalg.cho_factor</span></tt> and
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.cho_solve</span></tt> routines that work similarly to their LU
decomposition counterparts.</p>
</div>
<div class="section" id="qr-decomposition">
<h3>QR decomposition<a class="headerlink" href="#qr-decomposition" title="Permalink to this headline">¶</a></h3>
<p>The QR decomposition (sometimes called a polar decomposition) works
for any <span class="math">\(M\times N\)</span> array and finds an <span class="math">\(M\times M\)</span> unitary
matrix <span class="math">\(\mathbf{Q}\)</span> and an <span class="math">\(M\times N\)</span> upper-trapezoidal
matrix <span class="math">\(\mathbf{R}\)</span> such that</p>
<div class="math">
\[\mathbf{A=QR}.\]</div>
<p>Notice that if the SVD of <span class="math">\(\mathbf{A}\)</span> is known then the QR decomposition can be found</p>
<div class="math">
\[\mathbf{A}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{H}=\mathbf{QR}\]</div>
<p>implies that <span class="math">\(\mathbf{Q}=\mathbf{U}\)</span> and
<span class="math">\(\mathbf{R}=\boldsymbol{\Sigma}\mathbf{V}^{H}.\)</span> Note, however,
that in SciPy independent algorithms are used to find QR and SVD
decompositions. The command for QR decomposition is <tt class="xref py py-obj docutils literal"><span class="pre">linalg.qr</span></tt> .</p>
</div>
<div class="section" id="schur-decomposition">
<h3>Schur decomposition<a class="headerlink" href="#schur-decomposition" title="Permalink to this headline">¶</a></h3>
<p>For a square <span class="math">\(N\times N\)</span> matrix, <span class="math">\(\mathbf{A}\)</span> , the Schur
decomposition finds (not-necessarily unique) matrices
<span class="math">\(\mathbf{T}\)</span> and <span class="math">\(\mathbf{Z}\)</span> such that</p>
<div class="math">
\[\mathbf{A}=\mathbf{ZT}\mathbf{Z}^{H}\]</div>
<p>where <span class="math">\(\mathbf{Z}\)</span> is a unitary matrix and <span class="math">\(\mathbf{T}\)</span> is
either upper-triangular or quasi-upper triangular depending on whether
or not a real schur form or complex schur form is requested.  For a
real schur form both <span class="math">\(\mathbf{T}\)</span> and <span class="math">\(\mathbf{Z}\)</span> are
real-valued when <span class="math">\(\mathbf{A}\)</span> is real-valued. When
<span class="math">\(\mathbf{A}\)</span> is a real-valued matrix the real schur form is only
quasi-upper triangular because <span class="math">\(2\times2\)</span> blocks extrude from
the main diagonal corresponding to any complex- valued
eigenvalues. The command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.schur</span></tt> finds the Schur
decomposition while the command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.rsf2csf</span></tt> converts
<span class="math">\(\mathbf{T}\)</span> and <span class="math">\(\mathbf{Z}\)</span> from a real Schur form to a
complex Schur form. The Schur form is especially useful in calculating
functions of matrices.</p>
<p>The following example illustrates the schur decomposition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="s">&#39;[1 3 2; 1 4 5; 2 3 6]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T1</span><span class="p">,</span><span class="n">Z1</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="s">&#39;complex&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T2</span><span class="p">,</span><span class="n">Z2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rsf2csf</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">T</span>
<span class="go">[[ 9.90012467  1.78947961 -0.65498528]</span>
<span class="go"> [ 0.          0.54993766 -1.57754789]</span>
<span class="go"> [ 0.          0.51260928  0.54993766]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">T2</span>
<span class="go">[[ 9.90012467 +0.00000000e+00j -0.32436598 +1.55463542e+00j</span>
<span class="go">  -0.88619748 +5.69027615e-01j]</span>
<span class="go"> [ 0.00000000 +0.00000000e+00j  0.54993766 +8.99258408e-01j</span>
<span class="go">   1.06493862 +1.37016050e-17j]</span>
<span class="go"> [ 0.00000000 +0.00000000e+00j  0.00000000 +0.00000000e+00j</span>
<span class="go">   0.54993766 -8.99258408e-01j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">abs</span><span class="p">(</span><span class="n">T1</span><span class="o">-</span><span class="n">T2</span><span class="p">)</span> <span class="c"># different</span>
<span class="go">[[  1.24357637e-14   2.09205364e+00   6.56028192e-01]</span>
<span class="go"> [  0.00000000e+00   4.00296604e-16   1.83223097e+00]</span>
<span class="go"> [  0.00000000e+00   0.00000000e+00   4.57756680e-16]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Z1</span><span class="o">-</span><span class="n">Z2</span><span class="p">)</span> <span class="c"># different</span>
<span class="go">[[ 0.06833781  1.10591375  0.23662249]</span>
<span class="go"> [ 0.11857169  0.5585604   0.29617525]</span>
<span class="go"> [ 0.12624999  0.75656818  0.22975038]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">Z1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">Z2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">mat</span><span class="p">,(</span><span class="n">T</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">Z1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">Z2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">Z</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Z</span><span class="o">.</span><span class="n">H</span><span class="p">)</span> <span class="c"># same</span>
<span class="go">[[  1.11022302e-16   4.44089210e-16   4.44089210e-16]</span>
<span class="go"> [  4.44089210e-16   1.33226763e-15   8.88178420e-16]</span>
<span class="go"> [  8.88178420e-16   4.44089210e-16   2.66453526e-15]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">Z1</span><span class="o">*</span><span class="n">T1</span><span class="o">*</span><span class="n">Z1</span><span class="o">.</span><span class="n">H</span><span class="p">)</span> <span class="c"># same</span>
<span class="go">[[  1.00043248e-15   2.22301403e-15   5.55749485e-15]</span>
<span class="go"> [  2.88899660e-15   8.44927041e-15   9.77322008e-15]</span>
<span class="go"> [  3.11291538e-15   1.15463228e-14   1.15464861e-14]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">Z2</span><span class="o">*</span><span class="n">T2</span><span class="o">*</span><span class="n">Z2</span><span class="o">.</span><span class="n">H</span><span class="p">)</span> <span class="c"># same</span>
<span class="go">[[  3.34058710e-16   8.88611201e-16   4.18773089e-18]</span>
<span class="go"> [  1.48694940e-16   8.95109973e-16   8.92966151e-16]</span>
<span class="go"> [  1.33228956e-15   1.33582317e-15   3.55373104e-15]]</span>
</pre></div>
</div>
</div>
<div class="section" id="interpolative-decomposition">
<h3>Interpolative Decomposition<a class="headerlink" href="#interpolative-decomposition" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../linalg.interpolative.html#module-scipy.linalg.interpolative" title="scipy.linalg.interpolative"><tt class="xref py py-mod docutils literal"><span class="pre">scipy.linalg.interpolative</span></tt></a> contains routines for computing the
interpolative decomposition (ID) of a matrix. For a matrix <span class="math">\(A
\in \mathbb{C}^{m \times n}\)</span> of rank <span class="math">\(k \leq \min \{ m, n \}\)</span>
this is a factorization</p>
<div class="math">
\[\begin{split}A \Pi =
\begin{bmatrix}
 A \Pi_{1} &amp; A \Pi_{2}
\end{bmatrix} =
A \Pi_{1}
\begin{bmatrix}
 I &amp; T
\end{bmatrix},\end{split}\]</div>
<p>where <span class="math">\(\Pi = [\Pi_{1}, \Pi_{2}]\)</span> is a permutation matrix with
<span class="math">\(\Pi_{1} \in \{ 0, 1 \}^{n \times k}\)</span>, i.e., <span class="math">\(A \Pi_{2} =
A \Pi_{1} T\)</span>. This can equivalently be written as <span class="math">\(A = BP\)</span>,
where <span class="math">\(B = A \Pi_{1}\)</span> and <span class="math">\(P = [I, T] \Pi^{\mathsf{T}}\)</span>
are the <em>skeleton</em> and <em>interpolation matrices</em>, respectively.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../linalg.interpolative.html#module-scipy.linalg.interpolative" title="scipy.linalg.interpolative"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.interpolative</span></tt></a> &#8212; for more information.</p>
</div>
</div>
</div>
<div class="section" id="matrix-functions">
<h2>Matrix Functions<a class="headerlink" href="#matrix-functions" title="Permalink to this headline">¶</a></h2>
<p>Consider the function <span class="math">\(f\left(x\right)\)</span> with Taylor series expansion</p>
<div class="math">
\[f\left(x\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}x^{k}.\]</div>
<p>A matrix function can be defined using this Taylor series for the
square matrix <span class="math">\(\mathbf{A}\)</span> as</p>
<div class="math">
\[f\left(\mathbf{A}\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}\mathbf{A}^{k}.\]</div>
<p>While, this serves as a useful representation of a matrix function, it
is rarely the best way to calculate a matrix function.</p>
<div class="section" id="exponential-and-logarithm-functions">
<h3>Exponential and logarithm functions<a class="headerlink" href="#exponential-and-logarithm-functions" title="Permalink to this headline">¶</a></h3>
<p>The matrix exponential is one of the more common matrix functions. It
can be defined for square matrices as</p>
<div class="math">
\[e^{\mathbf{A}}=\sum_{k=0}^{\infty}\frac{1}{k!}\mathbf{A}^{k}.\]</div>
<p>The command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.expm3</span></tt> uses this Taylor series definition to compute the matrix exponential.
Due to poor convergence properties it is not often used.</p>
<p>Another method to compute the matrix exponential is to find an
eigenvalue decomposition of <span class="math">\(\mathbf{A}\)</span> :</p>
<div class="math">
\[\mathbf{A}=\mathbf{V}\boldsymbol{\Lambda}\mathbf{V}^{-1}\]</div>
<p>and note that</p>
<div class="math">
\[e^{\mathbf{A}}=\mathbf{V}e^{\boldsymbol{\Lambda}}\mathbf{V}^{-1}\]</div>
<p>where the matrix exponential of the diagonal matrix <span class="math">\(\boldsymbol{\Lambda}\)</span> is just the exponential of its elements. This method is implemented in <tt class="xref py py-obj docutils literal"><span class="pre">linalg.expm2</span></tt> .</p>
<p>The preferred method for implementing the matrix exponential is to use
scaling and a Padé approximation for <span class="math">\(e^{x}\)</span> . This algorithm is
implemented as <tt class="xref py py-obj docutils literal"><span class="pre">linalg.expm</span></tt> .</p>
<p>The inverse of the matrix exponential is the matrix logarithm defined
as the inverse of the matrix exponential.</p>
<div class="math">
\[\mathbf{A}\equiv\exp\left(\log\left(\mathbf{A}\right)\right).\]</div>
<p>The matrix logarithm can be obtained with <tt class="xref py py-obj docutils literal"><span class="pre">linalg.logm</span></tt> .</p>
</div>
<div class="section" id="trigonometric-functions">
<h3>Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<p>The trigonometric functions <span class="math">\(\sin\)</span> , <span class="math">\(\cos\)</span> , and
<span class="math">\(\tan\)</span> are implemented for matrices in <tt class="xref py py-func docutils literal"><span class="pre">linalg.sinm</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">linalg.cosm</span></tt>, and <tt class="xref py py-obj docutils literal"><span class="pre">linalg.tanm</span></tt> respectively. The matrix
sin and cosine can be defined using Euler&#8217;s identity as</p>
<div class="math">
\[ \begin{eqnarray*} \sin\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}-e^{-j\mathbf{A}}}{2j}\\ \cos\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}+e^{-j\mathbf{A}}}{2}.\end{eqnarray*}\]</div><p>The tangent is</p>
<div class="math">
\[\tan\left(x\right)=\frac{\sin\left(x\right)}{\cos\left(x\right)}=\left[\cos\left(x\right)\right]^{-1}\sin\left(x\right)\]</div>
<p>and so the matrix tangent is defined as</p>
<div class="math">
\[\left[\cos\left(\mathbf{A}\right)\right]^{-1}\sin\left(\mathbf{A}\right).\]</div>
</div>
<div class="section" id="hyperbolic-trigonometric-functions">
<h3>Hyperbolic trigonometric functions<a class="headerlink" href="#hyperbolic-trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<p>The hyperbolic trigonemetric functions <span class="math">\(\sinh\)</span> , <span class="math">\(\cosh\)</span> ,
and <span class="math">\(\tanh\)</span> can also be defined for matrices using the familiar
definitions:</p>
<div class="math">
\[ \begin{eqnarray*} \sinh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}-e^{-\mathbf{A}}}{2}\\ \cosh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}+e^{-\mathbf{A}}}{2}\\ \tanh\left(\mathbf{A}\right) & = & \left[\cosh\left(\mathbf{A}\right)\right]^{-1}\sinh\left(\mathbf{A}\right).\end{eqnarray*}\]</div><p>These matrix functions can be found using <tt class="xref py py-obj docutils literal"><span class="pre">linalg.sinhm</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">linalg.coshm</span></tt> , and <tt class="xref py py-obj docutils literal"><span class="pre">linalg.tanhm</span></tt>.</p>
</div>
<div class="section" id="arbitrary-function">
<h3>Arbitrary function<a class="headerlink" href="#arbitrary-function" title="Permalink to this headline">¶</a></h3>
<p>Finally, any arbitrary function that takes one complex number and
returns a complex number can be called as a matrix function using the
command <tt class="xref py py-obj docutils literal"><span class="pre">linalg.funm</span></tt>. This command takes the matrix and an
arbitrary Python function. It then implements an algorithm from Golub
and Van Loan&#8217;s book &#8220;Matrix Computations &#8220;to compute function applied
to the matrix using a Schur decomposition.  Note that <em>the function
needs to accept complex numbers</em> as input in order to work with this
algorithm. For example the following code computes the zeroth-order
Bessel function applied to a matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">funm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">special</span><span class="o">.</span><span class="n">jv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">A</span>
<span class="go">[[ 0.72578091  0.34105276  0.79570345]</span>
<span class="go"> [ 0.65767207  0.73855618  0.541453  ]</span>
<span class="go"> [ 0.78397086  0.68043507  0.4837898 ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">B</span>
<span class="go">[[ 0.72599893 -0.20545711 -0.22721101]</span>
<span class="go"> [-0.27426769  0.77255139 -0.23422637]</span>
<span class="go"> [-0.27612103 -0.21754832  0.7556849 ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.91262611+0.j  0.21846476+0.j -0.18296399+0.j]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">special</span><span class="o">.</span><span class="n">jv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">[ 0.27448286+0.j  0.98810383+0.j  0.99164854+0.j]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 0.27448286+0.j  0.98810383+0.j  0.99164854+0.j]</span>
</pre></div>
</div>
<p>Note how, by virtue of how matrix analytic functions are defined,
the Bessel function has acted on the matrix eigenvalues.</p>
</div>
</div>
<div class="section" id="special-matrices">
<h2>Special matrices<a class="headerlink" href="#special-matrices" title="Permalink to this headline">¶</a></h2>
<p>SciPy and NumPy provide several functions for creating special matrices
that are frequently used in engineering and science.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="25%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>block diagonal</td>
<td><a class="reference internal" href="../generated/scipy.linalg.block_diag.html#scipy.linalg.block_diag" title="scipy.linalg.block_diag"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.block_diag</span></tt></a></td>
<td>Create a block diagonal matrix from the provided arrays.</td>
</tr>
<tr class="row-odd"><td>circulant</td>
<td><a class="reference internal" href="../generated/scipy.linalg.circulant.html#scipy.linalg.circulant" title="scipy.linalg.circulant"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.circulant</span></tt></a></td>
<td>Construct a circulant matrix.</td>
</tr>
<tr class="row-even"><td>companion</td>
<td><a class="reference internal" href="../generated/scipy.linalg.companion.html#scipy.linalg.companion" title="scipy.linalg.companion"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.companion</span></tt></a></td>
<td>Create a companion matrix.</td>
</tr>
<tr class="row-odd"><td>Hadamard</td>
<td><a class="reference internal" href="../generated/scipy.linalg.hadamard.html#scipy.linalg.hadamard" title="scipy.linalg.hadamard"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.hadamard</span></tt></a></td>
<td>Construct a Hadamard matrix.</td>
</tr>
<tr class="row-even"><td>Hankel</td>
<td><a class="reference internal" href="../generated/scipy.linalg.hankel.html#scipy.linalg.hankel" title="scipy.linalg.hankel"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.hankel</span></tt></a></td>
<td>Construct a Hankel matrix.</td>
</tr>
<tr class="row-odd"><td>Hilbert</td>
<td><a class="reference internal" href="../generated/scipy.linalg.hilbert.html#scipy.linalg.hilbert" title="scipy.linalg.hilbert"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.hilbert</span></tt></a></td>
<td>Construct a Hilbert matrix.</td>
</tr>
<tr class="row-even"><td>Inverse Hilbert</td>
<td><a class="reference internal" href="../generated/scipy.linalg.invhilbert.html#scipy.linalg.invhilbert" title="scipy.linalg.invhilbert"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.invhilbert</span></tt></a></td>
<td>Construct the inverse of a Hilbert matrix.</td>
</tr>
<tr class="row-odd"><td>Leslie</td>
<td><a class="reference internal" href="../generated/scipy.linalg.leslie.html#scipy.linalg.leslie" title="scipy.linalg.leslie"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.leslie</span></tt></a></td>
<td>Create a Leslie matrix.</td>
</tr>
<tr class="row-even"><td>Pascal</td>
<td><a class="reference internal" href="../generated/scipy.linalg.pascal.html#scipy.linalg.pascal" title="scipy.linalg.pascal"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.pascal</span></tt></a></td>
<td>Create a Pascal matrix.</td>
</tr>
<tr class="row-odd"><td>Toeplitz</td>
<td><a class="reference internal" href="../generated/scipy.linalg.toeplitz.html#scipy.linalg.toeplitz" title="scipy.linalg.toeplitz"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.linalg.toeplitz</span></tt></a></td>
<td>Construct a Toeplitz matrix.</td>
</tr>
<tr class="row-even"><td>Van der Monde</td>
<td><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.vander.html#numpy.vander" title="(in NumPy v1.9)"><tt class="xref py py-obj docutils literal"><span class="pre">numpy.vander</span></tt></a></td>
<td>Generate a Van der Monde matrix.</td>
</tr>
</tbody>
</table>
<p>For examples of the use of these functions, see their respective docstrings.</p>
</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2014, The Scipy community.
      </li>
      <li>
      Last updated on Jul 24, 2015.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>