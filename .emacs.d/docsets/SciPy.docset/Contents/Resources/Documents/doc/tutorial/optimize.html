<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Optimization (scipy.optimize)</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.16.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="top" title="SciPy v0.16.0 Reference Guide" href="../index.html" >
    <link rel="up" title="SciPy Tutorial" href="index.html" >
    <link rel="next" title="Interpolation (scipy.interpolate)" href="interpolate.html" >
    <link rel="prev" title="Integration (scipy.integrate)" href="integrate.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">SciPy v0.16.0 Reference Guide</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">SciPy Tutorial</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="../scipy-optimize-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="interpolate.html" title="Interpolation (scipy.interpolate)"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="integrate.html" title="Integration (scipy.integrate)"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/scipyshiny_small.png" alt="Logo">
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Optimization (<tt class="docutils literal"><span class="pre">scipy.optimize</span></tt>)</a><ul>
<li><a class="reference internal" href="#unconstrained-minimization-of-multivariate-scalar-functions-minimize">Unconstrained minimization of multivariate scalar functions (<tt class="docutils literal"><span class="pre">minimize</span></tt>)</a><ul>
<li><a class="reference internal" href="#nelder-mead-simplex-algorithm-method-nelder-mead">Nelder-Mead Simplex algorithm (<tt class="docutils literal"><span class="pre">method='Nelder-Mead'</span></tt>)</a></li>
<li><a class="reference internal" href="#broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs">Broyden-Fletcher-Goldfarb-Shanno algorithm (<tt class="docutils literal"><span class="pre">method='BFGS'</span></tt>)</a></li>
<li><a class="reference internal" href="#newton-conjugate-gradient-algorithm-method-newton-cg">Newton-Conjugate-Gradient algorithm (<tt class="docutils literal"><span class="pre">method='Newton-CG'</span></tt>)</a><ul>
<li><a class="reference internal" href="#full-hessian-example">Full Hessian example:</a></li>
<li><a class="reference internal" href="#hessian-product-example">Hessian product example:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#constrained-minimization-of-multivariate-scalar-functions-minimize">Constrained minimization of multivariate scalar functions (<tt class="docutils literal"><span class="pre">minimize</span></tt>)</a></li>
<li><a class="reference internal" href="#least-square-fitting-leastsq">Least-square fitting (<tt class="docutils literal"><span class="pre">leastsq</span></tt>)</a></li>
<li><a class="reference internal" href="#univariate-function-minimizers-minimize-scalar">Univariate function minimizers (<tt class="docutils literal"><span class="pre">minimize_scalar</span></tt>)</a><ul>
<li><a class="reference internal" href="#unconstrained-minimization-method-brent">Unconstrained minimization (<tt class="docutils literal"><span class="pre">method='brent'</span></tt>)</a></li>
<li><a class="reference internal" href="#bounded-minimization-method-bounded">Bounded minimization (<tt class="docutils literal"><span class="pre">method='bounded'</span></tt>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-minimizers">Custom minimizers</a></li>
<li><a class="reference internal" href="#root-finding">Root finding</a><ul>
<li><a class="reference internal" href="#scalar-functions">Scalar functions</a></li>
<li><a class="reference internal" href="#fixed-point-solving">Fixed-point solving</a></li>
<li><a class="reference internal" href="#sets-of-equations">Sets of equations</a></li>
<li><a class="reference internal" href="#root-finding-for-large-problems">Root finding for large problems</a></li>
<li><a class="reference internal" href="#still-too-slow-preconditioning">Still too slow? Preconditioning.</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="integrate.html"
                        title="previous chapter">Integration (<tt class="docutils literal"><span class="pre">scipy.integrate</span></tt>)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="interpolate.html"
                        title="next chapter">Interpolation (<tt class="docutils literal"><span class="pre">scipy.interpolate</span></tt>)</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="optimization-scipy-optimize">
<h1>Optimization (<a class="reference internal" href="../optimize.html#module-scipy.optimize" title="scipy.optimize"><tt class="xref py py-mod docutils literal"><span class="pre">scipy.optimize</span></tt></a>)<a class="headerlink" href="#optimization-scipy-optimize" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="../optimize.html#module-scipy.optimize" title="scipy.optimize"><tt class="xref py py-mod docutils literal"><span class="pre">scipy.optimize</span></tt></a> package provides several commonly used
optimization algorithms. A detailed listing is available:
<a class="reference internal" href="../optimize.html#module-scipy.optimize" title="scipy.optimize"><tt class="xref py py-mod docutils literal"><span class="pre">scipy.optimize</span></tt></a> (can also be found by <tt class="docutils literal"><span class="pre">help(scipy.optimize)</span></tt>).</p>
<p>The module contains:</p>
<ol class="arabic simple">
<li>Unconstrained and constrained minimization of multivariate scalar
functions (<a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a>) using a variety of algorithms (e.g. BFGS,
Nelder-Mead simplex, Newton Conjugate Gradient, COBYLA or SLSQP)</li>
<li>Global (brute-force) optimization routines  (e.g. <a class="reference internal" href="../generated/scipy.optimize.basinhopping.html#scipy.optimize.basinhopping" title="scipy.optimize.basinhopping"><tt class="xref py py-func docutils literal"><span class="pre">basinhopping</span></tt></a>, <a class="reference internal" href="../generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution" title="scipy.optimize.differential_evolution"><tt class="xref py py-func docutils literal"><span class="pre">differential_evolution</span></tt></a>)</li>
<li>Least-squares minimization (<a class="reference internal" href="../generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq" title="scipy.optimize.leastsq"><tt class="xref py py-func docutils literal"><span class="pre">leastsq</span></tt></a>) and curve fitting
(<a class="reference internal" href="../generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit" title="scipy.optimize.curve_fit"><tt class="xref py py-func docutils literal"><span class="pre">curve_fit</span></tt></a>) algorithms</li>
<li>Scalar univariate functions minimizers (<a class="reference internal" href="../generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><tt class="xref py py-func docutils literal"><span class="pre">minimize_scalar</span></tt></a>) and
root finders (<a class="reference internal" href="../generated/scipy.optimize.newton.html#scipy.optimize.newton" title="scipy.optimize.newton"><tt class="xref py py-func docutils literal"><span class="pre">newton</span></tt></a>)</li>
<li>Multivariate equation system solvers (<a class="reference internal" href="../generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><tt class="xref py py-func docutils literal"><span class="pre">root</span></tt></a>) using a variety of
algorithms (e.g. hybrid Powell, Levenberg-Marquardt or large-scale
methods such as Newton-Krylov).</li>
</ol>
<p>Below, several examples demonstrate their basic usage.</p>
<div class="section" id="unconstrained-minimization-of-multivariate-scalar-functions-minimize">
<h2>Unconstrained minimization of multivariate scalar functions (<a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a>)<a class="headerlink" href="#unconstrained-minimization-of-multivariate-scalar-functions-minimize" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a> function provides a common interface to unconstrained
and constrained minimization algorithms for multivariate scalar functions
in <a class="reference internal" href="../optimize.html#module-scipy.optimize" title="scipy.optimize"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.optimize</span></tt></a>. To demonstrate the minimization function consider the
problem of minimizing the Rosenbrock function of <span class="math">\(N\)</span> variables:</p>
<div class="math">
\[ f\left(\mathbf{x}\right)=\sum_{i=1}^{N-1}100\left(x_{i}-x_{i-1}^{2}\right)^{2}+\left(1-x_{i-1}\right)^{2}.\]</div><p>The minimum value of this function is 0 which is achieved when
<span class="math">\(x_{i}=1.\)</span></p>
<p>Note that the Rosenbrock function and its derivatives are included in
<a class="reference internal" href="../optimize.html#module-scipy.optimize" title="scipy.optimize"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.optimize</span></tt></a>. The implementations shown in the following sections
provide examples of how to define an objective function as well as its
jacobian and hessian functions.</p>
<div class="section" id="nelder-mead-simplex-algorithm-method-nelder-mead">
<h3>Nelder-Mead Simplex algorithm (<tt class="docutils literal"><span class="pre">method='Nelder-Mead'</span></tt>)<a class="headerlink" href="#nelder-mead-simplex-algorithm-method-nelder-mead" title="Permalink to this headline">¶</a></h3>
<p>In the example below, the <a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a> routine is used
with the <em>Nelder-Mead</em> simplex algorithm (selected through the <tt class="docutils literal"><span class="pre">method</span></tt>
parameter):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;The Rosenbrock function&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">100.0</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;nelder-mead&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 339</span>
<span class="go">         Function evaluations: 571</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 1.  1.  1.  1.  1.]</span>
</pre></div>
</div>
<p>The simplex algorithm is probably the simplest way to minimize a fairly
well-behaved function. It requires only function evaluations and is a good
choice for simple minimization problems. However, because it does not use
any gradient evaluations, it may take longer to find the minimum.</p>
<p>Another optimization algorithm that needs only function calls to find
the minimum is <em>Powell</em>&#8216;s method available by setting <tt class="docutils literal"><span class="pre">method='powell'</span></tt> in
<a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a>.</p>
</div>
<div class="section" id="broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs">
<h3>Broyden-Fletcher-Goldfarb-Shanno algorithm (<tt class="docutils literal"><span class="pre">method='BFGS'</span></tt>)<a class="headerlink" href="#broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs" title="Permalink to this headline">¶</a></h3>
<p>In order to converge more quickly to the solution, this routine uses
the gradient of the objective function. If the gradient is not given
by the user, then it is estimated using first-differences. The
Broyden-Fletcher-Goldfarb-Shanno (BFGS) method typically requires
fewer function calls than the simplex algorithm even when the gradient
must be estimated.</p>
<p>To demonstrate this algorithm, the Rosenbrock function is again used.
The gradient of the Rosenbrock function is the vector:</p>
<div class="math">
\[ \begin{eqnarray*} \frac{\partial f}{\partial x_{j}} & = & \sum_{i=1}^{N}200\left(x_{i}-x_{i-1}^{2}\right)\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-2\left(1-x_{i-1}\right)\delta_{i-1,j}.\\  & = & 200\left(x_{j}-x_{j-1}^{2}\right)-400x_{j}\left(x_{j+1}-x_{j}^{2}\right)-2\left(1-x_{j}\right).\end{eqnarray*}\]</div><p>This expression is valid for the interior derivatives. Special cases
are</p>
<div class="math">
\[ \begin{eqnarray*} \frac{\partial f}{\partial x_{0}} & = & -400x_{0}\left(x_{1}-x_{0}^{2}\right)-2\left(1-x_{0}\right),\\ \frac{\partial f}{\partial x_{N-1}} & = & 200\left(x_{N-1}-x_{N-2}^{2}\right).\end{eqnarray*}\]</div><p>A Python function which computes this gradient is constructed by the
code-segment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_der</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xm</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">xm_m1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">xm_p1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="n">der</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">der</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="o">*</span><span class="p">(</span><span class="n">xm</span><span class="o">-</span><span class="n">xm_m1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="p">(</span><span class="n">xm_p1</span> <span class="o">-</span> <span class="n">xm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">xm</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xm</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">der</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="n">der</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">der</span>
</pre></div>
</div>
<p>This gradient information is specified in the <a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a> function
through the <tt class="docutils literal"><span class="pre">jac</span></tt> parameter as illustrated below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;BFGS&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 51</span>
<span class="go">         Function evaluations: 63</span>
<span class="go">         Gradient evaluations: 63</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 1.  1.  1.  1.  1.]</span>
</pre></div>
</div>
</div>
<div class="section" id="newton-conjugate-gradient-algorithm-method-newton-cg">
<h3>Newton-Conjugate-Gradient algorithm (<tt class="docutils literal"><span class="pre">method='Newton-CG'</span></tt>)<a class="headerlink" href="#newton-conjugate-gradient-algorithm-method-newton-cg" title="Permalink to this headline">¶</a></h3>
<p>The method which requires the fewest function calls and is therefore often
the fastest method to minimize functions of many variables uses the
Newton-Conjugate Gradient algorithm. This method is a modified Newton&#8217;s
method and uses a conjugate gradient algorithm to (approximately) invert
the local Hessian.  Newton&#8217;s method is based on fitting the function
locally to a quadratic form:</p>
<div class="math">
\[ f\left(\mathbf{x}\right)\approx f\left(\mathbf{x}_{0}\right)+\nabla f\left(\mathbf{x}_{0}\right)\cdot\left(\mathbf{x}-\mathbf{x}_{0}\right)+\frac{1}{2}\left(\mathbf{x}-\mathbf{x}_{0}\right)^{T}\mathbf{H}\left(\mathbf{x}_{0}\right)\left(\mathbf{x}-\mathbf{x}_{0}\right).\]</div><p>where <span class="math">\(\mathbf{H}\left(\mathbf{x}_{0}\right)\)</span> is a matrix of second-derivatives (the Hessian). If the Hessian is
positive definite then the local minimum of this function can be found
by setting the gradient of the quadratic form to zero, resulting in</p>
<div class="math">
\[ \mathbf{x}_{\textrm{opt}}=\mathbf{x}_{0}-\mathbf{H}^{-1}\nabla f.\]</div><p>The inverse of the Hessian is evaluated using the conjugate-gradient
method. An example of employing this method to minimizing the
Rosenbrock function is given below. To take full advantage of the
Newton-CG method, a function which computes the Hessian must be
provided. The Hessian matrix itself does not need to be constructed,
only a vector which is the product of the Hessian with an arbitrary
vector needs to be available to the minimization routine. As a result,
the user can provide either a function to compute the Hessian matrix,
or a function to compute the product of the Hessian with an arbitrary
vector.</p>
<div class="section" id="full-hessian-example">
<h4>Full Hessian example:<a class="headerlink" href="#full-hessian-example" title="Permalink to this headline">¶</a></h4>
<p>The Hessian of the Rosenbrock function is</p>
<div class="math">
\[ \begin{eqnarray*} H_{ij}=\frac{\partial^{2}f}{\partial x_{i}\partial x_{j}} & = & 200\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-400x_{i}\left(\delta_{i+1,j}-2x_{i}\delta_{i,j}\right)-400\delta_{i,j}\left(x_{i+1}-x_{i}^{2}\right)+2\delta_{i,j},\\  & = & \left(202+1200x_{i}^{2}-400x_{i+1}\right)\delta_{i,j}-400x_{i}\delta_{i+1,j}-400x_{i-1}\delta_{i-1,j},\end{eqnarray*}\]</div><p>if <span class="math">\(i,j\in\left[1,N-2\right]\)</span> with <span class="math">\(i,j\in\left[0,N-1\right]\)</span> defining the <span class="math">\(N\times N\)</span> matrix. Other non-zero entries of the matrix are</p>
<div class="math">
\[ \begin{eqnarray*} \frac{\partial^{2}f}{\partial x_{0}^{2}} & = & 1200x_{0}^{2}-400x_{1}+2,\\ \frac{\partial^{2}f}{\partial x_{0}\partial x_{1}}=\frac{\partial^{2}f}{\partial x_{1}\partial x_{0}} & = & -400x_{0},\\ \frac{\partial^{2}f}{\partial x_{N-1}\partial x_{N-2}}=\frac{\partial^{2}f}{\partial x_{N-2}\partial x_{N-1}} & = & -400x_{N-2},\\ \frac{\partial^{2}f}{\partial x_{N-1}^{2}} & = & 200.\end{eqnarray*}\]</div><p>For example, the Hessian when <span class="math">\(N=5\)</span> is</p>
<div class="math">
\[ \mathbf{H}=\left[\begin{array}{ccccc} 1200x_{0}^{2}-400x_{1}+2 & -400x_{0} & 0 & 0 & 0\\ -400x_{0} & 202+1200x_{1}^{2}-400x_{2} & -400x_{1} & 0 & 0\\ 0 & -400x_{1} & 202+1200x_{2}^{2}-400x_{3} & -400x_{2} & 0\\ 0 &  & -400x_{2} & 202+1200x_{3}^{2}-400x_{4} & -400x_{3}\\ 0 & 0 & 0 & -400x_{3} & 200\end{array}\right].\]</div><p>The code which computes this Hessian along with the code to minimize
the function using Newton-CG method is shown in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_hess</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">diagonal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span>
<span class="gp">... </span>    <span class="n">diagonal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>
<span class="gp">... </span>    <span class="n">diagonal</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">202</span> <span class="o">+</span> <span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">H</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;Newton-CG&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">rosen_hess</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 19</span>
<span class="go">         Function evaluations: 22</span>
<span class="go">         Gradient evaluations: 19</span>
<span class="go">         Hessian evaluations: 19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 1.  1.  1.  1.  1.]</span>
</pre></div>
</div>
</div>
<div class="section" id="hessian-product-example">
<h4>Hessian product example:<a class="headerlink" href="#hessian-product-example" title="Permalink to this headline">¶</a></h4>
<p>For larger minimization problems, storing the entire Hessian matrix can
consume considerable time and memory. The Newton-CG algorithm only needs
the product of the Hessian times an arbitrary vector. As a result, the user
can supply code to compute this product rather than the full Hessian by
giving a <tt class="docutils literal"><span class="pre">hess</span></tt> function which take the minimization vector as the first
argument and the arbitrary vector as the second argument (along with extra
arguments passed to the function to be minimized). If possible, using
Newton-CG with the Hessian product option is probably the fastest way to
minimize the function.</p>
<p>In this case, the product of the Rosenbrock Hessian with an arbitrary
vector is not difficult to compute. If <span class="math">\(\mathbf{p}\)</span> is the arbitrary
vector, then <span class="math">\(\mathbf{H}\left(\mathbf{x}\right)\mathbf{p}\)</span> has
elements:</p>
<div class="math">
\[ \mathbf{H}\left(\mathbf{x}\right)\mathbf{p}=\left[\begin{array}{c} \left(1200x_{0}^{2}-400x_{1}+2\right)p_{0}-400x_{0}p_{1}\\ \vdots\\ -400x_{i-1}p_{i-1}+\left(202+1200x_{i}^{2}-400x_{i+1}\right)p_{i}-400x_{i}p_{i+1}\\ \vdots\\ -400x_{N-2}p_{N-2}+200p_{N-1}\end{array}\right].\]</div><p>Code which makes use of this Hessian product to minimize the
Rosenbrock function using <a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a> follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_hess_p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">Hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">Hp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">Hp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">202</span><span class="o">+</span><span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> \
<span class="gp">... </span>               <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="n">Hp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">200</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">Hp</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;Newton-CG&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="n">rosen_hess_p</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 20</span>
<span class="go">         Function evaluations: 23</span>
<span class="go">         Gradient evaluations: 20</span>
<span class="go">         Hessian evaluations: 44</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 1.  1.  1.  1.  1.]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="constrained-minimization-of-multivariate-scalar-functions-minimize">
<span id="tutorial-sqlsp"></span><h2>Constrained minimization of multivariate scalar functions (<a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a>)<a class="headerlink" href="#constrained-minimization-of-multivariate-scalar-functions-minimize" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a> function also provides an interface to several
constrained minimization algorithm. As an example, the Sequential Least
SQuares Programming optimization algorithm (SLSQP) will be considered here.
This algorithm allows to deal with constrained minimization problems of the
form:</p>
<div class="math">
\[  \begin{eqnarray*} \min F(x) \\ \text{subject to } & C_j(X) =  0  ,  &j = 1,...,\text{MEQ}\\
         & C_j(x) \geq 0  ,  &j = \text{MEQ}+1,...,M\\
        &  XL  \leq x \leq XU , &I = 1,...,N. \end{eqnarray*}\]</div><p>As an example, let us consider the problem of maximizing the function:</p>
<div class="math">
\[f(x, y) = 2 x y + 2 x - x^2 - 2 y^2\]</div><p>subject to an equality and an inequality constraints defined as:</p>
<div class="math">
\[\begin{eqnarray*}
  x^3 - y &= 0 \\
  y - 1 &\geq 0
\end{eqnarray*}\]</div><p>The objective function and its derivative are defined as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot; Objective function &quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">sign</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot; Derivative of objective function &quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">dfdx0</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">dfdx1</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">dfdx0</span><span class="p">,</span> <span class="n">dfdx1</span> <span class="p">])</span>
</pre></div>
</div>
<p>Note that since <a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a> only minimizes functions, the <tt class="docutils literal"><span class="pre">sign</span></tt>
parameter is introduced to multiply the objective function (and its
derivative) by -1 in order to perform a maximization.</p>
<p>Then constraints are defined as a sequence of dictionaries, with keys
<tt class="docutils literal"><span class="pre">type</span></tt>, <tt class="docutils literal"><span class="pre">fun</span></tt> and <tt class="docutils literal"><span class="pre">jac</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cons</span> <span class="o">=</span> <span class="p">({</span><span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;eq&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s">&#39;fun&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
<span class="gp">... </span>         <span class="s">&#39;jac&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.0</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;ineq&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s">&#39;fun&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span>
<span class="gp">... </span>         <span class="s">&#39;jac&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])})</span>
</pre></div>
</div>
<p>Now an unconstrained optimization can be performed as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,),</span> <span class="n">jac</span><span class="o">=</span><span class="n">func_deriv</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">method</span><span class="o">=</span><span class="s">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.    (Exit mode 0)</span>
<span class="go">            Current function value: -2.0</span>
<span class="go">            Iterations: 4</span>
<span class="go">            Function evaluations: 5</span>
<span class="go">            Gradient evaluations: 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 2.  1.]</span>
</pre></div>
</div>
<p>and a constrained optimization as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,),</span> <span class="n">jac</span><span class="o">=</span><span class="n">func_deriv</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.    (Exit mode 0)</span>
<span class="go">            Current function value: -1.00000018311</span>
<span class="go">            Iterations: 9</span>
<span class="go">            Function evaluations: 14</span>
<span class="go">            Gradient evaluations: 9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 1.00000009  1.        ]</span>
</pre></div>
</div>
</div>
<div class="section" id="least-square-fitting-leastsq">
<h2>Least-square fitting (<a class="reference internal" href="../generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq" title="scipy.optimize.leastsq"><tt class="xref py py-func docutils literal"><span class="pre">leastsq</span></tt></a>)<a class="headerlink" href="#least-square-fitting-leastsq" title="Permalink to this headline">¶</a></h2>
<p>All of the previously-explained minimization procedures can be used to
solve a least-squares problem provided the appropriate objective
function is constructed. For example, suppose it is desired to fit a
set of data <span class="math">\(\left\{\mathbf{x}_{i}, \mathbf{y}_{i}\right\}\)</span>
to a known model,
<span class="math">\(\mathbf{y}=\mathbf{f}\left(\mathbf{x},\mathbf{p}\right)\)</span>
where <span class="math">\(\mathbf{p}\)</span> is a vector of parameters for the model that
need to be found. A common method for determining which parameter
vector gives the best fit to the data is to minimize the sum of squares
of the residuals. The residual is usually defined for each observed
data-point as</p>
<div class="math">
\[ e_{i}\left(\mathbf{p},\mathbf{y}_{i},\mathbf{x}_{i}\right)=\left\Vert \mathbf{y}_{i}-\mathbf{f}\left(\mathbf{x}_{i},\mathbf{p}\right)\right\Vert\]</div><p>An objective function to pass to any of the previous minization
algorithms to obtain a least-squares fit is.</p>
<div class="math">
\[ J\left(\mathbf{p}\right)=\sum_{i=0}^{N-1}e_{i}^{2}\left(\mathbf{p}\right).\]</div><p>The <a class="reference internal" href="../generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq" title="scipy.optimize.leastsq"><tt class="xref py py-obj docutils literal"><span class="pre">leastsq</span></tt></a> algorithm performs this squaring and summing of the
residuals automatically. It takes as an input argument the vector
function <span class="math">\(\mathbf{e}\left(\mathbf{p}\right)\)</span> and returns the
value of <span class="math">\(\mathbf{p}\)</span> which minimizes
<span class="math">\(J\left(\mathbf{p}\right)=\mathbf{e}^{T}\mathbf{e}\)</span>
directly. The user is also encouraged to provide the Jacobian matrix
of the function (with derivatives down the columns or across the
rows). If the Jacobian is not provided, it is estimated.</p>
<p>An example should clarify the usage. Suppose it is believed some
measured data follow a sinusoidal pattern</p>
<div class="math">
\[ y_{i}=A\sin\left(2\pi kx_{i}+\theta\right)\]</div><p>where the parameters <span class="math">\(A,\)</span> <span class="math">\(k\)</span> , and <span class="math">\(\theta\)</span> are unknown. The residual vector is</p>
<div class="math">
\[ e_{i}=\left|y_{i}-A\sin\left(2\pi kx_{i}+\theta\right)\right|.\]</div><p>By defining a function to compute the residuals and (selecting an
appropriate starting position), the least-squares fit routine can be
used to find the best-fit parameters <span class="math">\(\hat{A},\,\hat{k},\,\hat{\theta}\)</span>.
This is shown in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arange</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">6e-2</span><span class="p">,</span> <span class="mf">6e-2</span> <span class="o">/</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3e-2</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_meas</span> <span class="o">=</span> <span class="n">y_true</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">p</span>
<span class="gp">... </span>    <span class="n">err</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">A</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">theta</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">err</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">peval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">2.3e-2</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">p0</span><span class="p">))</span>
<span class="go">[  8.      43.4783   1.0472]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">leastsq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plsq</span> <span class="o">=</span> <span class="n">leastsq</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">y_meas</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">plsq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 10.9437  33.3605   0.5834]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">theta</span><span class="p">]))</span>
<span class="go">[ 10.      33.3333   0.5236]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">peval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">plsq</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">x</span><span class="p">,</span><span class="n">y_meas</span><span class="p">,</span><span class="s">&#39;o&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y_true</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Least-squares fit to noisy data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;Fit&#39;</span><span class="p">,</span> <span class="s">&#39;Noisy&#39;</span><span class="p">,</span> <span class="s">&#39;True&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../tutorial/optimize-1.py">Source code</a>)</p>
<div class="figure">
<img alt="../_images/optimize-1.png" src="../_images/optimize-1.png" />
</div>
</div>
<div class="section" id="univariate-function-minimizers-minimize-scalar">
<h2>Univariate function minimizers (<a class="reference internal" href="../generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><tt class="xref py py-func docutils literal"><span class="pre">minimize_scalar</span></tt></a>)<a class="headerlink" href="#univariate-function-minimizers-minimize-scalar" title="Permalink to this headline">¶</a></h2>
<p>Often only the minimum of an univariate function (i.e. a function that
takes a scalar as input) is needed. In these circumstances, other
optimization techniques have been developed that can work faster. These are
accessible from the <a class="reference internal" href="../generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><tt class="xref py py-func docutils literal"><span class="pre">minimize_scalar</span></tt></a> function which proposes several
algorithms.</p>
<div class="section" id="unconstrained-minimization-method-brent">
<h3>Unconstrained minimization (<tt class="docutils literal"><span class="pre">method='brent'</span></tt>)<a class="headerlink" href="#unconstrained-minimization-method-brent" title="Permalink to this headline">¶</a></h3>
<p>There are actually two methods that can be used to minimize an univariate
function: <a class="reference internal" href="../generated/scipy.optimize.brent.html#scipy.optimize.brent" title="scipy.optimize.brent"><tt class="xref py py-obj docutils literal"><span class="pre">brent</span></tt></a> and <a class="reference internal" href="../generated/scipy.optimize.golden.html#scipy.optimize.golden" title="scipy.optimize.golden"><tt class="xref py py-obj docutils literal"><span class="pre">golden</span></tt></a>, but <a class="reference internal" href="../generated/scipy.optimize.golden.html#scipy.optimize.golden" title="scipy.optimize.golden"><tt class="xref py py-obj docutils literal"><span class="pre">golden</span></tt></a> is included only for academic
purposes and should rarely be used. These can be respectively selected
through the <em class="xref py py-obj">method</em> parameter in <a class="reference internal" href="../generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><tt class="xref py py-func docutils literal"><span class="pre">minimize_scalar</span></tt></a>. The <a class="reference internal" href="../generated/scipy.optimize.brent.html#scipy.optimize.brent" title="scipy.optimize.brent"><tt class="xref py py-obj docutils literal"><span class="pre">brent</span></tt></a>
method uses Brent&#8217;s algorithm for locating a minimum. Optimally a bracket
(the <em class="xref py py-obj">bs</em> parameter) should be given which contains the minimum desired. A
bracket is a triple <span class="math">\(\left( a, b, c \right)\)</span> such that <span class="math">\(f
\left( a \right) &gt; f \left( b \right) &lt; f \left( c \right)\)</span> and <span class="math">\(a &lt;
b &lt; c\)</span> . If this is not given, then alternatively two starting points can
be chosen and a bracket will be found from these points using a simple
marching algorithm. If these two starting points are not provided <em class="xref py py-obj">0</em> and
<em class="xref py py-obj">1</em> will be used (this may not be the right choice for your function and
result in an unexpected minimum being returned).</p>
<p>Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize_scalar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;brent&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</div>
<div class="section" id="bounded-minimization-method-bounded">
<h3>Bounded minimization (<tt class="docutils literal"><span class="pre">method='bounded'</span></tt>)<a class="headerlink" href="#bounded-minimization-method-bounded" title="Permalink to this headline">¶</a></h3>
<p>Very often, there are constraints that can be placed on the solution space
before minimization occurs. The <em class="xref py py-obj">bounded</em> method in <a class="reference internal" href="../generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><tt class="xref py py-func docutils literal"><span class="pre">minimize_scalar</span></tt></a>
is an example of a constrained minimization procedure that provides a
rudimentary interval constraint for scalar functions. The interval
constraint allows the minimization to occur only between two fixed
endpoints, specified using the mandatory <em class="xref py py-obj">bs</em> parameter.</p>
<p>For example, to find the minimum of <span class="math">\(J_{1}\left( x \right)\)</span> near
<span class="math">\(x=5\)</span> , <a class="reference internal" href="../generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><tt class="xref py py-func docutils literal"><span class="pre">minimize_scalar</span></tt></a> can be called using the interval
<span class="math">\(\left[ 4, 7 \right]\)</span> as a constraint. The result is
<span class="math">\(x_{\textrm{min}}=5.3314\)</span> :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">j1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;bounded&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">5.33144184241</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="custom-minimizers">
<h2>Custom minimizers<a class="headerlink" href="#custom-minimizers" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, it may be useful to use a custom method as a (multivariate
or univariate) minimizer, for example when using some library wrappers
of <a class="reference internal" href="../generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><tt class="xref py py-func docutils literal"><span class="pre">minimize</span></tt></a> (e.g. <a class="reference internal" href="../generated/scipy.optimize.basinhopping.html#scipy.optimize.basinhopping" title="scipy.optimize.basinhopping"><tt class="xref py py-func docutils literal"><span class="pre">basinhopping</span></tt></a>).</p>
<p>We can achieve that by, instead of passing a method name, we pass
a callable (either a function or an object implementing a <em class="xref py py-obj">__call__</em>
method) as the <em class="xref py py-obj">method</em> parameter.</p>
<p>Let us consider an (admittedly rather virtual) need to use a trivial
custom multivariate minimization method that will just search the
neighborhood in each dimension independently with a fixed step size:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">custmin</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">maxfev</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">bestx</span> <span class="o">=</span> <span class="n">x0</span>
<span class="gp">... </span>    <span class="n">besty</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">funcalls</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">improved</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">improved</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop</span> <span class="ow">and</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">improved</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">... </span>        <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x0</span><span class="p">)):</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">bestx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">bestx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">stepsize</span><span class="p">]:</span>
<span class="gp">... </span>                <span class="n">testx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>                <span class="n">testx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
<span class="gp">... </span>                <span class="n">testy</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">testx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>                <span class="n">funcalls</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>                <span class="k">if</span> <span class="n">testy</span> <span class="o">&lt;</span> <span class="n">besty</span><span class="p">:</span>
<span class="gp">... </span>                    <span class="n">besty</span> <span class="o">=</span> <span class="n">testy</span>
<span class="gp">... </span>                    <span class="n">bestx</span> <span class="o">=</span> <span class="n">testx</span>
<span class="gp">... </span>                    <span class="n">improved</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">callback</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">maxfev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">funcalls</span> <span class="o">&gt;=</span> <span class="n">maxfev</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">... </span>                <span class="k">break</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">OptimizeResult</span><span class="p">(</span><span class="n">fun</span><span class="o">=</span><span class="n">besty</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">bestx</span><span class="p">,</span> <span class="n">nit</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">nfev</span><span class="o">=</span><span class="n">funcalls</span><span class="p">,</span> <span class="n">success</span><span class="o">=</span><span class="p">(</span><span class="n">niter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.35</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">custmin</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="mf">0.05</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">[ 1.  1.  1.  1.  1.]</span>
</pre></div>
</div>
<p>This will work just as well in case of univariate optimization:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">custmin</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">maxfev</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">bestx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bracket</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bracket</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="gp">... </span>    <span class="n">besty</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">funcalls</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">improved</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">improved</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop</span> <span class="ow">and</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">improved</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">... </span>        <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">testx</span> <span class="ow">in</span> <span class="p">[</span><span class="n">bestx</span> <span class="o">-</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">bestx</span> <span class="o">+</span> <span class="n">stepsize</span><span class="p">]:</span>
<span class="gp">... </span>            <span class="n">testy</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">testx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>            <span class="n">funcalls</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">testy</span> <span class="o">&lt;</span> <span class="n">besty</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">besty</span> <span class="o">=</span> <span class="n">testy</span>
<span class="gp">... </span>                <span class="n">bestx</span> <span class="o">=</span> <span class="n">testx</span>
<span class="gp">... </span>                <span class="n">improved</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">callback</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">maxfev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">funcalls</span> <span class="o">&gt;=</span> <span class="n">maxfev</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">... </span>            <span class="k">break</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">OptimizeResult</span><span class="p">(</span><span class="n">fun</span><span class="o">=</span><span class="n">besty</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">bestx</span><span class="p">,</span> <span class="n">nit</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">nfev</span><span class="o">=</span><span class="n">funcalls</span><span class="p">,</span> <span class="n">success</span><span class="o">=</span><span class="p">(</span><span class="n">niter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">3.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">custmin</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">stepsize</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">-2.0</span>
</pre></div>
</div>
</div>
<div class="section" id="root-finding">
<h2>Root finding<a class="headerlink" href="#root-finding" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scalar-functions">
<h3>Scalar functions<a class="headerlink" href="#scalar-functions" title="Permalink to this headline">¶</a></h3>
<p>If one has a single-variable equation, there are four different root
finding algorithms that can be tried. Each of these algorithms requires the
endpoints of an interval in which a root is expected (because the function
changes signs). In general <a class="reference internal" href="../generated/scipy.optimize.brentq.html#scipy.optimize.brentq" title="scipy.optimize.brentq"><tt class="xref py py-obj docutils literal"><span class="pre">brentq</span></tt></a> is the best choice, but the other
methods may be useful in certain circumstances or for academic purposes.</p>
</div>
<div class="section" id="fixed-point-solving">
<h3>Fixed-point solving<a class="headerlink" href="#fixed-point-solving" title="Permalink to this headline">¶</a></h3>
<p>A problem closely related to finding the zeros of a function is the
problem of finding a fixed-point of a function. A fixed point of a
function is the point at which evaluation of the function returns the
point: <span class="math">\(g\left(x\right)=x.\)</span> Clearly the fixed point of <span class="math">\(g\)</span>
is the root of <span class="math">\(f\left(x\right)=g\left(x\right)-x.\)</span>
Equivalently, the root of <span class="math">\(f\)</span> is the fixed_point of
<span class="math">\(g\left(x\right)=f\left(x\right)+x.\)</span> The routine
<a class="reference internal" href="../generated/scipy.optimize.fixed_point.html#scipy.optimize.fixed_point" title="scipy.optimize.fixed_point"><tt class="xref py py-obj docutils literal"><span class="pre">fixed_point</span></tt></a> provides a simple iterative method using Aitkens
sequence acceleration to estimate the fixed point of <span class="math">\(g\)</span> given a
starting point.</p>
</div>
<div class="section" id="sets-of-equations">
<h3>Sets of equations<a class="headerlink" href="#sets-of-equations" title="Permalink to this headline">¶</a></h3>
<p>Finding a root of a set of non-linear equations can be achieve using the
<a class="reference internal" href="../generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><tt class="xref py py-func docutils literal"><span class="pre">root</span></tt></a> function. Several methods are available, amongst which <tt class="docutils literal"><span class="pre">hybr</span></tt>
(the default) and <tt class="docutils literal"><span class="pre">lm</span></tt> which respectively use the hybrid method of Powell
and the Levenberg-Marquardt method from MINPACK.</p>
<p>The following example considers the single-variable transcendental
equation</p>
<div class="math">
\[ x+2\cos\left(x\right)=0,\]</div><p>a root of which can be found as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([-1.02986653])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span>
<span class="go">array([ -6.66133815e-16])</span>
</pre></div>
</div>
<p>Consider now a set of non-linear equations</p>
<div class="math">
\[ \begin{eqnarray*}
 x_{0}\cos\left(x_{1}\right) & = & 4,\\
 x_{0}x_{1}-x_{1} & = & 5.
 \end{eqnarray*}\]</div><p>We define the objective function so that it also returns the Jacobian and
indicate this by setting the <tt class="docutils literal"><span class="pre">jac</span></tt> parameter to <tt class="docutils literal"><span class="pre">True</span></tt>. Also, the
Levenberg-Marquardt solver is used here.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">func2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">jac</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;lm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 6.50409711,  0.90841421])</span>
</pre></div>
</div>
</div>
<div class="section" id="root-finding-for-large-problems">
<h3>Root finding for large problems<a class="headerlink" href="#root-finding-for-large-problems" title="Permalink to this headline">¶</a></h3>
<p>Methods <tt class="docutils literal"><span class="pre">hybr</span></tt> and <tt class="docutils literal"><span class="pre">lm</span></tt> in <a class="reference internal" href="../generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><tt class="xref py py-func docutils literal"><span class="pre">root</span></tt></a> cannot deal with a very large
number of variables (<em>N</em>), as they need to calculate and invert a dense <em>N
x N</em> Jacobian matrix on every Newton step. This becomes rather inefficient
when <em>N</em> grows.</p>
<p>Consider for instance the following problem: we need to solve the
following integrodifferential equation on the square
<span class="math">\([0,1]\times[0,1]\)</span>:</p>
<div class="math">
\[(\partial_x^2 + \partial_y^2) P + 5 \left(\int_0^1\int_0^1\cosh(P)\,dx\,dy\right)^2 = 0\]</div>
<p>with the boundary condition <span class="math">\(P(x,1) = 1\)</span> on the upper edge and
<span class="math">\(P=0\)</span> elsewhere on the boundary of the square. This can be done
by approximating the continuous function <em>P</em> by its values on a grid,
<span class="math">\(P_{n,m}\approx{}P(n h, m h)\)</span>, with a small grid spacing
<em>h</em>. The derivatives and integrals can then be approximated; for
instance <span class="math">\(\partial_x^2 P(x,y)\approx{}(P(x+h,y) - 2 P(x,y) +
P(x-h,y))/h^2\)</span>. The problem is then equivalent to finding the root of
some function <tt class="docutils literal"><span class="pre">residual(P)</span></tt>, where <tt class="docutils literal"><span class="pre">P</span></tt> is a vector of length
<span class="math">\(N_x N_y\)</span>.</p>
<p>Now, because <span class="math">\(N_x N_y\)</span> can be large, methods <tt class="docutils literal"><span class="pre">hybr</span></tt> or <tt class="docutils literal"><span class="pre">lm</span></tt> in
<a class="reference internal" href="../generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><tt class="xref py py-func docutils literal"><span class="pre">root</span></tt></a> will take a long time to solve this problem. The solution can
however be found using one of the large-scale solvers, for example
<tt class="docutils literal"><span class="pre">krylov</span></tt>, <tt class="docutils literal"><span class="pre">broyden2</span></tt>, or <tt class="docutils literal"><span class="pre">anderson</span></tt>. These use what is known as the
inexact Newton method, which instead of computing the Jacobian matrix
exactly, forms an approximation for it.</p>
<p>The problem we have can now be solved as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">zeros</span>

<span class="c"># parameters</span>
<span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">75</span>
<span class="n">hx</span><span class="p">,</span> <span class="n">hy</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">P_left</span><span class="p">,</span> <span class="n">P_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">P_top</span><span class="p">,</span> <span class="n">P_bottom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
   <span class="n">d2x</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
   <span class="n">d2y</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

   <span class="n">d2x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
   <span class="n">d2x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_left</span><span class="p">)</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
   <span class="n">d2x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_right</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>

   <span class="n">d2y</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
   <span class="n">d2y</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_bottom</span><span class="p">)</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
   <span class="n">d2y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_top</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>

   <span class="k">return</span> <span class="n">d2x</span> <span class="o">+</span> <span class="n">d2y</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>

<span class="c"># solve</span>
<span class="n">guess</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;krylov&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
<span class="c">#sol = root(residual, guess, method=&#39;broyden2&#39;, options={&#39;disp&#39;: True, &#39;max_rank&#39;: 50})</span>
<span class="c">#sol = root(residual, guess, method=&#39;anderson&#39;, options={&#39;disp&#39;: True, &#39;M&#39;: 10})</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Residual: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">abs</span><span class="p">(</span><span class="n">residual</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

<span class="c"># visualize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">nx</span><span class="o">*</span><span class="mi">1j</span><span class="p">),</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">ny</span><span class="o">*</span><span class="mi">1j</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">pcolor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../tutorial/optimize-2.py">Source code</a>)</p>
<div class="figure">
<img alt="../_images/optimize-2.png" src="../_images/optimize-2.png" />
</div>
</div>
<div class="section" id="still-too-slow-preconditioning">
<h3>Still too slow? Preconditioning.<a class="headerlink" href="#still-too-slow-preconditioning" title="Permalink to this headline">¶</a></h3>
<p>When looking for the zero of the functions <span class="math">\(f_i({\bf x}) = 0\)</span>,
<em>i = 1, 2, ..., N</em>, the <tt class="docutils literal"><span class="pre">krylov</span></tt> solver spends most of its
time inverting the Jacobian matrix,</p>
<div class="math">
\[J_{ij} = \frac{\partial f_i}{\partial x_j} .\]</div>
<p>If you have an approximation for the inverse matrix
<span class="math">\(M\approx{}J^{-1}\)</span>, you can use it for <em>preconditioning</em> the
linear inversion problem. The idea is that instead of solving
<span class="math">\(J{\bf s}={\bf y}\)</span> one solves <span class="math">\(MJ{\bf s}=M{\bf y}\)</span>: since
matrix <span class="math">\(MJ\)</span> is &#8220;closer&#8221; to the identity matrix than <span class="math">\(J\)</span>
is, the equation should be easier for the Krylov method to deal with.</p>
<p>The matrix <em>M</em> can be passed to <a class="reference internal" href="../generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><tt class="xref py py-func docutils literal"><span class="pre">root</span></tt></a> with method <tt class="docutils literal"><span class="pre">krylov</span></tt> as an
option <tt class="docutils literal"><span class="pre">options['jac_options']['inner_M']</span></tt>. It can be a (sparse) matrix
or a <a class="reference internal" href="../generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.sparse.linalg.LinearOperator</span></tt></a> instance.</p>
<p>For the problem in the previous section, we note that the function to
solve consists of two parts: the first one is application of the
Laplace operator, <span class="math">\([\partial_x^2 + \partial_y^2] P\)</span>, and the second
is the integral. We can actually easily compute the Jacobian corresponding
to the Laplace operator part: we know that in one dimension</p>
<div class="math">
\[\begin{split}\partial_x^2 \approx \frac{1}{h_x^2} \begin{pmatrix}
-2 &amp; 1 &amp; 0 &amp; 0 \cdots \\
1 &amp; -2 &amp; 1 &amp; 0 \cdots \\
0 &amp; 1 &amp; -2 &amp; 1 \cdots \\
\ldots
\end{pmatrix}
= h_x^{-2} L\end{split}\]</div>
<p>so that the whole 2-D operator is represented by</p>
<div class="math">
\[J_1 = \partial_x^2 + \partial_y^2
\simeq
h_x^{-2} L \otimes I + h_y^{-2} I \otimes L\]</div>
<p>The matrix <span class="math">\(J_2\)</span> of the Jacobian corresponding to the integral
is more difficult to calculate, and since <em>all</em> of it entries are
nonzero, it will be difficult to invert. <span class="math">\(J_1\)</span> on the other hand
is a relatively simple matrix, and can be inverted by
<a class="reference internal" href="../generated/scipy.sparse.linalg.splu.html#scipy.sparse.linalg.splu" title="scipy.sparse.linalg.splu"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.sparse.linalg.splu</span></tt></a> (or the inverse can be approximated by
<a class="reference internal" href="../generated/scipy.sparse.linalg.spilu.html#scipy.sparse.linalg.spilu" title="scipy.sparse.linalg.spilu"><tt class="xref py py-obj docutils literal"><span class="pre">scipy.sparse.linalg.spilu</span></tt></a>). So we are content to take
<span class="math">\(M\approx{}J_1^{-1}\)</span> and hope for the best.</p>
<p>In the example below, we use the preconditioner <span class="math">\(M=J_1^{-1}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">spdiags</span><span class="p">,</span> <span class="n">kron</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spilu</span><span class="p">,</span> <span class="n">LinearOperator</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">eye</span>

<span class="c"># parameters</span>
<span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">75</span>
<span class="n">hx</span><span class="p">,</span> <span class="n">hy</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">P_left</span><span class="p">,</span> <span class="n">P_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">P_top</span><span class="p">,</span> <span class="n">P_bottom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">get_preconditioner</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute the preconditioner M&quot;&quot;&quot;</span>
    <span class="n">diags_x</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>
    <span class="n">diags_x</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
    <span class="n">diags_x</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
    <span class="n">diags_x</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
    <span class="n">Lx</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">diags_x</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">nx</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>

    <span class="n">diags_y</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
    <span class="n">diags_y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
    <span class="n">diags_y</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
    <span class="n">diags_y</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">diags_y</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>

    <span class="n">J1</span> <span class="o">=</span> <span class="n">kron</span><span class="p">(</span><span class="n">Lx</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="n">ny</span><span class="p">))</span> <span class="o">+</span> <span class="n">kron</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">Ly</span><span class="p">)</span>

    <span class="c"># Now we have the matrix `J_1`. We need to find its inverse `M` --</span>
    <span class="c"># however, since an approximate inverse is enough, we can use</span>
    <span class="c"># the *incomplete LU* decomposition</span>

    <span class="n">J1_ilu</span> <span class="o">=</span> <span class="n">spilu</span><span class="p">(</span><span class="n">J1</span><span class="p">)</span>

    <span class="c"># This returns an object with a method .solve() that evaluates</span>
    <span class="c"># the corresponding matrix-vector product. We need to wrap it into</span>
    <span class="c"># a LinearOperator before it can be passed to the Krylov methods:</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">),</span> <span class="n">matvec</span><span class="o">=</span><span class="n">J1_ilu</span><span class="o">.</span><span class="n">solve</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">preconditioning</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the solution&quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
        <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">d2x</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="n">d2y</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

        <span class="n">d2x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
        <span class="n">d2x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_left</span><span class="p">)</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
        <span class="n">d2x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_right</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>

        <span class="n">d2y</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
        <span class="n">d2y</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_bottom</span><span class="p">)</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
        <span class="n">d2y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_top</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>

        <span class="k">return</span> <span class="n">d2x</span> <span class="o">+</span> <span class="n">d2y</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>

    <span class="c"># preconditioner</span>
    <span class="k">if</span> <span class="n">preconditioning</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">get_preconditioner</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># solve</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;krylov&#39;</span><span class="p">,</span>
               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;disp&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                        <span class="s">&#39;jac_options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;inner_M&#39;</span><span class="p">:</span> <span class="n">M</span><span class="p">}})</span>
    <span class="k">print</span> <span class="s">&#39;Residual&#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">residual</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;Evaluations&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">preconditioning</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># visualize</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">nx</span><span class="o">*</span><span class="mi">1j</span><span class="p">),</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">ny</span><span class="o">*</span><span class="mi">1j</span><span class="p">)]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pcolor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Resulting run, first without preconditioning:</p>
<div class="highlight-python"><div class="highlight"><pre>0:  |F(x)| = 803.614; step 1; tol 0.000257947
1:  |F(x)| = 345.912; step 1; tol 0.166755
2:  |F(x)| = 139.159; step 1; tol 0.145657
3:  |F(x)| = 27.3682; step 1; tol 0.0348109
4:  |F(x)| = 1.03303; step 1; tol 0.00128227
5:  |F(x)| = 0.0406634; step 1; tol 0.00139451
6:  |F(x)| = 0.00344341; step 1; tol 0.00645373
7:  |F(x)| = 0.000153671; step 1; tol 0.00179246
8:  |F(x)| = 6.7424e-06; step 1; tol 0.00173256
Residual 3.57078908664e-07
Evaluations 317
</pre></div>
</div>
<p>and then with preconditioning:</p>
<div class="highlight-python"><div class="highlight"><pre>0:  |F(x)| = 136.993; step 1; tol 7.49599e-06
1:  |F(x)| = 4.80983; step 1; tol 0.00110945
2:  |F(x)| = 0.195942; step 1; tol 0.00149362
3:  |F(x)| = 0.000563597; step 1; tol 7.44604e-06
4:  |F(x)| = 1.00698e-09; step 1; tol 2.87308e-12
Residual 9.29603061195e-11
Evaluations 77
</pre></div>
</div>
<p>Using a preconditioner reduced the number of evaluations of the
<tt class="docutils literal"><span class="pre">residual</span></tt> function by a factor of <em>4</em>. For problems where the
residual is expensive to compute, good preconditioning can be crucial
&#8212; it can even decide whether the problem is solvable in practice or
not.</p>
<p>Preconditioning is an art, science, and industry. Here, we were lucky
in making a simple choice that worked reasonably well, but there is a
lot more depth to this topic than is shown here.</p>
<p class="rubric">References</p>
<p>Some further reading and related software:</p>
<table class="docutils citation" frame="void" id="kk" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[KK]</td><td>D.A. Knoll and D.E. Keyes, &#8220;Jacobian-free Newton-Krylov methods&#8221;,
J. Comp. Phys. 193, 357 (2003).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[PP]</td><td>PETSc <a class="reference external" href="http://www.mcs.anl.gov/petsc/">http://www.mcs.anl.gov/petsc/</a> and its Python bindings
<a class="reference external" href="http://code.google.com/p/petsc4py/">http://code.google.com/p/petsc4py/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="amg" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[AMG]</td><td>PyAMG (algebraic multigrid preconditioners/solvers)
<a class="reference external" href="http://code.google.com/p/pyamg/">http://code.google.com/p/pyamg/</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2014, The Scipy community.
      </li>
      <li>
      Last updated on Jul 24, 2015.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>