<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>perlretut</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta http-equiv="Content-Language" content="en-gb">
  <link rel="search" type="application/opensearchdescription+xml" title="Search perldoc.perl.org" href="/static/search.xml"/>
  <link href="static/css-20100830.css" rel="stylesheet" rev="stylesheet" type="text/css" media="screen">
  <link href="static/exploreperl.css" rel="stylesheet" rev="stylesheet" type="text/css">
</head>

<body onLoad="perldoc.startup();" onPageShow="if (event.persisted) perldoc.startup();">
    <div id="page">
      
      <div id="header">
	<div id="homepage_link">
	  <a href="index.html"></a>
	</div>
	<div id="strapline">
	  Perl Programming Documentation
	</div>
	<div id="download_link" class="download">
	  <a href="http://www.perl.org/get.html">Download Perl</a>
	</div>
	<div id="explore_link" class="download">
	  <a id="explore_anchor" href="#">Explore</a>
	</div>
      </div>
      
      <div id="body">
        <div id="left_column">
          <div class="side_group">
            
	    <div class="side_panel doc_panel">
              <p>Manual</p>
              <ul>
                <li><a href="index-overview.html">Overview</a>
                <li><a href="index-tutorials.html">Tutorials</a>
                <li><a href="index-faq.html">FAQs</a>
                <li><a href="index-history.html">History / Changes</a>
                <li><a href="index-licence.html">License</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Reference</p>
              <ul>
                <li><a href="index-language.html">Language</a>
                <li><a href="index-functions.html">Functions</a>
                <li><a href="perlop.html">Operators</a>
                <li><a href="perlvar.html">Special Variables</a>
                <li><a href="index-pragmas.html">Pragmas</a>
                <li><a href="index-utilities.html">Utilities</a>
                <li><a href="index-internals.html">Internals</a>
                <li><a href="index-platforms.html">Platform Specific</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Modules</p>
              <ul>
		<li>
		
                
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		
                  
		
		
                    <a href="index-modules-A.html">A</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-B.html">B</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-C.html">C</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-D.html">D</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-E.html">E</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-F.html">F</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-G.html">G</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-H.html">H</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-I.html">I</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-L.html">L</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-M.html">M</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-N.html">N</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-O.html">O</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-P.html">P</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-S.html">S</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-T.html">T</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-U.html">U</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-X.html">X</a>
                    
                
              </ul>
            </div>
            
	      <div class="side_panel doc_panel">
		<p>Tools</p>
		<ul>
		  <li><a href="preferences.html">Preferences</a>
		</ul>
	      </div>
            
          </div>
        </div>
        <div id="centre_column">
          <div id="content_header">
            <div id="title_bar">
              <div id="page_name">
                <h1>perlretut</h1>
              </div>
              <div id="perl_version">
                Perl 5 version 22.0 documentation
              </div>
              <div class="page_links" id="page_links_top">
                <a href="#" onClick="toolbar.goToTop();return false;">Go to top</a>
		
              </div>
	      <div class="page_links" id="page_links_bottom">
		
                  <a href="#" id="page_index_toggle">Show page index</a> &bull;
		
                <a href="#" id="recent_pages_toggle">Show recent pages</a>		
	      </div>
	      <div id="search_form">
		<form action="search.html" method="GET" id="search">
		  <input type="text" name="q" id="search_box" alt="Search">
		</form>
	      </div>
            </div>
            <div id="breadcrumbs">
                
    <a href="index.html">Home</a> &gt;
    
      
        <a href="index-tutorials.html">Tutorials</a> &gt;
      
    
    perlretut
  

            </div>
          </div>
          <div id="content_body">
	    <!--[if lt IE 7]>
 <div class="noscript">
   <p>
     <strong>It looks like you're using Internet Explorer 6. This is a very old
     browser which does not offer full support for modern websites.</strong>
   </p>
   <p>
     Unfortunately this means that this website will not work on
     your computer.
   </p>
   <p>
     Don't miss out though! To view the site (and get a better experience from
     many other websites), simply upgrade to
     <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet
Explorer 8</a>
     or download an alternative browser such as
     <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>,
     <a href="http://www.apple.com/safari/download/">Safari</a>, or
     <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
   </p>
   <p>
     All of these browsers are free. If you're using a PC at work, you may
     need to contact your IT administrator.
   </p>
 </div>
<![endif]-->
	    <noscript>
	      <div class="noscript">
	      <p>
                <strong>Please note: Many features of this site require JavaScript. You appear to have JavaScript disabled,
	        or are running a non-JavaScript capable web browser.</strong>
	      </p>
	      <p>
		To get the best experience, please enable JavaScript or download a modern web browser such as <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet Explorer 8</a>, <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>, <a href="http://www.apple.com/safari/download/">Safari</a>, or <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
              </p>
	      </div>
	    </noscript>

	    <div id="recent_pages" class="hud_container">
	      <div id="recent_pages_header" class="hud_header">
		<div id="recent_pages_close" class="hud_close"><a href="#" onClick="recentPages.hide();return false;"></a></div>
		<div id="recent_pages_title" class="hud_title"><span class="hud_span_top">Recently read</span></div>
		<div id="recent_pages_topright" class="hud_topright"></div>
	      </div>
	      <div id="recent_pages_content" class="hud_content">
	      </div>
	      <div id="recent_pages_footer" class="hud_footer">
		<div id="recent_pages_bottomleft" class="hud_bottomleft"></div>
		<div id="recent_pages_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
		<div id="recent_pages_resize" class="hud_resize"></div>
	      </div>
	    </div>
  
	    <div id="from_search"></div>
            <h1>perlretut</h1>


  <!--    -->
<ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION</a><li><a href="#Part-1%3a-The-basics">Part 1: The basics</a><ul><li><a href="#Simple-word-matching">Simple word matching</a><li><a href="#Using-character-classes">Using character classes</a><li><a href="#Matching-this-or-that">Matching this or that</a><li><a href="#Grouping-things-and-hierarchical-matching">Grouping things and hierarchical matching</a><li><a href="#Extracting-matches">Extracting matches</a><li><a href="#Backreferences">Backreferences</a><li><a href="#Relative-backreferences">Relative backreferences</a><li><a href="#Named-backreferences">Named backreferences</a><li><a href="#Alternative-capture-group-numbering">Alternative capture group numbering</a><li><a href="#Position-information">Position information</a><li><a href="#Non-capturing-groupings">Non-capturing groupings</a><li><a href="#Matching-repetitions">Matching repetitions</a><li><a href="#Possessive-quantifiers">Possessive quantifiers</a><li><a href="#Building-a-regexp">Building a regexp</a><li><a href="#Using-regular-expressions-in-Perl">Using regular expressions in Perl</a></ul><li><a href="#Part-2%3a-Power-tools">Part 2: Power tools</a><ul><li><a href="#More-on-characters%2c-strings%2c-and-character-classes">More on characters, strings, and character classes</a><li><a href="#Compiling-and-saving-regular-expressions">Compiling and saving regular expressions</a><li><a href="#Composing-regular-expressions-at-runtime">Composing regular expressions at runtime</a><li><a href="#Embedding-comments-and-modifiers-in-a-regular-expression">Embedding comments and modifiers in a regular expression</a><li><a href="#Looking-ahead-and-looking-behind">Looking ahead and looking behind</a><li><a href="#Using-independent-subexpressions-to-prevent-backtracking">Using independent subexpressions to prevent backtracking</a><li><a href="#Conditional-expressions">Conditional expressions</a><li><a href="#Defining-named-patterns">Defining named patterns</a><li><a href="#Recursive-patterns">Recursive patterns</a><li><a href="#A-bit-of-magic%3a-executing-Perl-code-in-a-regular-expression">A bit of magic: executing Perl code in a regular expression</a><li><a href="#Backtracking-control-verbs">Backtracking control verbs</a><li><a href="#Pragmas-and-debugging">Pragmas and debugging</a></ul><li><a href="#BUGS">BUGS</a><li><a href="#SEE-ALSO">SEE ALSO</a><li><a href="#AUTHOR-AND-COPYRIGHT">AUTHOR AND COPYRIGHT</a><ul><li><a href="#Acknowledgments">Acknowledgments</a></ul></ul><a name="NAME"></a><h1>NAME</h1>
<p>perlretut - Perl regular expressions tutorial</p>
<a name="DESCRIPTION"></a><h1>DESCRIPTION</h1>
<p>This page provides a basic tutorial on understanding, creating and
using regular expressions in Perl.  It serves as a complement to the
reference page on regular expressions <a href="perlre.html">perlre</a>.  Regular expressions
are an integral part of the <code class="inline"><a class="l_k" href="functions/m.html">m//</a></code>, <code class="inline"><a class="l_k" href="functions/s.html">s///</a></code>, <code class="inline"><a class="l_k" href="functions/qr.html">qr//</a></code> and <code class="inline"><a class="l_k" href="functions/split.html">split</a></code>
operators and so this tutorial also overlaps with
<a href="perlop.html#Regexp-Quote-Like-Operators">Regexp Quote-Like Operators in perlop</a> and <a href="functions/split.html">split</a>.</p>
<p>Perl is widely renowned for excellence in text processing, and regular
expressions are one of the big factors behind this fame.  Perl regular
expressions display an efficiency and flexibility unknown in most
other computer languages.  Mastering even the basics of regular
expressions will allow you to manipulate text with surprising ease.</p>
<p>What is a regular expression?  A regular expression is simply a string
that describes a pattern.  Patterns are in common use these days;
examples are the patterns typed into a search engine to find web pages
and the patterns used to list files in a directory, e.g., <code class="inline">ls *.txt</code>
or <code class="inline">dir *.*</code>.  In Perl, the patterns described by regular expressions
are used to search strings, extract desired parts of strings, and to
do search and replace operations.</p>
<p>Regular expressions have the undeserved reputation of being abstract
and difficult to understand.  Regular expressions are constructed using
simple concepts like conditionals and loops and are no more difficult
to understand than the corresponding <code class="inline">if</code>
 conditionals and <code class="inline">while</code>

loops in the Perl language itself.  In fact, the main challenge in
learning regular expressions is just getting used to the terse
notation used to express these concepts.</p>
<p>This tutorial flattens the learning curve by discussing regular
expression concepts, along with their notation, one at a time and with
many examples.  The first part of the tutorial will progress from the
simplest word searches to the basic regular expression concepts.  If
you master the first part, you will have all the tools needed to solve
about 98% of your needs.  The second part of the tutorial is for those
comfortable with the basics and hungry for more power tools.  It
discusses the more advanced regular expression operators and
introduces the latest cutting-edge innovations.</p>
<p>A note: to save time, 'regular expression' is often abbreviated as
regexp or regex.  Regexp is a more natural abbreviation than regex, but
is harder to pronounce.  The Perl pod documentation is evenly split on
regexp vs regex; in Perl, there is more than one way to abbreviate it.
We'll use regexp in this tutorial.</p>
<p>New in v5.22, <a href="re.html#'strict'-mode">use re &#39;strict&#39; </a> applies stricter
rules than otherwise when compiling regular expression patterns.  It can
find things that, while legal, may not be what you intended.</p>
<a name="Part-1%3a-The-basics"></a><h1>Part 1: The basics</h1>
<a name="Simple-word-matching"></a><h2>Simple word matching</h2>
<p>The simplest regexp is simply a word, or more generally, a string of
characters.  A regexp consisting of a word matches any string that
contains that word:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/World/</span><span class="sc">;</span>  <span class="c"># matches</span></li></ol></pre><p>What is this Perl statement all about? <code class="inline"><span class="q">&quot;Hello World&quot;</span></code>
 is a simple
double-quoted string.  <code class="inline"><span class="w">World</span></code>
 is the regular expression and the
<code class="inline"><span class="q">//</span></code>
 enclosing <code class="inline"><span class="q">/World/</span></code>
 tells Perl to search a string for a match.
The operator <code class="inline">=~</code>
 associates the string with the regexp match and
produces a true value if the regexp matched, or false if the regexp
did not match.  In our case, <code class="inline"><span class="w">World</span></code>
 matches the second word in
<code class="inline"><span class="q">&quot;Hello World&quot;</span></code>
, so the expression is true.  Expressions like this
are useful in conditionals:</p>
<pre class="verbatim"><ol><li>    if <span class="s">(</span><span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/World/</span><span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It matches\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    else <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It doesn&#39;t match\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>There are useful variations on this theme.  The sense of the match can
be reversed by using the <code class="inline">!~</code>
 operator:</p>
<pre class="verbatim"><ol><li>    if <span class="s">(</span><span class="q">&quot;Hello World&quot;</span> !~ <span class="q">/World/</span><span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It doesn&#39;t match\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    else <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It matches\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>The literal string in the regexp can be replaced by a variable:</p>
<pre class="verbatim"><ol><li>    <span class="i">$greeting</span> = <span class="q">&quot;World&quot;</span><span class="sc">;</span></li><li>    if <span class="s">(</span><span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/$greeting/</span><span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It matches\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    else <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It doesn&#39;t match\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>If you're matching against the special default variable <code class="inline"><span class="i">$_</span></code>
, the
<code class="inline"><span class="i">$_</span> =~</code>
 part can be omitted:</p>
<pre class="verbatim"><ol><li>    <span class="i">$_</span> = <span class="q">&quot;Hello World&quot;</span><span class="sc">;</span></li><li>    if <span class="s">(</span><span class="q">/World/</span><span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It matches\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    else <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It doesn&#39;t match\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>And finally, the <code class="inline"><span class="q">//</span></code>
 default delimiters for a match can be changed
to arbitrary delimiters by putting an <code class="inline"><span class="q">&#39;m&#39;</span></code>
 out front:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">m!World!</span><span class="sc">;</span>   <span class="c"># matches, delimited by &#39;!&#39;</span></li><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">m{World}</span><span class="sc">;</span>   <span class="c"># matches, note the matching &#39;{}&#39;</span></li><li>    <span class="q">&quot;/usr/bin/perl&quot;</span> =~ <span class="q">m&quot;/perl&quot;</span><span class="sc">;</span> <span class="c"># matches after &#39;/usr/bin&#39;,</span></li><li>                                 <span class="c"># &#39;/&#39; becomes an ordinary char</span></li></ol></pre><p><code class="inline"><span class="q">/World/</span></code>
, <code class="inline"><a class="l_k" href="functions/m.html">m!World!</a></code>, and <code class="inline"><a class="l_k" href="functions/m.html">m{World}</a></code> all represent the
same thing.  When, e.g., the quote (<code class="inline">"</code>) is used as a delimiter, the forward
slash <code class="inline"><span class="q">&#39;/&#39;</span></code>
 becomes an ordinary character and can be used in this regexp
without trouble.</p>
<p>Let's consider how different regexps would match <code class="inline"><span class="q">&quot;Hello World&quot;</span></code>
:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/world/</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match</span></li><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/o W/</span><span class="sc">;</span>    <span class="c"># matches</span></li><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/oW/</span><span class="sc">;</span>     <span class="c"># doesn&#39;t match</span></li><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/World /</span><span class="sc">;</span> <span class="c"># doesn&#39;t match</span></li></ol></pre><p>The first regexp <code class="inline"><span class="w">world</span></code>
 doesn't match because regexps are
case-sensitive.  The second regexp matches because the substring
<code class="inline"><span class="q">&#39;o W&#39;</span></code>
 occurs in the string <code class="inline"><span class="q">&quot;Hello World&quot;</span></code>
.  The space
character ' ' is treated like any other character in a regexp and is
needed to match in this case.  The lack of a space character is the
reason the third regexp <code class="inline"><span class="q">&#39;oW&#39;</span></code>
 doesn't match.  The fourth regexp
<code class="inline"><span class="q">&#39;World &#39;</span></code>
 doesn't match because there is a space at the end of the
regexp, but not at the end of the string.  The lesson here is that
regexps must match a part of the string <i>exactly</i> in order for the
statement to be true.</p>
<p>If a regexp matches in more than one place in the string, Perl will
always match at the earliest possible point in the string:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;Hello World&quot;</span> =~ <span class="q">/o/</span><span class="sc">;</span>       <span class="c"># matches &#39;o&#39; in &#39;Hello&#39;</span></li><li>    <span class="q">&quot;That hat is red&quot;</span> =~ <span class="q">/hat/</span><span class="sc">;</span> <span class="c"># matches &#39;hat&#39; in &#39;That&#39;</span></li></ol></pre><p>With respect to character matching, there are a few more points you
need to know about.   First of all, not all characters can be used 'as
is' in a match.  Some characters, called <i>metacharacters</i>, are reserved
for use in regexp notation.  The metacharacters are</p>
<pre class="verbatim"><ol><li>    {}[]()^$.|*+?\</li></ol></pre><p>The significance of each of these will be explained
in the rest of the tutorial, but for now, it is important only to know
that a metacharacter can be matched by putting a backslash before it:</p>
<pre class="verbatim"><ol><li>    "2+2=4" =~ /2+2/;    # doesn't match, + is a metacharacter</li><li>    "2+2=4" =~ /2\+2/;   # matches, \+ is treated like an ordinary +</li><li>    "The interval is [0,1)." =~ /[0,1)./     # is a syntax error!</li><li>    "The interval is [0,1)." =~ /\[0,1\)\./  # matches</li><li>    "#!/usr/bin/perl" =~ /#!\/usr\/bin\/perl/;  # matches</li></ol></pre><p>In the last regexp, the forward slash <code class="inline"><span class="q">&#39;/&#39;</span></code>
 is also backslashed,
because it is used to delimit the regexp.  This can lead to LTS
(leaning toothpick syndrome), however, and it is often more readable
to change delimiters.</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;#!/usr/bin/perl&quot;</span> =~ <span class="q">m!#\!/usr/bin/perl!</span><span class="sc">;</span>  <span class="c"># easier to read</span></li></ol></pre><p>The backslash character <code class="inline">'\'</code> is a metacharacter itself and needs to
be backslashed:</p>
<pre class="verbatim"><ol><li>    <span class="q">&#39;C:\WIN32&#39;</span> =~ <span class="q">/C:\\WIN/</span><span class="sc">;</span>   <span class="c"># matches</span></li></ol></pre><p>In addition to the metacharacters, there are some ASCII characters
which don't have printable character equivalents and are instead
represented by <i>escape sequences</i>.  Common examples are <code class="inline">\<span class="w">t</span></code>
 for a
tab, <code class="inline">\<span class="w">n</span></code>
 for a newline, <code class="inline">\<span class="w">r</span></code>
 for a carriage return and <code class="inline">\<span class="w">a</span></code>
 for a
bell (or alert).  If your string is better thought of as a sequence of arbitrary
bytes, the octal escape sequence, e.g., <code class="inline">\<span class="n">033</span></code>
, or hexadecimal escape
sequence, e.g., <code class="inline">\<span class="w">x1B</span></code>
 may be a more natural representation for your
bytes.  Here are some examples of escapes:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;1000\t2000&quot;</span> =~ <span class="q">m(0\t2)</span>   <span class="c"># matches</span></li><li>    <span class="q">&quot;1000\n2000&quot;</span> =~ <span class="q">/0\n20/</span>   <span class="c"># matches</span></li><li>    <span class="q">&quot;1000\t2000&quot;</span> =~ <span class="q">/\000\t2/</span> <span class="c"># doesn&#39;t match, &quot;0&quot; ne &quot;\000&quot;</span></li><li>    <span class="q">&quot;cat&quot;</span>   =~ <span class="q">/\o{143}\x61\x74/</span> <span class="c"># matches in ASCII, but a weird way</span></li><li>                                 <span class="c"># to spell cat</span></li></ol></pre><p>If you've been around Perl a while, all this talk of escape sequences
may seem familiar.  Similar escape sequences are used in double-quoted
strings and in fact the regexps in Perl are mostly treated as
double-quoted strings.  This means that variables can be used in
regexps as well.  Just like double-quoted strings, the values of the
variables in the regexp will be substituted in before the regexp is
evaluated for matching purposes.  So we have:</p>
<pre class="verbatim"><ol><li>    <span class="i">$foo</span> = <span class="q">&#39;house&#39;</span><span class="sc">;</span></li><li>    <span class="q">&#39;housecat&#39;</span> =~ <span class="q">/$foo/</span><span class="sc">;</span>      <span class="c"># matches</span></li><li>    <span class="q">&#39;cathouse&#39;</span> =~ <span class="q">/cat$foo/</span><span class="sc">;</span>   <span class="c"># matches</span></li><li>    <span class="q">&#39;housecat&#39;</span> =~ <span class="q">/${foo}cat/</span><span class="sc">;</span> <span class="c"># matches</span></li></ol></pre><p>So far, so good.  With the knowledge above you can already perform
searches with just about any literal string regexp you can dream up.
Here is a <i>very simple</i> emulation of the Unix grep program:</p>
<pre class="verbatim"><ol><li>    % cat &gt; simple_grep</li><li>    #!/usr/bin/perl</li><li>    $regexp = shift;</li><li>    while (&lt;&gt;) {</li><li>        print if /$regexp/;</li><li>    }</li><li>    ^D</li><li></li><li>    % chmod +x simple_grep</li><li></li><li>    % simple_grep abba /usr/dict/words</li><li>    Babbage</li><li>    cabbage</li><li>    cabbages</li><li>    sabbath</li><li>    Sabbathize</li><li>    Sabbathizes</li><li>    sabbatical</li><li>    scabbard</li><li>    scabbards</li></ol></pre><p>This program is easy to understand.  <code class="inline">#!/usr/bin/perl</code>
 is the standard
way to invoke a perl program from the shell.
<code class="inline"><span class="i">$regexp</span> = <a class="l_k" href="functions/shift.html">shift</a><span class="sc">;</span></code>
 saves the first command line argument as the
regexp to be used, leaving the rest of the command line arguments to
be treated as files.  <code class="inline">while <span class="s">(</span>&lt;&gt;<span class="s">)</span></code>
 loops over all the lines in
all the files.  For each line, <code class="inline"><a class="l_k" href="functions/print.html">print</a> if <span class="q">/$regexp/</span><span class="sc">;</span></code>
 prints the
line if the regexp matches the line.  In this line, both <code class="inline"><a class="l_k" href="functions/print.html">print</a></code> and
<code class="inline"><span class="q">/$regexp/</span></code>
 use the default variable <code class="inline"><span class="i">$_</span></code>
 implicitly.</p>
<p>With all of the regexps above, if the regexp matched anywhere in the
string, it was considered a match.  Sometimes, however, we'd like to
specify <i>where</i> in the string the regexp should try to match.  To do
this, we would use the <i>anchor</i> metacharacters <code class="inline">^</code> and <code class="inline"><span class="i">$</span></code>
.  The
anchor <code class="inline">^</code> means match at the beginning of the string and the anchor
<code class="inline"><span class="i">$</span></code>
 means match at the end of the string, or before a newline at the
end of the string.  Here is how they are used:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;housekeeper&quot;</span> =~ <span class="q">/keeper/</span><span class="sc">;</span>    <span class="c"># matches</span></li><li>    <span class="q">&quot;housekeeper&quot;</span> =~ <span class="q">/^keeper/</span><span class="sc">;</span>   <span class="c"># doesn&#39;t match</span></li><li>    <span class="q">&quot;housekeeper&quot;</span> =~ <span class="q">/keeper$/</span><span class="sc">;</span>   <span class="c"># matches</span></li><li>    <span class="q">&quot;housekeeper\n&quot;</span> =~ <span class="q">/keeper$/</span><span class="sc">;</span> <span class="c"># matches</span></li></ol></pre><p>The second regexp doesn't match because <code class="inline">^</code> constrains <code class="inline"><span class="w">keeper</span></code>
 to
match only at the beginning of the string, but <code class="inline"><span class="q">&quot;housekeeper&quot;</span></code>
 has
keeper starting in the middle.  The third regexp does match, since the
<code class="inline"><span class="i">$</span></code>
 constrains <code class="inline"><span class="w">keeper</span></code>
 to match only at the end of the string.</p>
<p>When both <code class="inline">^</code> and <code class="inline"><span class="i">$</span></code>
 are used at the same time, the regexp has to
match both the beginning and the end of the string, i.e., the regexp
matches the whole string.  Consider</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;keeper&quot;</span> =~ <span class="q">/^keep$/</span><span class="sc">;</span>      <span class="c"># doesn&#39;t match</span></li><li>    <span class="q">&quot;keeper&quot;</span> =~ <span class="q">/^keeper$/</span><span class="sc">;</span>    <span class="c"># matches</span></li><li>    <span class="q">&quot;&quot;</span>       =~ <span class="q">/^$/</span><span class="sc">;</span>          <span class="c"># ^$ matches an empty string</span></li></ol></pre><p>The first regexp doesn't match because the string has more to it than
<code class="inline"><span class="w">keep</span></code>
.  Since the second regexp is exactly the string, it
matches.  Using both <code class="inline">^</code> and <code class="inline"><span class="i">$</span></code>
 in a regexp forces the complete
string to match, so it gives you complete control over which strings
match and which don't.  Suppose you are looking for a fellow named
bert, off in a string by himself:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;dogbert&quot;</span> =~ <span class="q">/bert/</span><span class="sc">;</span>   <span class="c"># matches, but not what you want</span></li><li></li><li>    <span class="q">&quot;dilbert&quot;</span> =~ <span class="q">/^bert/</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match, but ..</span></li><li>    <span class="q">&quot;bertram&quot;</span> =~ <span class="q">/^bert/</span><span class="sc">;</span>  <span class="c"># matches, so still not good enough</span></li><li></li><li>    <span class="q">&quot;bertram&quot;</span> =~ <span class="q">/^bert$/</span><span class="sc">;</span> <span class="c"># doesn&#39;t match, good</span></li><li>    <span class="q">&quot;dilbert&quot;</span> =~ <span class="q">/^bert$/</span><span class="sc">;</span> <span class="c"># doesn&#39;t match, good</span></li><li>    <span class="q">&quot;bert&quot;</span>    =~ <span class="q">/^bert$/</span><span class="sc">;</span> <span class="c"># matches, perfect</span></li></ol></pre><p>Of course, in the case of a literal string, one could just as easily
use the string comparison <code class="inline"><span class="i">$string</span> eq <span class="q">&#39;bert&#39;</span></code>
 and it would be
more efficient.   The  <code class="inline">^...$</code> regexp really becomes useful when we
add in the more powerful regexp tools below.</p>
<a name="Using-character-classes"></a><h2>Using character classes</h2>
<p>Although one can already do quite a lot with the literal string
regexps above, we've only scratched the surface of regular expression
technology.  In this and subsequent sections we will introduce regexp
concepts (and associated metacharacter notations) that will allow a
regexp to represent not just a single character sequence, but a <i>whole
class</i> of them.</p>
<p>One such concept is that of a <i>character class</i>.  A character class
allows a set of possible characters, rather than just a single
character, to match at a particular point in a regexp.  You can define
your own custom character classes.  These
are denoted by brackets <code class="inline"><span class="s">[</span>...<span class="s">]</span></code>
, with the set of characters
to be possibly matched inside.  Here are some examples:</p>
<pre class="verbatim"><ol><li>    <span class="q">/cat/</span><span class="sc">;</span>       <span class="c"># matches &#39;cat&#39;</span></li><li>    <span class="q">/[bcr]at/</span><span class="sc">;</span>   <span class="c"># matches &#39;bat, &#39;cat&#39;, or &#39;rat&#39;</span></li><li>    <span class="q">/item[0123456789]/</span><span class="sc">;</span>  <span class="c"># matches &#39;item0&#39; or ... or &#39;item9&#39;</span></li><li>    <span class="q">&quot;abc&quot;</span> =~ <span class="q">/[cab]/</span><span class="sc">;</span>    <span class="c"># matches &#39;a&#39;</span></li></ol></pre><p>In the last statement, even though <code class="inline"><span class="q">&#39;c&#39;</span></code>
 is the first character in
the class, <code class="inline"><span class="q">&#39;a&#39;</span></code>
 matches because the first character position in the
string is the earliest point at which the regexp can match.</p>
<pre class="verbatim"><ol><li>    <span class="q">/[yY][eE][sS]/</span><span class="sc">;</span>      <span class="c"># match &#39;yes&#39; in a case-insensitive way</span></li><li>                         <span class="c"># &#39;yes&#39;, &#39;Yes&#39;, &#39;YES&#39;, etc.</span></li></ol></pre><p>This regexp displays a common task: perform a case-insensitive
match.  Perl provides a way of avoiding all those brackets by simply
appending an <code class="inline"><span class="q">&#39;i&#39;</span></code>
 to the end of the match.  Then <code class="inline"><span class="q">/[yY][eE][sS]/</span><span class="sc">;</span></code>

can be rewritten as <code class="inline"><span class="q">/yes/i</span><span class="sc">;</span></code>
.  The <code class="inline"><span class="q">&#39;i&#39;</span></code>
 stands for
case-insensitive and is an example of a <i>modifier</i> of the matching
operation.  We will meet other modifiers later in the tutorial.</p>
<p>We saw in the section above that there were ordinary characters, which
represented themselves, and special characters, which needed a
backslash <code class="inline">\</code>
 to represent themselves.  The same is true in a
character class, but the sets of ordinary and special characters
inside a character class are different than those outside a character
class.  The special characters for a character class are <code class="inline">-]\^$</code> (and
the pattern delimiter, whatever it is).
<code class="inline">]</code> is special because it denotes the end of a character class.  <code class="inline"><span class="i">$</span></code>
 is
special because it denotes a scalar variable.  <code class="inline">\</code>
 is special because
it is used in escape sequences, just like above.  Here is how the
special characters <code class="inline">]$\</code> are handled:</p>
<pre class="verbatim"><ol><li>   <span class="q">/[\]c]def/</span><span class="sc">;</span> <span class="c"># matches &#39;]def&#39; or &#39;cdef&#39;</span></li><li>   <span class="i">$x</span> = <span class="q">&#39;bcr&#39;</span><span class="sc">;</span></li><li>   <span class="q">/[$x]at/</span><span class="sc">;</span>   <span class="c"># matches &#39;bat&#39;, &#39;cat&#39;, or &#39;rat&#39;</span></li><li>   <span class="q">/[\$x]at/</span><span class="sc">;</span>  <span class="c"># matches &#39;$at&#39; or &#39;xat&#39;</span></li><li>   <span class="q">/[\\$x]at/</span><span class="sc">;</span> <span class="c"># matches &#39;\at&#39;, &#39;bat, &#39;cat&#39;, or &#39;rat&#39;</span></li></ol></pre><p>The last two are a little tricky.  In <code class="inline"><span class="s">[</span>\<span class="i">$x</span><span class="s">]</span></code>
, the backslash protects
the dollar sign, so the character class has two members <code class="inline"><span class="i">$</span></code>
 and <code class="inline"><span class="w">x</span></code>
.
In <code class="inline"><span class="s">[</span>\\<span class="i">$x</span><span class="s">]</span></code>
, the backslash is protected, so <code class="inline"><span class="i">$x</span></code>
 is treated as a
variable and substituted in double quote fashion.</p>
<p>The special character <code class="inline"><span class="q">&#39;-&#39;</span></code>
 acts as a range operator within character
classes, so that a contiguous set of characters can be written as a
range.  With ranges, the unwieldy <code class="inline">[0123456789]</code> and <code class="inline"><span class="s">[</span><span class="w">abc</span>...<span class="w">xyz</span><span class="s">]</span></code>

become the svelte <code class="inline"><span class="s">[</span><span class="n">0</span>-<span class="n">9</span><span class="s">]</span></code>
 and <code class="inline"><span class="s">[</span><span class="w">a</span>-z<span class="s">]</span></code>
.  Some examples are</p>
<pre class="verbatim"><ol><li>    <span class="q">/item[0-9]/</span><span class="sc">;</span>  <span class="c"># matches 'item0' or ... or 'item9'</span></li><li>    <span class="q">/[0-9bx-z]aa/</span><span class="sc">;</span>  <span class="c"># matches '0aa', ..., '9aa',</span></li><li>                    <span class="c"># 'baa', 'xaa', 'yaa', or 'zaa'</span></li><li>    <span class="q">/[0-9a-fA-F]/</span><span class="sc">;</span>  <span class="c"># matches a hexadecimal digit</span></li><li>    <span class="q">/[0-9a-zA-Z_]/</span><span class="sc">;</span> <span class="c"># matches a &quot;word&quot; character,</span></li><li>                    <span class="c"># like those in a Perl variable name</span></li></ol></pre><p>If <code class="inline"><span class="q">&#39;-&#39;</span></code>
 is the first or last character in a character class, it is
treated as an ordinary character; <code class="inline"><span class="s">[</span>-<span class="w">ab</span><span class="s">]</span></code>
, <code class="inline"><span class="s">[</span><span class="w">ab</span>-<span class="s">]</span></code>
 and <code class="inline"><span class="s">[</span><span class="w">a</span>\-b<span class="s">]</span></code>
 are
all equivalent.</p>
<p>The special character <code class="inline">^</code> in the first position of a character class
denotes a <i>negated character class</i>, which matches any character but
those in the brackets.  Both <code class="inline"><span class="s">[</span>...<span class="s">]</span></code>
 and <code class="inline">[^...]</code> must match a
character, or the match fails.  Then</p>
<pre class="verbatim"><ol><li>    <span class="q">/[^a]at/</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match &#39;aat&#39; or &#39;at&#39;, but matches</span></li><li>               <span class="c"># all other &#39;bat&#39;, &#39;cat, &#39;0at&#39;, &#39;%at&#39;, etc.</span></li><li>    <span class="q">/[^0-9]/</span><span class="sc">;</span>  <span class="c"># matches a non-numeric character</span></li><li>    <span class="q">/[a^]at/</span><span class="sc">;</span>  <span class="c"># matches &#39;aat&#39; or &#39;^at&#39;; here &#39;^&#39; is ordinary</span></li></ol></pre><p>Now, even <code class="inline"><span class="s">[</span><span class="n">0</span>-<span class="n">9</span><span class="s">]</span></code>
 can be a bother to write multiple times, so in the
interest of saving keystrokes and making regexps more readable, Perl
has several abbreviations for common character classes, as shown below.
Since the introduction of Unicode, unless the <code class="inline"><span class="q">//</span><span class="w">a</span></code>
 modifier is in
effect, these character classes match more than just a few characters in
the ASCII range.</p>
<ul>
<li>
<p>\d matches a digit, not just [0-9] but also digits from non-roman scripts</p>
</li>
<li>
<p>\s matches a whitespace character, the set [\ \t\r\n\f] and others</p>
</li>
<li>
<p>\w matches a word character (alphanumeric or _), not just [0-9a-zA-Z_]
but also digits and characters from non-roman scripts</p>
</li>
<li>
<p>\D is a negated \d; it represents any other character than a digit, or [^\d]</p>
</li>
<li>
<p>\S is a negated \s; it represents any non-whitespace character [^\s]</p>
</li>
<li>
<p>\W is a negated \w; it represents any non-word character [^\w]</p>
</li>
<li>
<p>The period '.' matches any character but "\n" (unless the modifier <code class="inline"><span class="q">//s</span></code>
 is
in effect, as explained below).</p>
</li>
<li>
<p>\N, like the period, matches any character but "\n", but it does so
regardless of whether the modifier <code class="inline"><span class="q">//s</span></code>
 is in effect.</p>
</li>
</ul>
<p>The <code class="inline"><span class="q">//</span><span class="w">a</span></code>
 modifier, available starting in Perl 5.14,  is used to
restrict the matches of \d, \s, and \w to just those in the ASCII range.
It is useful to keep your program from being needlessly exposed to full
Unicode (and its accompanying security considerations) when all you want
is to process English-like text.  (The "a" may be doubled, <code class="inline"><span class="q">//</span><span class="w">aa</span></code>
, to
provide even more restrictions, preventing case-insensitive matching of
ASCII with non-ASCII characters; otherwise a Unicode "Kelvin Sign"
would caselessly match a "k" or "K".)</p>
<p>The <code class="inline">\d\s\w\D\S\W</code> abbreviations can be used both inside and outside
of bracketed character classes.  Here are some in use:</p>
<pre class="verbatim"><ol><li>    <span class="q">/\d\d:\d\d:\d\d/</span><span class="sc">;</span> <span class="c"># matches a hh:mm:ss time format</span></li><li>    <span class="q">/[\d\s]/</span><span class="sc">;</span>         <span class="c"># matches any digit or whitespace character</span></li><li>    <span class="q">/\w\W\w/</span><span class="sc">;</span>         <span class="c"># matches a word char, followed by a</span></li><li>                      <span class="c"># non-word char, followed by a word char</span></li><li>    <span class="q">/..rt/</span><span class="sc">;</span>           <span class="c"># matches any two chars, followed by &#39;rt&#39;</span></li><li>    <span class="q">/end\./</span><span class="sc">;</span>          <span class="c"># matches &#39;end.&#39;</span></li><li>    <span class="q">/end[.]/</span><span class="sc">;</span>         <span class="c"># same thing, matches &#39;end.&#39;</span></li></ol></pre><p>Because a period is a metacharacter, it needs to be escaped to match
as an ordinary period. Because, for example, <code class="inline">\<span class="w">d</span></code>
 and <code class="inline">\<span class="w">w</span></code>
 are sets
of characters, it is incorrect to think of <code class="inline">[^\d\w]</code> as <code class="inline"><span class="s">[</span>\<span class="w">D</span>\<span class="w">W</span><span class="s">]</span></code>
; in
fact <code class="inline">[^\d\w]</code> is the same as <code class="inline">[^\w]</code>, which is the same as
<code class="inline"><span class="s">[</span>\<span class="w">W</span><span class="s">]</span></code>
. Think DeMorgan's laws.</p>
<p>In actuality, the period and <code class="inline">\d\s\w\D\S\W</code> abbreviations are
themselves types of character classes, so the ones surrounded by
brackets are just one type of character class.  When we need to make a
distinction, we refer to them as "bracketed character classes."</p>
<p>An anchor useful in basic regexps is the <i>word anchor</i>
<code class="inline">\<span class="w">b</span></code>
.  This matches a boundary between a word character and a non-word
character <code class="inline">\<span class="w">w</span>\<span class="w">W</span></code>
 or <code class="inline">\<span class="w">W</span>\<span class="w">w</span></code>
:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;Housecat catenates house and cat&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/cat/</span><span class="sc">;</span>    <span class="c"># matches cat in &#39;housecat&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\bcat/</span><span class="sc">;</span>  <span class="c"># matches cat in &#39;catenates&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/cat\b/</span><span class="sc">;</span>  <span class="c"># matches cat in &#39;housecat&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\bcat\b/</span><span class="sc">;</span>  <span class="c"># matches &#39;cat&#39; at end of string</span></li></ol></pre><p>Note in the last example, the end of the string is considered a word
boundary.</p>
<p>For natural language processing (so that, for example, apostrophes are
included in words), use instead <code class="inline">\<span class="i">b</span><span class="s">{</span><span class="w">wb</span><span class="s">}</span></code>
</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;don&#39;t&quot;</span> =~ <span class="q">/ .+? \b{wb} /x</span><span class="sc">;</span>  <span class="c"># matches the whole string</span></li></ol></pre><p>You might wonder why <code class="inline"><span class="q">&#39;.&#39;</span></code>
 matches everything but <code class="inline"><span class="q">&quot;\n&quot;</span></code>
 - why not
every character? The reason is that often one is matching against
lines and would like to ignore the newline characters.  For instance,
while the string <code class="inline"><span class="q">&quot;\n&quot;</span></code>
 represents one line, we would like to think
of it as empty.  Then</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;&quot;</span>   =~ <span class="q">/^$/</span><span class="sc">;</span>    <span class="c"># matches</span></li><li>    <span class="q">&quot;\n&quot;</span> =~ <span class="q">/^$/</span><span class="sc">;</span>    <span class="c"># matches, $ anchors before &quot;\n&quot;</span></li><li></li><li>    <span class="q">&quot;&quot;</span>   =~ <span class="q">/./</span><span class="sc">;</span>      <span class="c"># doesn&#39;t match; it needs a char</span></li><li>    <span class="q">&quot;&quot;</span>   =~ <span class="q">/^.$/</span><span class="sc">;</span>    <span class="c"># doesn&#39;t match; it needs a char</span></li><li>    <span class="q">&quot;\n&quot;</span> =~ <span class="q">/^.$/</span><span class="sc">;</span>    <span class="c"># doesn&#39;t match; it needs a char other than &quot;\n&quot;</span></li><li>    <span class="q">&quot;a&quot;</span>  =~ <span class="q">/^.$/</span><span class="sc">;</span>    <span class="c"># matches</span></li><li>    <span class="q">&quot;a\n&quot;</span>  =~ <span class="q">/^.$/</span><span class="sc">;</span>  <span class="c"># matches, $ anchors before &quot;\n&quot;</span></li></ol></pre><p>This behavior is convenient, because we usually want to ignore
newlines when we count and match characters in a line.  Sometimes,
however, we want to keep track of newlines.  We might even want <code class="inline">^</code>
and <code class="inline"><span class="i">$</span></code>
 to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the string.  Perl
allows us to choose between ignoring and paying attention to newlines
by using the <code class="inline"><span class="q">//s</span></code>
 and <code class="inline"><span class="q">//m</span></code>
 modifiers.  <code class="inline"><span class="q">//s</span></code>
 and <code class="inline"><span class="q">//m</span></code>
 stand for
single line and multi-line and they determine whether a string is to
be treated as one continuous string, or as a set of lines.  The two
modifiers affect two aspects of how the regexp is interpreted: 1) how
the <code class="inline"><span class="q">&#39;.&#39;</span></code>
 character class is defined, and 2) where the anchors <code class="inline">^</code>
and <code class="inline"><span class="i">$</span></code>
 are able to match.  Here are the four possible combinations:</p>
<ul>
<li>
<p>no modifiers (//): Default behavior.  <code class="inline"><span class="q">&#39;.&#39;</span></code>
 matches any character
except <code class="inline"><span class="q">&quot;\n&quot;</span></code>
.  <code class="inline">^</code> matches only at the beginning of the string and
<code class="inline"><span class="i">$</span></code>
 matches only at the end or before a newline at the end.</p>
</li>
<li>
<p>s modifier (//s): Treat string as a single long line.  <code class="inline"><span class="q">&#39;.&#39;</span></code>
 matches
any character, even <code class="inline"><span class="q">&quot;\n&quot;</span></code>
.  <code class="inline">^</code> matches only at the beginning of
the string and <code class="inline"><span class="i">$</span></code>
 matches only at the end or before a newline at the
end.</p>
</li>
<li>
<p>m modifier (//m): Treat string as a set of multiple lines.  <code class="inline"><span class="q">&#39;.&#39;</span></code>

matches any character except <code class="inline"><span class="q">&quot;\n&quot;</span></code>
.  <code class="inline">^</code> and <code class="inline"><span class="i">$</span></code>
 are able to match
at the start or end of <i>any</i> line within the string.</p>
</li>
<li>
<p>both s and m modifiers (//sm): Treat string as a single long line, but
detect multiple lines.  <code class="inline"><span class="q">&#39;.&#39;</span></code>
 matches any character, even
<code class="inline"><span class="q">&quot;\n&quot;</span></code>
.  <code class="inline">^</code> and <code class="inline"><span class="i">$</span></code>
, however, are able to match at the start or end
of <i>any</i> line within the string.</p>
</li>
</ul>
<p>Here are examples of <code class="inline"><span class="q">//s</span></code>
 and <code class="inline"><span class="q">//m</span></code>
 in action:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;There once was a girl\nWho programmed in Perl\n&quot;</span><span class="sc">;</span></li><li></li><li>    <span class="i">$x</span> =~ <span class="q">/^Who/</span><span class="sc">;</span>   <span class="c"># doesn&#39;t match, &quot;Who&quot; not at start of string</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^Who/s</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match, &quot;Who&quot; not at start of string</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^Who/m</span><span class="sc">;</span>  <span class="c"># matches, &quot;Who&quot; at start of second line</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^Who/sm</span><span class="sc">;</span> <span class="c"># matches, &quot;Who&quot; at start of second line</span></li><li></li><li>    <span class="i">$x</span> =~ <span class="q">/girl.Who/</span><span class="sc">;</span>   <span class="c"># doesn&#39;t match, &quot;.&quot; doesn&#39;t match &quot;\n&quot;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/girl.Who/s</span><span class="sc">;</span>  <span class="c"># matches, &quot;.&quot; matches &quot;\n&quot;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/girl.Who/m</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match, &quot;.&quot; doesn&#39;t match &quot;\n&quot;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/girl.Who/sm</span><span class="sc">;</span> <span class="c"># matches, &quot;.&quot; matches &quot;\n&quot;</span></li></ol></pre><p>Most of the time, the default behavior is what is wanted, but <code class="inline"><span class="q">//s</span></code>
 and
<code class="inline"><span class="q">//m</span></code>
 are occasionally very useful.  If <code class="inline"><span class="q">//m</span></code>
 is being used, the start
of the string can still be matched with <code class="inline">\<span class="w">A</span></code>
 and the end of the string
can still be matched with the anchors <code class="inline">\<span class="w">Z</span></code>
 (matches both the end and
the newline before, like <code class="inline"><span class="i">$</span></code>
), and <code class="inline">\<span class="w">z</span></code>
 (matches only the end):</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/^Who/m</span><span class="sc">;</span>   <span class="c"># matches, &quot;Who&quot; at start of second line</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\AWho/m</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match, &quot;Who&quot; is not at start of string</span></li><li></li><li>    <span class="i">$x</span> =~ <span class="q">/girl$/m</span><span class="sc">;</span>  <span class="c"># matches, &quot;girl&quot; at end of first line</span></li><li>    <span class="i">$x</span> =~ <span class="q">/girl\Z/m</span><span class="sc">;</span> <span class="c"># doesn&#39;t match, &quot;girl&quot; is not at end of string</span></li><li></li><li>    <span class="i">$x</span> =~ <span class="q">/Perl\Z/m</span><span class="sc">;</span> <span class="c"># matches, &quot;Perl&quot; is at newline before end</span></li><li>    <span class="i">$x</span> =~ <span class="q">/Perl\z/m</span><span class="sc">;</span> <span class="c"># doesn&#39;t match, &quot;Perl&quot; is not at end of string</span></li></ol></pre><p>We now know how to create choices among classes of characters in a
regexp.  What about choices among words or character strings? Such
choices are described in the next section.</p>
<a name="Matching-this-or-that"></a><h2>Matching this or that</h2>
<p>Sometimes we would like our regexp to be able to match different
possible words or character strings.  This is accomplished by using
the <i>alternation</i> metacharacter <code class="inline">|</code>.  To match <code class="inline"><span class="w">dog</span></code>
 or <code class="inline"><span class="w">cat</span></code>
, we
form the regexp <code class="inline"><span class="w">dog</span>|<span class="w">cat</span></code>
.  As before, Perl will try to match the
regexp at the earliest possible point in the string.  At each
character position, Perl will first try to match the first
alternative, <code class="inline"><span class="w">dog</span></code>
.  If <code class="inline"><span class="w">dog</span></code>
 doesn't match, Perl will then try the
next alternative, <code class="inline"><span class="w">cat</span></code>
.  If <code class="inline"><span class="w">cat</span></code>
 doesn't match either, then the
match fails and Perl moves to the next position in the string.  Some
examples:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;cats and dogs&quot;</span> =~ <span class="q">/cat|dog|bird/</span><span class="sc">;</span>  <span class="c"># matches &quot;cat&quot;</span></li><li>    <span class="q">&quot;cats and dogs&quot;</span> =~ <span class="q">/dog|cat|bird/</span><span class="sc">;</span>  <span class="c"># matches &quot;cat&quot;</span></li></ol></pre><p>Even though <code class="inline"><span class="w">dog</span></code>
 is the first alternative in the second regexp,
<code class="inline"><span class="w">cat</span></code>
 is able to match earlier in the string.</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;cats&quot;</span>          =~ <span class="q">/c|ca|cat|cats/</span><span class="sc">;</span> <span class="c"># matches &quot;c&quot;</span></li><li>    <span class="q">&quot;cats&quot;</span>          =~ <span class="q">/cats|cat|ca|c/</span><span class="sc">;</span> <span class="c"># matches &quot;cats&quot;</span></li></ol></pre><p>Here, all the alternatives match at the first string position, so the
first alternative is the one that matches.  If some of the
alternatives are truncations of the others, put the longest ones first
to give them a chance to match.</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;cab&quot;</span> =~ <span class="q">/a|b|c/</span> <span class="c"># matches &quot;c&quot;</span></li><li>                     <span class="c"># /a|b|c/ == /[abc]/</span></li></ol></pre><p>The last example points out that character classes are like
alternations of characters.  At a given character position, the first
alternative that allows the regexp match to succeed will be the one
that matches.</p>
<a name="Grouping-things-and-hierarchical-matching"></a><h2>Grouping things and hierarchical matching</h2>
<p>Alternation allows a regexp to choose among alternatives, but by
itself it is unsatisfying.  The reason is that each alternative is a whole
regexp, but sometime we want alternatives for just part of a
regexp.  For instance, suppose we want to search for housecats or
housekeepers.  The regexp <code class="inline"><span class="w">housecat</span>|<span class="w">housekeeper</span></code>
 fits the bill, but is
inefficient because we had to type <code class="inline"><span class="w">house</span></code>
 twice.  It would be nice to
have parts of the regexp be constant, like <code class="inline"><span class="w">house</span></code>
, and some
parts have alternatives, like <code class="inline"><span class="w">cat</span>|<span class="w">keeper</span></code>
.</p>
<p>The <i>grouping</i> metacharacters <code class="inline"><span class="s">(</span><span class="s">)</span></code>
 solve this problem.  Grouping
allows parts of a regexp to be treated as a single unit.  Parts of a
regexp are grouped by enclosing them in parentheses.  Thus we could solve
the <code class="inline"><span class="w">housecat</span>|<span class="w">housekeeper</span></code>
 by forming the regexp as
<code class="inline"><span class="i">house</span><span class="s">(</span><span class="w">cat</span>|<span class="w">keeper</span><span class="s">)</span></code>
.  The regexp <code class="inline"><span class="i">house</span><span class="s">(</span><span class="w">cat</span>|<span class="w">keeper</span><span class="s">)</span></code>
 means match
<code class="inline"><span class="w">house</span></code>
 followed by either <code class="inline"><span class="w">cat</span></code>
 or <code class="inline"><span class="w">keeper</span></code>
.  Some more examples
are</p>
<pre class="verbatim"><ol><li>    <span class="q">/(a|b)b/</span><span class="sc">;</span>    <span class="c"># matches &#39;ab&#39; or &#39;bb&#39;</span></li><li>    <span class="q">/(ac|b)b/</span><span class="sc">;</span>   <span class="c"># matches &#39;acb&#39; or &#39;bb&#39;</span></li><li>    <span class="q">/(^a|b)c/</span><span class="sc">;</span>   <span class="c"># matches &#39;ac&#39; at start of string or &#39;bc&#39; anywhere</span></li><li>    <span class="q">/(a|[bc])d/</span><span class="sc">;</span> <span class="c"># matches &#39;ad&#39;, &#39;bd&#39;, or &#39;cd&#39;</span></li><li></li><li>    <span class="q">/house(cat|)/</span><span class="sc">;</span>  <span class="c"># matches either &#39;housecat&#39; or &#39;house&#39;</span></li><li>    <span class="q">/house(cat(s|)|)/</span><span class="sc">;</span>  <span class="c"># matches either &#39;housecats&#39; or &#39;housecat&#39; or</span></li><li>                        <span class="c"># &#39;house&#39;.  Note groups can be nested.</span></li><li></li><li>    <span class="q">/(19|20|)\d\d/</span><span class="sc">;</span>  <span class="c"># match years 19xx, 20xx, or the Y2K problem, xx</span></li><li>    <span class="q">&quot;20&quot;</span> =~ <span class="q">/(19|20|)\d\d/</span><span class="sc">;</span>  <span class="c"># matches the null alternative &#39;()\d\d&#39;,</span></li><li>                             <span class="c"># because &#39;20\d\d&#39; can&#39;t match</span></li></ol></pre><p>Alternations behave the same way in groups as out of them: at a given
string position, the leftmost alternative that allows the regexp to
match is taken.  So in the last example at the first string position,
<code class="inline"><span class="q">&quot;20&quot;</span></code>
 matches the second alternative, but there is nothing left over
to match the next two digits <code class="inline">\<span class="w">d</span>\<span class="w">d</span></code>
.  So Perl moves on to the next
alternative, which is the null alternative and that works, since
<code class="inline"><span class="q">&quot;20&quot;</span></code>
 is two digits.</p>
<p>The process of trying one alternative, seeing if it matches, and
moving on to the next alternative, while going back in the string
from where the previous alternative was tried, if it doesn't, is called
<i>backtracking</i>.  The term 'backtracking' comes from the idea that
matching a regexp is like a walk in the woods.  Successfully matching
a regexp is like arriving at a destination.  There are many possible
trailheads, one for each string position, and each one is tried in
order, left to right.  From each trailhead there may be many paths,
some of which get you there, and some which are dead ends.  When you
walk along a trail and hit a dead end, you have to backtrack along the
trail to an earlier point to try another trail.  If you hit your
destination, you stop immediately and forget about trying all the
other trails.  You are persistent, and only if you have tried all the
trails from all the trailheads and not arrived at your destination, do
you declare failure.  To be concrete, here is a step-by-step analysis
of what Perl does when it tries to match the regexp</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;abcde&quot;</span> =~ <span class="q">/(abd|abc)(df|d|de)/</span><span class="sc">;</span></li></ol></pre><ul>
<li><a name="0"></a><b>0</b>
<p>Start with the first letter in the string 'a'.</p>
</li>
<li><a name="1"></a><b>1</b>
<p>Try the first alternative in the first group 'abd'.</p>
</li>
<li><a name="2"></a><b>2</b>
<p>Match 'a' followed by 'b'. So far so good.</p>
</li>
<li><a name="3"></a><b>3</b>
<p>'d' in the regexp doesn't match 'c' in the string - a dead
end.  So backtrack two characters and pick the second alternative in
the first group 'abc'.</p>
</li>
<li><a name="4"></a><b>4</b>
<p>Match 'a' followed by 'b' followed by 'c'.  We are on a roll
and have satisfied the first group. Set $1 to 'abc'.</p>
</li>
<li><a name="5"></a><b>5</b>
<p>Move on to the second group and pick the first alternative
'df'.</p>
</li>
<li><a name="6"></a><b>6</b>
<p>Match the 'd'.</p>
</li>
<li><a name="7"></a><b>7</b>
<p>'f' in the regexp doesn't match 'e' in the string, so a dead
end.  Backtrack one character and pick the second alternative in the
second group 'd'.</p>
</li>
<li><a name="8"></a><b>8</b>
<p>'d' matches. The second grouping is satisfied, so set $2 to
'd'.</p>
</li>
<li><a name="9"></a><b>9</b>
<p>We are at the end of the regexp, so we are done! We have
matched 'abcd' out of the string "abcde".</p>
</li>
</ul>
<p>There are a couple of things to note about this analysis.  First, the
third alternative in the second group 'de' also allows a match, but we
stopped before we got to it - at a given character position, leftmost
wins.  Second, we were able to get a match at the first character
position of the string 'a'.  If there were no matches at the first
position, Perl would move to the second character position 'b' and
attempt the match all over again.  Only when all possible paths at all
possible character positions have been exhausted does Perl give
up and declare <code class="inline"><span class="i">$string</span> =~ <span class="q">/(abd|abc)(df|d|de)/</span><span class="sc">;</span></code>
 to be false.</p>
<p>Even with all this work, regexp matching happens remarkably fast.  To
speed things up, Perl compiles the regexp into a compact sequence of
opcodes that can often fit inside a processor cache.  When the code is
executed, these opcodes can then run at full throttle and search very
quickly.</p>
<a name="Extracting-matches"></a><h2>Extracting matches</h2>
<p>The grouping metacharacters <code class="inline"><span class="s">(</span><span class="s">)</span></code>
 also serve another completely
different function: they allow the extraction of the parts of a string
that matched.  This is very useful to find out what matched and for
text processing in general.  For each grouping, the part that matched
inside goes into the special variables <code class="inline"><span class="i">$1</span></code>
, <code class="inline"><span class="i">$2</span></code>
, etc.  They can be
used just as ordinary variables:</p>
<pre class="verbatim"><ol><li>    <span class="c"># extract hours, minutes, seconds</span></li><li>    if <span class="s">(</span><span class="i">$time</span> =~ <span class="q">/(\d\d):(\d\d):(\d\d)/</span><span class="s">)</span> <span class="s">{</span>    <span class="c"># match hh:mm:ss format</span></li><li>	<span class="i">$hours</span> = <span class="i">$1</span><span class="sc">;</span></li><li>	<span class="i">$minutes</span> = <span class="i">$2</span><span class="sc">;</span></li><li>	<span class="i">$seconds</span> = <span class="i">$3</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>Now, we know that in scalar context,
<code class="inline"><span class="i">$time</span> =~ <span class="q">/(\d\d):(\d\d):(\d\d)/</span></code>
 returns a true or false
value.  In list context, however, it returns the list of matched values
<code class="inline"><span class="s">(</span><span class="i">$1</span><span class="cm">,</span><span class="i">$2</span><span class="cm">,</span><span class="i">$3</span><span class="s">)</span></code>
.  So we could write the code more compactly as</p>
<pre class="verbatim"><ol><li>    <span class="c"># extract hours, minutes, seconds</span></li><li>    <span class="s">(</span><span class="i">$hours</span><span class="cm">,</span> <span class="i">$minutes</span><span class="cm">,</span> <span class="i">$second</span><span class="s">)</span> = <span class="s">(</span><span class="i">$time</span> =~ <span class="q">/(\d\d):(\d\d):(\d\d)/</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>If the groupings in a regexp are nested, <code class="inline"><span class="i">$1</span></code>
 gets the group with the
leftmost opening parenthesis, <code class="inline"><span class="i">$2</span></code>
 the next opening parenthesis,
etc.  Here is a regexp with nested groups:</p>
<pre class="verbatim"><ol><li>    /(ab(cd|ef)((gi)|j))/;</li><li>     1  2      34</li></ol></pre><p>If this regexp matches, <code class="inline"><span class="i">$1</span></code>
 contains a string starting with
<code class="inline"><span class="q">'ab'</span></code>
, <code class="inline"><span class="i">$2</span></code>
 is either set to <code class="inline"><span class="q">'cd'</span></code>
 or <code class="inline"><span class="q">'ef'</span></code>
, <code class="inline"><span class="i">$3</span></code>
 equals either
<code class="inline"><span class="q">'gi'</span></code>
 or <code class="inline"><span class="q">'j'</span></code>
, and <code class="inline"><span class="i">$4</span></code>
 is either set to <code class="inline"><span class="q">'gi'</span></code>
, just like <code class="inline"><span class="i">$3</span></code>
,
or it remains undefined.</p>
<p>For convenience, Perl sets <code class="inline"><span class="i">$+</span></code>
 to the string held by the highest numbered
<code class="inline"><span class="i">$1</span></code>
, <code class="inline"><span class="i">$2</span></code>
,... that got assigned (and, somewhat related, <code class="inline"><span class="i">$^N</span></code>
 to the
value of the <code class="inline"><span class="i">$1</span></code>
, <code class="inline"><span class="i">$2</span></code>
,... most-recently assigned; i.e. the <code class="inline"><span class="i">$1</span></code>
,
<code class="inline"><span class="i">$2</span></code>
,... associated with the rightmost closing parenthesis used in the
match).</p>
<a name="Backreferences"></a><h2>Backreferences</h2>
<p>Closely associated with the matching variables <code class="inline"><span class="i">$1</span></code>
, <code class="inline"><span class="i">$2</span></code>
, ... are
the <i>backreferences</i> <code class="inline">\<span class="w">g1</span></code>
, <code class="inline">\<span class="w">g2</span></code>
,...  Backreferences are simply
matching variables that can be used <i>inside</i> a regexp.  This is a
really nice feature; what matches later in a regexp is made to depend on
what matched earlier in the regexp.  Suppose we wanted to look
for doubled words in a text, like 'the the'.  The following regexp finds
all 3-letter doubles with a space in between:</p>
<pre class="verbatim"><ol><li>    <span class="q">/\b(\w\w\w)\s\g1\b/</span><span class="sc">;</span></li></ol></pre><p>The grouping assigns a value to \g1, so that the same 3-letter sequence
is used for both parts.</p>
<p>A similar task is to find words consisting of two identical parts:</p>
<pre class="verbatim"><ol><li>    <span class="i">% simple_grep</span> <span class="q">&#39;^(\w\w\w\w|\w\w\w|\w\w|\w)\g1$&#39;</span> /<span class="w">usr</span><span class="q">/dict/</span><span class="w">words</span></li><li>    <span class="w">beriberi</span></li><li>    <span class="w">booboo</span></li><li>    <span class="w">coco</span></li><li>    <span class="w">mama</span></li><li>    <span class="w">murmur</span></li><li>    <span class="w">papa</span></li></ol></pre><p>The regexp has a single grouping which considers 4-letter
combinations, then 3-letter combinations, etc., and uses <code class="inline">\<span class="w">g1</span></code>
 to look for
a repeat.  Although <code class="inline"><span class="i">$1</span></code>
 and <code class="inline">\<span class="w">g1</span></code>
 represent the same thing, care should be
taken to use matched variables <code class="inline"><span class="i">$1</span></code>
, <code class="inline"><span class="i">$2</span></code>
,... only <i>outside</i> a regexp
and backreferences <code class="inline">\<span class="w">g1</span></code>
, <code class="inline">\<span class="w">g2</span></code>
,... only <i>inside</i> a regexp; not doing
so may lead to surprising and unsatisfactory results.</p>
<a name="Relative-backreferences"></a><h2>Relative backreferences</h2>
<p>Counting the opening parentheses to get the correct number for a
backreference is error-prone as soon as there is more than one
capturing group.  A more convenient technique became available
with Perl 5.10: relative backreferences. To refer to the immediately
preceding capture group one now may write <code class="inline">\<span class="i">g</span><span class="s">{</span><span class="n">-1</span><span class="s">}</span></code>
, the next but
last is available via <code class="inline">\<span class="i">g</span><span class="s">{</span><span class="n">-2</span><span class="s">}</span></code>
, and so on.</p>
<p>Another good reason in addition to readability and maintainability
for using relative backreferences is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:</p>
<pre class="verbatim"><ol><li>    <span class="i">$a99a</span> = <span class="q">&#39;([a-z])(\d)\g2\g1&#39;</span><span class="sc">;</span>   <span class="c"># matches a11a, g22g, x33x, etc.</span></li></ol></pre><p>Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:</p>
<pre class="verbatim"><ol><li>    <span class="i">$line</span> = <span class="q">&quot;code=e99e&quot;</span><span class="sc">;</span></li><li>    if <span class="s">(</span><span class="i">$line</span> =~ <span class="q">/^(\w+)=$a99a$/</span><span class="s">)</span><span class="s">{</span>   <span class="c"># unexpected behavior!</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;$1 is valid\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span> else <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;bad line: '$line'\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>But this doesn't match, at least not the way one might expect. Only
after inserting the interpolated <code class="inline"><span class="i">$a99a</span></code>
 and looking at the resulting
full text of the regexp is it obvious that the backreferences have
backfired. The subexpression <code class="inline"><span class="s">(</span>\<span class="w">w</span>+<span class="s">)</span></code>
 has snatched number 1 and
demoted the groups in <code class="inline"><span class="i">$a99a</span></code>
 by one rank. This can be avoided by
using relative backreferences:</p>
<pre class="verbatim"><ol><li>    <span class="i">$a99a</span> = <span class="q">'([a-z])(\d)\g{-1}\g{-2}'</span><span class="sc">;</span>  <span class="c"># safe for being interpolated</span></li></ol></pre><a name="Named-backreferences"></a><h2>Named backreferences</h2>
<p>Perl 5.10 also introduced named capture groups and named backreferences.
To attach a name to a capturing group, you write either
<code class="inline">(?&lt;name&gt;...)</code> or <code class="inline">(?'name'...)</code>.  The backreference may
then be written as <code class="inline">\<span class="i">g</span><span class="s">{</span><span class="w">name</span><span class="s">}</span></code>
.  It is permissible to attach the
same name to more than one group, but then only the leftmost one of the
eponymous set can be referenced.  Outside of the pattern a named
capture group is accessible through the <code class="inline"><span class="i">%+</span></code>
 hash.</p>
<p>Assuming that we have to match calendar dates which may be given in one
of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' and 'y' respectively as the
names of the groups capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:</p>
<pre class="verbatim"><ol><li>    <span class="i">$fmt1</span> = <span class="q">'(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d)'</span><span class="sc">;</span></li><li>    <span class="i">$fmt2</span> = <span class="q">'(?&lt;m&gt;\d\d)/(?&lt;d&gt;\d\d)/(?&lt;y&gt;\d\d\d\d)'</span><span class="sc">;</span></li><li>    <span class="i">$fmt3</span> = <span class="q">'(?&lt;d&gt;\d\d)\.(?&lt;m&gt;\d\d)\.(?&lt;y&gt;\d\d\d\d)'</span><span class="sc">;</span></li><li>    for <a class="l_k" href="functions/my.html">my</a> <span class="i">$d</span> <span class="q">qw( 2006-10-21 15.01.2007 10/31/2005 )</span><span class="s">{</span></li><li>        if <span class="s">(</span> <span class="i">$d</span> =~ <span class="q">m{$fmt1|$fmt2|$fmt3}</span> <span class="s">)</span><span class="s">{</span></li><li>            <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;day=$+{d} month=$+{m} year=$+{y}\n&quot;</span><span class="sc">;</span></li><li>        <span class="s">}</span></li><li>    <span class="s">}</span></li></ol></pre><p>If any of the alternatives matches, the hash <code class="inline"><span class="i">%+</span></code>
 is bound to contain the
three key-value pairs.</p>
<a name="Alternative-capture-group-numbering"></a><h2>Alternative capture group numbering</h2>
<p>Yet another capturing group numbering technique (also as from Perl 5.10)
deals with the problem of referring to groups within a set of alternatives.
Consider a pattern for matching a time of the day, civil or military style:</p>
<pre class="verbatim"><ol><li>    if <span class="s">(</span> <span class="i">$time</span> =~ <span class="q">/(\d\d|\d):(\d\d)|(\d\d)(\d\d)/</span> <span class="s">)</span><span class="s">{</span></li><li>        <span class="c"># process hour and minute</span></li><li>    <span class="s">}</span></li></ol></pre><p>Processing the results requires an additional if statement to determine
whether <code class="inline"><span class="i">$1</span></code>
 and <code class="inline"><span class="i">$2</span></code>
 or <code class="inline"><span class="i">$3</span></code>
 and <code class="inline"><span class="i">$4</span></code>
 contain the goodies. It would
be easier if we could use group numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct <code class="inline">(?|...)</code>,
set around an alternative achieves. Here is an extended version of the
previous pattern:</p>
<pre class="verbatim"><ol><li>  <a class="l_k" href="functions/if.html">if</a><span class="s">(</span><span class="i">$time</span> =~ <span class="q">/(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/</span><span class="s">)</span><span class="s">{</span></li><li>      <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;hour=$1 minute=$2 zone=$3\n&quot;</span><span class="sc">;</span></li><li>  <span class="s">}</span></li></ol></pre><p>Within the alternative numbering group, group numbers start at the same
position for each alternative. After the group, numbering continues
with one higher than the maximum reached across all the alternatives.</p>
<a name="Position-information"></a><h2>Position information</h2>
<p>In addition to what was matched, Perl also provides the
positions of what was matched as contents of the <code class="inline"><span class="i">@-</span></code>
 and <code class="inline"><span class="i">@+</span></code>

arrays. <code class="inline"><span class="i">$-</span>[<span class="n">0</span>]</code>
 is the position of the start of the entire match and
<code class="inline"><span class="i">$+</span>[<span class="n">0</span>]</code>
 is the position of the end. Similarly, <code class="inline"><span class="i">$-</span>[<span class="w">n</span>]</code>
 is the
position of the start of the <code class="inline"><span class="i">$n</span></code>
 match and <code class="inline"><span class="i">$+</span>[<span class="w">n</span>]</code>
 is the position
of the end. If <code class="inline"><span class="i">$n</span></code>
 is undefined, so are <code class="inline"><span class="i">$-</span>[<span class="w">n</span>]</code>
 and <code class="inline"><span class="i">$+</span>[<span class="w">n</span>]</code>
. Then
this code</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;Mmm...donut, thought Homer&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^(Mmm|Yech)\.\.\.(donut|peas)/</span><span class="sc">;</span> <span class="c"># matches</span></li><li>    <a class="l_k" href="functions/foreach.html">foreach</a> <span class="i">$exp</span> <span class="s">(</span><span class="n">1</span>..<span class="i">$#-</span><span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;Match $exp: &#39;${$exp}&#39; at position ($-[$exp],$+[$exp])\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>prints</p>
<pre class="verbatim"><ol><li>    Match 1: 'Mmm' at position (0,3)</li><li>    Match 2: 'donut' at position (6,11)</li></ol></pre><p>Even if there are no groupings in a regexp, it is still possible to
find out what exactly matched in a string.  If you use them, Perl
will set <code class="inline"><span class="i">$`</span></code>
 to the part of the string before the match, will set <code class="inline"><span class="i">$&amp;</span></code>

to the part of the string that matched, and will set <code class="inline"><span class="i">$&#39;</span></code>
 to the part
of the string after the match.  An example:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;the cat caught the mouse&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/cat/</span><span class="sc">;</span>  <span class="c"># $` = &#39;the &#39;, $&amp; = &#39;cat&#39;, $&#39; = &#39; caught the mouse&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/the/</span><span class="sc">;</span>  <span class="c"># $` = &#39;&#39;, $&amp; = &#39;the&#39;, $&#39; = &#39; cat caught the mouse&#39;</span></li></ol></pre><p>In the second match, <code class="inline"><span class="i">$`</span></code>
 equals <code class="inline"><span class="q">&#39;&#39;</span></code>
 because the regexp matched at the
first character position in the string and stopped; it never saw the
second 'the'.</p>
<p>If your code is to run on Perl versions earlier than
5.20, it is worthwhile to note that using <code class="inline"><span class="i">$`</span></code>
 and <code class="inline"><span class="i">$&#39;</span></code>

slows down regexp matching quite a bit, while <code class="inline"><span class="i">$&amp;</span></code>
 slows it down to a
lesser extent, because if they are used in one regexp in a program,
they are generated for <i>all</i> regexps in the program.  So if raw
performance is a goal of your application, they should be avoided.
If you need to extract the corresponding substrings, use <code class="inline"><span class="i">@-</span></code>
 and
<code class="inline"><span class="i">@+</span></code>
 instead:</p>
<pre class="verbatim"><ol><li>    $` is the same as substr( $x, 0, $-[0] )</li><li>    $&amp; is the same as substr( $x, $-[0], $+[0]-$-[0] )</li><li>    $' is the same as substr( $x, $+[0] )</li></ol></pre><p>As of Perl 5.10, the <code class="inline"><span class="i">$</span>{<span class="w">^PREMATCH</span>}</code>
, <code class="inline"><span class="i">$</span>{<span class="w">^MATCH</span>}</code>
 and <code class="inline"><span class="i">$</span>{<span class="w">^POSTMATCH</span>}</code>

variables may be used.  These are only set if the <code class="inline">/p</code> modifier is
present.  Consequently they do not penalize the rest of the program.  In
Perl 5.20, <code class="inline"><span class="i">$</span>{<span class="w">^PREMATCH</span>}</code>
, <code class="inline"><span class="i">$</span>{<span class="w">^MATCH</span>}</code>
 and <code class="inline"><span class="i">$</span>{<span class="w">^POSTMATCH</span>}</code>
 are available
whether the <code class="inline">/p</code> has been used or not (the modifier is ignored), and
<code class="inline"><span class="i">$`</span></code>
, <code class="inline"><span class="i">$&#39;</span></code>
 and <code class="inline"><span class="i">$&amp;</span></code>
 do not cause any speed difference.</p>
<a name="Non-capturing-groupings"></a><h2>Non-capturing groupings</h2>
<p>A group that is required to bundle a set of alternatives may or may not be
useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture group values, inside as well as
outside the regexp.  Non-capturing groupings, denoted by <code class="inline">(?:regexp)</code>,
still allow the regexp to be treated as a single unit, but don't establish
a capturing group at the same time.  Both capturing and non-capturing
groupings are allowed to co-exist in the same regexp.  Because there is
no extraction, non-capturing groupings are faster than capturing
groupings.  Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching variables:</p>
<pre class="verbatim"><ol><li>    <span class="c"># match a number, $1-$4 are set, but we only want $1</span></li><li>    <span class="q">/([+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)/</span><span class="sc">;</span></li><li></li><li>    <span class="c"># match a number faster , only $1 is set</span></li><li>    <span class="q">/([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)/</span><span class="sc">;</span></li><li></li><li>    <span class="c"># match a number, get $1 = whole number, $2 = exponent</span></li><li>    <span class="q">/([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]([+-]?\d+))?)/</span><span class="sc">;</span></li></ol></pre><p>Non-capturing groupings are also useful for removing nuisance
elements gathered from a split operation where parentheses are
required for some reason:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&#39;12aba34ba5&#39;</span><span class="sc">;</span></li><li>    <span class="i">@num</span> = <a class="l_k" href="functions/split.html">split</a> <span class="q">/(a|b)+/</span><span class="cm">,</span> <span class="i">$x</span><span class="sc">;</span>    <span class="c"># @num = (&#39;12&#39;,&#39;a&#39;,&#39;34&#39;,&#39;a&#39;,&#39;5&#39;)</span></li><li>    <span class="i">@num</span> = <a class="l_k" href="functions/split.html">split</a> <span class="q">/(?:a|b)+/</span><span class="cm">,</span> <span class="i">$x</span><span class="sc">;</span>  <span class="c"># @num = (&#39;12&#39;,&#39;34&#39;,&#39;5&#39;)</span></li></ol></pre><p>In Perl 5.22 and later, all groups within a regexp can be set to
non-capturing by using the new <code class="inline"><span class="q">/n</span></code>
 flag:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;hello&quot;</span> =~ <span class="q">/(hi|hello)/</span><span class="w">n</span><span class="sc">;</span> <span class="c"># $1 is not set!</span></li></ol></pre><p>See <a href="perlre.html#n">n in perlre</a> for more information.</p>
<a name="Matching-repetitions"></a><h2>Matching repetitions</h2>
<p>The examples in the previous section display an annoying weakness.  We
were only matching 3-letter words, or chunks of words of 4 letters or
less.  We'd like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
<code class="inline">\<span class="w">w</span>\<span class="w">w</span>\<span class="w">w</span>\<span class="w">w</span>|\<span class="w">w</span>\<span class="w">w</span>\<span class="w">w</span>|\<span class="w">w</span>\<span class="w">w</span>|\<span class="w">w</span></code>
.</p>
<p>This is exactly the problem the <i>quantifier</i> metacharacters <code class="inline">?</code>,
<code class="inline"><span class="i">*</span></code>
, <code class="inline">+</code>
, and <code class="inline"><span class="s">{</span><span class="s">}</span></code>
 were created for.  They allow us to delimit the
number of repeats for a portion of a regexp we consider to be a
match.  Quantifiers are put immediately after the character, character
class, or grouping that we want to specify.  They have the following
meanings:</p>
<ul>
<li>
<p><code class="inline">a?</code> means: match 'a' 1 or 0 times</p>
</li>
<li>
<p><code class="inline"><span class="w">a</span>*</code>
 means: match 'a' 0 or more times, i.e., any number of times</p>
</li>
<li>
<p><code class="inline"><span class="w">a</span>+</code>
 means: match 'a' 1 or more times, i.e., at least once</p>
</li>
<li>
<p><code class="inline">a{n,m}</code> means: match at least <code class="inline"><span class="w">n</span></code>
 times, but not more than <code class="inline"><a class="l_k" href="functions/m.html">m</a></code>
times.</p>
</li>
<li>
<p><code class="inline"><span class="w">a</span><span class="s">{</span><span class="w">n</span><span class="cm">,</span><span class="s">}</span></code>
 means: match at least <code class="inline"><span class="w">n</span></code>
 or more times</p>
</li>
<li>
<p><code class="inline"><span class="i">a</span><span class="s">{</span><span class="w">n</span><span class="s">}</span></code>
 means: match exactly <code class="inline"><span class="w">n</span></code>
 times</p>
</li>
</ul>
<p>Here are some examples:</p>
<pre class="verbatim"><ol><li>    <span class="q">/[a-z]+\s+\d*/</span><span class="sc">;</span>  <span class="c"># match a lowercase word, at least one space, and</span></li><li>                     <span class="c"># any number of digits</span></li><li>    <span class="q">/(\w+)\s+\g1/</span><span class="sc">;</span>    <span class="c"># match doubled words of arbitrary length</span></li><li>    <span class="q">/y(es)?/i</span><span class="sc">;</span>       <span class="c"># matches &#39;y&#39;, &#39;Y&#39;, or a case-insensitive &#39;yes&#39;</span></li><li>    <span class="i">$year</span> =~ <span class="q">/^\d{2,4}$/</span><span class="sc">;</span>  <span class="c"># make sure year is at least 2 but not more</span></li><li>                           <span class="c"># than 4 digits</span></li><li>    <span class="i">$year</span> =~ <span class="q">/^\d{4}$|^\d{2}$/</span><span class="sc">;</span> <span class="c"># better match; throw out 3-digit dates</span></li><li>    <span class="i">$year</span> =~ <span class="q">/^\d{2}(\d{2})?$/</span><span class="sc">;</span> <span class="c"># same thing written differently.</span></li><li>                                <span class="c"># However, this captures the last two</span></li><li>                                <span class="c"># digits in $1 and the other does not.</span></li><li></li><li>    <span class="i">% simple_grep</span> <span class="q">&#39;^(\w+)\g1$&#39;</span> /<span class="w">usr</span><span class="q">/dict/</span><span class="w">words</span>   <span class="c"># isn&#39;t this easier?</span></li><li>    <span class="w">beriberi</span></li><li>    <span class="w">booboo</span></li><li>    <span class="w">coco</span></li><li>    <span class="w">mama</span></li><li>    <span class="w">murmur</span></li><li>    <span class="w">papa</span></li></ol></pre><p>For all of these quantifiers, Perl will try to match as much of the
string as possible, while still allowing the regexp to succeed.  Thus
with <code class="inline"><span class="q">/a?.../</span></code>
, Perl will first try to match the regexp with the <code class="inline"><span class="w">a</span></code>

present; if that fails, Perl will try to match the regexp without the
<code class="inline"><span class="w">a</span></code>
 present.  For the quantifier <code class="inline"><span class="i">*</span></code>
, we get the following:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;the cat in the hat&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^(.*)(cat)(.*)$/</span><span class="sc">;</span> <span class="c"># matches,</span></li><li>                             <span class="c"># $1 = &#39;the &#39;</span></li><li>                             <span class="c"># $2 = &#39;cat&#39;</span></li><li>                             <span class="c"># $3 = &#39; in the hat&#39;</span></li></ol></pre><p>Which is what we might expect, the match finds the only <code class="inline"><span class="w">cat</span></code>
 in the
string and locks onto it.  Consider, however, this regexp:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/^(.*)(at)(.*)$/</span><span class="sc">;</span> <span class="c"># matches,</span></li><li>                            <span class="c"># $1 = 'the cat in the h'</span></li><li>                            <span class="c"># $2 = 'at'</span></li><li>                            <span class="c"># $3 = ''   (0 characters match)</span></li></ol></pre><p>One might initially guess that Perl would find the <code class="inline"><span class="w">at</span></code>
 in <code class="inline"><span class="w">cat</span></code>
 and
stop there, but that wouldn't give the longest possible string to the
first quantifier <code class="inline">.*</code>.  Instead, the first quantifier <code class="inline">.*</code> grabs as
much of the string as possible while still having the regexp match.  In
this example, that means having the <code class="inline"><span class="w">at</span></code>
 sequence with the final <code class="inline"><span class="w">at</span></code>

in the string.  The other important principle illustrated here is that,
when there are two or more elements in a regexp, the <i>leftmost</i>
quantifier, if there is one, gets to grab as much of the string as
possible, leaving the rest of the regexp to fight over scraps.  Thus in
our example, the first quantifier <code class="inline">.*</code> grabs most of the string, while
the second quantifier <code class="inline">.*</code> gets the empty string.   Quantifiers that
grab as much of the string as possible are called <i>maximal match</i> or
<i>greedy</i> quantifiers.</p>
<p>When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:</p>
<ul>
<li>
<p>Principle 0: Taken as a whole, any regexp will be matched at the
earliest possible position in the string.</p>
</li>
<li>
<p>Principle 1: In an alternation <code class="inline"><span class="w">a</span>|<span class="w">b</span>|<span class="w">c</span>...</code>
, the leftmost alternative
that allows a match for the whole regexp will be the one used.</p>
</li>
<li>
<p>Principle 2: The maximal matching quantifiers <code class="inline">?</code>, <code class="inline"><span class="i">*</span></code>
, <code class="inline">+</code>
 and
<code class="inline">{n,m}</code> will in general match as much of the string as possible while
still allowing the whole regexp to match.</p>
</li>
<li>
<p>Principle 3: If there are two or more elements in a regexp, the
leftmost greedy quantifier, if any, will match as much of the string
as possible while still allowing the whole regexp to match.  The next
leftmost greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still allowing the
whole regexp to match.  And so on, until all the regexp elements are
satisfied.</p>
</li>
</ul>
<p>As we have seen above, Principle 0 overrides the others. The regexp
will be matched as early as possible, with the other principles
determining how the regexp matches at that earliest character
position.</p>
<p>Here is an example of these principles in action:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;The programming republic of Perl&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^(.+)(e|r)(.*)$/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                              <span class="c"># $1 = &#39;The programming republic of Pe&#39;</span></li><li>                              <span class="c"># $2 = &#39;r&#39;</span></li><li>                              <span class="c"># $3 = &#39;l&#39;</span></li></ol></pre><p>This regexp matches at the earliest string position, <code class="inline"><span class="q">&#39;T&#39;</span></code>
.  One
might think that <code class="inline"><span class="w">e</span></code>
, being leftmost in the alternation, would be
matched, but <code class="inline"><span class="w">r</span></code>
 produces the longest string in the first quantifier.</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(m{1,2})(.*)$/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                            <span class="c"># $1 = &#39;mm&#39;</span></li><li>                            <span class="c"># $2 = &#39;ing republic of Perl&#39;</span></li></ol></pre><p>Here, The earliest possible match is at the first <code class="inline"><span class="q">&#39;m&#39;</span></code>
 in
<code class="inline"><span class="w">programming</span></code>
. <code class="inline"><a class="l_k" href="functions/m.html">m{1,2}</a></code> is the first quantifier, so it gets to match
a maximal <code class="inline"><span class="w">mm</span></code>
.</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/.*(m{1,2})(.*)$/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                              <span class="c"># $1 = &#39;m&#39;</span></li><li>                              <span class="c"># $2 = &#39;ing republic of Perl&#39;</span></li></ol></pre><p>Here, the regexp matches at the start of the string. The first
quantifier <code class="inline">.*</code> grabs as much as possible, leaving just a single
<code class="inline"><span class="q">&#39;m&#39;</span></code>
 for the second quantifier <code class="inline"><a class="l_k" href="functions/m.html">m{1,2}</a></code>.</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(.?)(m{1,2})(.*)$/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                                <span class="c"># $1 = &#39;a&#39;</span></li><li>                                <span class="c"># $2 = &#39;mm&#39;</span></li><li>                                <span class="c"># $3 = &#39;ing republic of Perl&#39;</span></li></ol></pre><p>Here, <code class="inline">.?</code> eats its maximal one character at the earliest possible
position in the string, <code class="inline"><span class="q">&#39;a&#39;</span></code>
 in <code class="inline"><span class="w">programming</span></code>
, leaving <code class="inline"><a class="l_k" href="functions/m.html">m{1,2}</a></code>
the opportunity to match both <code class="inline"><a class="l_k" href="functions/m.html">m</a></code>'s. Finally,</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;aXXXb&quot;</span> =~ <span class="q">/(X*)/</span><span class="sc">;</span> <span class="c"># matches with $1 = &#39;&#39;</span></li></ol></pre><p>because it can match zero copies of <code class="inline"><span class="q">&#39;X&#39;</span></code>
 at the beginning of the
string.  If you definitely want to match at least one <code class="inline"><span class="q">&#39;X&#39;</span></code>
, use
<code class="inline"><span class="w">X</span>+</code>
, not <code class="inline"><span class="w">X</span>*</code>
.</p>
<p>Sometimes greed is not good.  At times, we would like quantifiers to
match a <i>minimal</i> piece of string, rather than a maximal piece.  For
this purpose, Larry Wall created the <i>minimal match</i> or
<i>non-greedy</i> quantifiers <code class="inline"><span class="q">??</span></code>
, <code class="inline"><span class="i">*?</span></code>
, <code class="inline">+?</code>, and <code class="inline">{}?</code>.  These are
the usual quantifiers with a <code class="inline">?</code> appended to them.  They have the
following meanings:</p>
<ul>
<li>
<p><code class="inline"><span class="w">a</span><span class="q">??</span></code>
 means: match 'a' 0 or 1 times. Try 0 first, then 1.</p>
</li>
<li>
<p><code class="inline">a*?</code> means: match 'a' 0 or more times, i.e., any number of times,
but as few times as possible</p>
</li>
<li>
<p><code class="inline">a+?</code> means: match 'a' 1 or more times, i.e., at least once, but
as few times as possible</p>
</li>
<li>
<p><code class="inline">a{n,m}?</code> means: match at least <code class="inline"><span class="w">n</span></code>
 times, not more than <code class="inline"><a class="l_k" href="functions/m.html">m</a></code>
times, as few times as possible</p>
</li>
<li>
<p><code class="inline">a{n,}?</code> means: match at least <code class="inline"><span class="w">n</span></code>
 times, but as few times as
possible</p>
</li>
<li>
<p><code class="inline">a{n}?</code> means: match exactly <code class="inline"><span class="w">n</span></code>
 times.  Because we match exactly
<code class="inline"><span class="w">n</span></code>
 times, <code class="inline">a{n}?</code> is equivalent to <code class="inline"><span class="i">a</span><span class="s">{</span><span class="w">n</span><span class="s">}</span></code>
 and is just there for
notational consistency.</p>
</li>
</ul>
<p>Let's look at the example above, but with minimal quantifiers:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;The programming republic of Perl&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^(.+?)(e|r)(.*)$/</span><span class="sc">;</span> <span class="c"># matches,</span></li><li>                              <span class="c"># $1 = &#39;Th&#39;</span></li><li>                              <span class="c"># $2 = &#39;e&#39;</span></li><li>                              <span class="c"># $3 = &#39; programming republic of Perl&#39;</span></li></ol></pre><p>The minimal string that will allow both the start of the string <code class="inline">^</code>
and the alternation to match is <code class="inline"><span class="w">Th</span></code>
, with the alternation <code class="inline"><span class="w">e</span>|<span class="w">r</span></code>

matching <code class="inline"><span class="w">e</span></code>
.  The second quantifier <code class="inline">.*</code> is free to gobble up the
rest of the string.</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(m{1,2}?)(.*?)$/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                              <span class="c"># $1 = &#39;m&#39;</span></li><li>                              <span class="c"># $2 = &#39;ming republic of Perl&#39;</span></li></ol></pre><p>The first string position that this regexp can match is at the first
<code class="inline"><span class="q">&#39;m&#39;</span></code>
 in <code class="inline"><span class="w">programming</span></code>
. At this position, the minimal <code class="inline"><a class="l_k" href="functions/m.html">m{1,2}?</a></code>
matches just one <code class="inline"><span class="q">&#39;m&#39;</span></code>
.  Although the second quantifier <code class="inline">.*?</code> would
prefer to match no characters, it is constrained by the end-of-string
anchor <code class="inline"><span class="i">$</span></code>
 to match the rest of the string.</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(.*?)(m{1,2}?)(.*)$/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                                  <span class="c"># $1 = &#39;The progra&#39;</span></li><li>                                  <span class="c"># $2 = &#39;m&#39;</span></li><li>                                  <span class="c"># $3 = &#39;ming republic of Perl&#39;</span></li></ol></pre><p>In this regexp, you might expect the first minimal quantifier <code class="inline">.*?</code>
to match the empty string, because it is not constrained by a <code class="inline">^</code>
anchor to match the beginning of the word.  Principle 0 applies here,
however.  Because it is possible for the whole regexp to match at the
start of the string, it <i>will</i> match at the start of the string.  Thus
the first quantifier has to match everything up to the first <code class="inline"><a class="l_k" href="functions/m.html">m</a></code>.  The
second minimal quantifier matches just one <code class="inline"><a class="l_k" href="functions/m.html">m</a></code> and the third
quantifier matches the rest of the string.</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(.??)(m{1,2})(.*)$/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                                 <span class="c"># $1 = &#39;a&#39;</span></li><li>                                 <span class="c"># $2 = &#39;mm&#39;</span></li><li>                                 <span class="c"># $3 = &#39;ing republic of Perl&#39;</span></li></ol></pre><p>Just as in the previous regexp, the first quantifier <code class="inline">.??</code> can match
earliest at position <code class="inline"><span class="q">&#39;a&#39;</span></code>
, so it does.  The second quantifier is
greedy, so it matches <code class="inline"><span class="w">mm</span></code>
, and the third matches the rest of the
string.</p>
<p>We can modify principle 3 above to take into account non-greedy
quantifiers:</p>
<ul>
<li>
<p>Principle 3: If there are two or more elements in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match as much
(little) of the string as possible while still allowing the whole
regexp to match.  The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string remaining
available to it as possible, while still allowing the whole regexp to
match.  And so on, until all the regexp elements are satisfied.</p>
</li>
</ul>
<p>Just like alternation, quantifiers are also susceptible to
backtracking.  Here is a step-by-step analysis of the example</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;the cat in the hat&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^(.*)(at)(.*)$/</span><span class="sc">;</span> <span class="c"># matches,</span></li><li>                            <span class="c"># $1 = &#39;the cat in the h&#39;</span></li><li>                            <span class="c"># $2 = &#39;at&#39;</span></li><li>                            <span class="c"># $3 = &#39;&#39;   (0 matches)</span></li></ol></pre><ul>
<li><a name="0"></a><b>0</b>
<p>Start with the first letter in the string 't'.</p>
</li>
<li><a name="1"></a><b>1</b>
<p>The first quantifier '.*' starts out by matching the whole
string 'the cat in the hat'.</p>
</li>
<li><a name="2"></a><b>2</b>
<p>'a' in the regexp element 'at' doesn't match the end of the
string.  Backtrack one character.</p>
</li>
<li><a name="3"></a><b>3</b>
<p>'a' in the regexp element 'at' still doesn't match the last
letter of the string 't', so backtrack one more character.</p>
</li>
<li><a name="4"></a><b>4</b>
<p>Now we can match the 'a' and the 't'.</p>
</li>
<li><a name="5"></a><b>5</b>
<p>Move on to the third element '.*'.  Since we are at the end of
the string and '.*' can match 0 times, assign it the empty string.</p>
</li>
<li><a name="6"></a><b>6</b>
<p>We are done!</p>
</li>
</ul>
<p>Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string.  A typical structure that blows up in your face is of the form</p>
<pre class="verbatim"><ol><li>    <span class="q">/(a|b+)*/</span><span class="sc">;</span></li></ol></pre><p>The problem is the nested indeterminate quantifiers.  There are many
different ways of partitioning a string of length n between the <code class="inline">+</code>

and <code class="inline"><span class="i">*</span></code>
: one repetition with <code class="inline"><span class="w">b</span>+</code>
 of length n, two repetitions with
the first <code class="inline"><span class="w">b</span>+</code>
 length k and the second with length n-k, m repetitions
whose bits add up to length n, etc.  In fact there are an exponential
number of ways to partition a string as a function of its length.  A
regexp may get lucky and match early in the process, but if there is
no match, Perl will try <i>every</i> possibility before giving up.  So be
careful with nested <code class="inline"><span class="i">*</span></code>
's, <code class="inline">{n,m}</code>'s, and <code class="inline">+</code>
's.  The book
<i>Mastering Regular Expressions</i> by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.</p>
<a name="Possessive-quantifiers"></a><h2>Possessive quantifiers</h2>
<p>Backtracking during the relentless search for a match may be a waste
of time, particularly when the match is bound to fail.  Consider
the simple pattern</p>
<pre class="verbatim"><ol><li>    <span class="q">/^\w+\s+\w+$/</span><span class="sc">;</span> <span class="c"># a word, spaces, a word</span></li></ol></pre><p>Whenever this is applied to a string which doesn't quite meet the
pattern's expectations such as <code class="inline"><span class="q">&quot;abc  &quot;</span></code>
 or <code class="inline"><span class="q">&quot;abc  def &quot;</span></code>
,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking <i>all</i>
of the initial word characters to match the first repetition, that <i>all</i>
spaces must be eaten by the middle part, and the same goes for the second
word.</p>
<p>With the introduction of the <i>possessive quantifiers</i> in Perl 5.10, we
have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a <code class="inline">+</code>
 appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:</p>
<ul>
<li>
<p><code class="inline">a{n,m}+</code> means: match at least <code class="inline"><span class="w">n</span></code>
 times, not more than <code class="inline"><a class="l_k" href="functions/m.html">m</a></code> times,
as many times as possible, and don't give anything up. <code class="inline">a?+</code> is short
for <code class="inline"><span class="w">a</span><span class="s">{</span><span class="n">0</span><span class="cm">,</span><span class="n">1</span><span class="s">}</span>+</code>
</p>
</li>
<li>
<p><code class="inline"><span class="w">a</span><span class="s">{</span><span class="w">n</span><span class="cm">,</span><span class="s">}</span>+</code>
 means: match at least <code class="inline"><span class="w">n</span></code>
 times, but as many times as possible,
and don't give anything up. <code class="inline"><span class="w">a</span>*+</code>
 is short for <code class="inline"><span class="w">a</span><span class="s">{</span><span class="n">0</span><span class="cm">,</span><span class="s">}</span>+</code>
 and <code class="inline"><span class="w">a</span>++</code>
 is
short for <code class="inline"><span class="w">a</span><span class="s">{</span><span class="n">1</span><span class="cm">,</span><span class="s">}</span>+</code>
.</p>
</li>
<li>
<p><code class="inline"><span class="i">a</span><span class="s">{</span><span class="w">n</span><span class="s">}</span>+</code>
 means: match exactly <code class="inline"><span class="w">n</span></code>
 times.  It is just there for
notational consistency.</p>
</li>
</ul>
<p>These possessive quantifiers represent a special case of a more general
concept, the <i>independent subexpression</i>, see below.</p>
<p>As an example where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.</p>
<pre class="verbatim"><ol><li>    <span class="q">/&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</span><span class="sc">;</span></li></ol></pre><a name="Building-a-regexp"></a><h2>Building a regexp</h2>
<p>At this point, we have all the basic regexp concepts covered, so let's
give a more involved example of a regular expression.  We will build a
regexp that matches numbers.</p>
<p>The first task in building a regexp is to decide what we want to match
and what we want to exclude.  In our case, we want to match both
integers and floating point numbers and we want to reject any string
that isn't a number.</p>
<p>The next task is to break the problem down into smaller problems that
are easily converted into a regexp.</p>
<p>The simplest case is integers.  These consist of a sequence of digits,
with an optional sign in front.  The digits we can represent with
<code class="inline">\<span class="w">d</span>+</code>
 and the sign can be matched with <code class="inline"><span class="s">[</span>+-<span class="s">]</span></code>
.  Thus the integer
regexp is</p>
<pre class="verbatim"><ol><li>    <span class="q">/[+-]?\d+/</span><span class="sc">;</span>  <span class="c"># matches integers</span></li></ol></pre><p>A floating point number potentially has a sign, an integral part, a
decimal point, a fractional part, and an exponent.  One or more of these
parts is optional, so we need to check out the different
possibilities.  Floating point numbers which are in proper form include
123., 0.345, .34, -1e6, and 25.4E-72.  As with integers, the sign out
front is completely optional and can be matched by <code class="inline">[+-]?</code>.  We can
see that if there is no exponent, floating point numbers must have a
decimal point, otherwise they are integers.  We might be tempted to
model these with <code class="inline">\d*\.\d*</code>, but this would also match just a single
decimal point, which is not a number.  So the three cases of floating
point number without exponent are</p>
<pre class="verbatim"><ol><li>   <span class="q">/[+-]?\d+\./</span><span class="sc">;</span>  <span class="c"># 1., 321., etc.</span></li><li>   <span class="q">/[+-]?\.\d+/</span><span class="sc">;</span>  <span class="c"># .1, .234, etc.</span></li><li>   <span class="q">/[+-]?\d+\.\d+/</span><span class="sc">;</span>  <span class="c"># 1.0, 30.56, etc.</span></li></ol></pre><p>These can be combined into a single regexp with a three-way alternation:</p>
<pre class="verbatim"><ol><li>   <span class="q">/[+-]?(\d+\.\d+|\d+\.|\.\d+)/</span><span class="sc">;</span>  <span class="c"># floating point, no exponent</span></li></ol></pre><p>In this alternation, it is important to put <code class="inline"><span class="q">&#39;\d+\.\d+&#39;</span></code>
 before
<code class="inline"><span class="q">&#39;\d+\.&#39;</span></code>
.  If <code class="inline"><span class="q">&#39;\d+\.&#39;</span></code>
 were first, the regexp would happily match that
and ignore the fractional part of the number.</p>
<p>Now consider floating point numbers with exponents.  The key
observation here is that <i>both</i> integers and numbers with decimal
points are allowed in front of an exponent.  Then exponents, like the
overall sign, are independent of whether we are matching numbers with
or without decimal points, and can be 'decoupled' from the
mantissa.  The overall form of the regexp now becomes clear:</p>
<pre class="verbatim"><ol><li>    <span class="q">/^(optional sign)(integer | f.p. mantissa)(optional exponent)$/</span><span class="sc">;</span></li></ol></pre><p>The exponent is an <code class="inline"><span class="w">e</span></code>
 or <code class="inline"><span class="w">E</span></code>
, followed by an integer.  So the
exponent regexp is</p>
<pre class="verbatim"><ol><li>   <span class="q">/[eE][+-]?\d+/</span><span class="sc">;</span>  <span class="c"># exponent</span></li></ol></pre><p>Putting all the parts together, we get a regexp that matches numbers:</p>
<pre class="verbatim"><ol><li>   <span class="q">/^[+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?$/</span><span class="sc">;</span>  <span class="c"># Ta da!</span></li></ol></pre><p>Long regexps like this may impress your friends, but can be hard to
decipher.  In complex situations like this, the <code class="inline"><span class="q">//x</span></code>
 modifier for a
match is invaluable.  It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.  Using it,
we can rewrite our 'extended' regexp in the more pleasing form</p>
<pre class="verbatim"><ol><li>   <span class="q">/^</span></li><li>      <span class="q">      [+-]?         # first, match an optional sign</span></li><li>      <span class="q">      (             # then match integers or f.p. mantissas:</span></li><li>          <span class="q">          \d+\.\d+  # mantissa of the form a.b</span></li><li>         <span class="q">         |\d+\.     # mantissa of the form a.</span></li><li>         <span class="q">         |\.\d+     # mantissa of the form .b</span></li><li>         <span class="q">         |\d+       # integer of the form a</span></li><li>      <span class="q">      )</span></li><li>      <span class="q">      ([eE][+-]?\d+)?  # finally, optionally match an exponent</span></li><li>   <span class="q">   $/x</span><span class="sc">;</span></li></ol></pre><p>If whitespace is mostly irrelevant, how does one include space
characters in an extended regexp? The answer is to backslash it
<code class="inline"><span class="q">&#39;\ &#39;</span></code>
 or put it in a character class <code class="inline"><span class="s">[</span> <span class="s">]</span></code>
.  The same thing
goes for pound signs: use <code class="inline">\<span class="c">#</span></code>
 or <code class="inline">[#]</code>.  For instance, Perl allows
a space between the sign and the mantissa or integer, and we could add
this to our regexp as follows:</p>
<pre class="verbatim"><ol><li>   <span class="q">/^</span></li><li>      <span class="q">      [+-]?\ *      # first, match an optional sign *and space*</span></li><li>      <span class="q">      (             # then match integers or f.p. mantissas:</span></li><li>          <span class="q">          \d+\.\d+  # mantissa of the form a.b</span></li><li>         <span class="q">         |\d+\.     # mantissa of the form a.</span></li><li>         <span class="q">         |\.\d+     # mantissa of the form .b</span></li><li>         <span class="q">         |\d+       # integer of the form a</span></li><li>      <span class="q">      )</span></li><li>      <span class="q">      ([eE][+-]?\d+)?  # finally, optionally match an exponent</span></li><li>   <span class="q">   $/x</span><span class="sc">;</span></li></ol></pre><p>In this form, it is easier to see a way to simplify the
alternation.  Alternatives 1, 2, and 4 all start with <code class="inline">\<span class="w">d</span>+</code>
, so it
could be factored out:</p>
<pre class="verbatim"><ol><li>   <span class="q">/^</span></li><li>      <span class="q">      [+-]?\ *      # first, match an optional sign</span></li><li>      <span class="q">      (             # then match integers or f.p. mantissas:</span></li><li>          <span class="q">          \d+       # start out with a ...</span></li><li>          <span class="q">          (</span></li><li>              <span class="q">              \.\d* # mantissa of the form a.b or a.</span></li><li>          <span class="q">          )?        # ? takes care of integers of the form a</span></li><li>         <span class="q">         |\.\d+     # mantissa of the form .b</span></li><li>      <span class="q">      )</span></li><li>      <span class="q">      ([eE][+-]?\d+)?  # finally, optionally match an exponent</span></li><li>   <span class="q">   $/x</span><span class="sc">;</span></li></ol></pre><p>or written in the compact form,</p>
<pre class="verbatim"><ol><li>    <span class="q">/^[+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/</span><span class="sc">;</span></li></ol></pre><p>This is our final regexp.  To recap, we built a regexp by</p>
<ul>
<li>
<p>specifying the task in detail,</p>
</li>
<li>
<p>breaking down the problem into smaller parts,</p>
</li>
<li>
<p>translating the small parts into regexps,</p>
</li>
<li>
<p>combining the regexps,</p>
</li>
<li>
<p>and optimizing the final combined regexp.</p>
</li>
</ul>
<p>These are also the typical steps involved in writing a computer
program.  This makes perfect sense, because regular expressions are
essentially programs written in a little computer language that specifies
patterns.</p>
<a name="Using-regular-expressions-in-Perl"></a><h2>Using regular expressions in Perl</h2>
<p>The last topic of Part 1 briefly covers how regexps are used in Perl
programs.  Where do they fit into Perl syntax?</p>
<p>We have already introduced the matching operator in its default
<code class="inline"><span class="q">/regexp/</span></code>
 and arbitrary delimiter <code class="inline"><a class="l_k" href="functions/m.html">m!regexp!</a></code> forms.  We have used
the binding operator <code class="inline">=~</code>
 and its negation <code class="inline">!~</code>
 to test for string
matches.  Associated with the matching operator, we have discussed the
single line <code class="inline"><span class="q">//s</span></code>
, multi-line <code class="inline"><span class="q">//m</span></code>
, case-insensitive <code class="inline"><span class="q">//i</span></code>
 and
extended <code class="inline"><span class="q">//x</span></code>
 modifiers.  There are a few more things you might
want to know about matching operators.</p>
<a name="Prohibiting-substitution"></a><h3>Prohibiting substitution</h3>
<p>If you change <code class="inline"><span class="i">$pattern</span></code>
 after the first substitution happens, Perl
will ignore it.  If you don't want any substitutions at all, use the
special delimiter <code class="inline"><a class="l_k" href="functions/m.html">m''</a></code>:</p>
<pre class="verbatim"><ol><li>    <span class="i">@pattern</span> = <span class="s">(</span><span class="q">&#39;Seuss&#39;</span><span class="s">)</span><span class="sc">;</span></li><li>    while <span class="s">(</span>&lt;&gt;<span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> if <span class="q">m&#39;@pattern&#39;</span><span class="sc">;</span>  <span class="c"># matches literal &#39;@pattern&#39;, not &#39;Seuss&#39;</span></li><li>    <span class="s">}</span></li></ol></pre><p>Similar to strings, <code class="inline"><a class="l_k" href="functions/m.html">m''</a></code> acts like apostrophes on a regexp; all other
<code class="inline"><a class="l_k" href="functions/m.html">m</a></code> delimiters act like quotes.  If the regexp evaluates to the empty string,
the regexp in the <i>last successful match</i> is used instead.  So we have</p>
<pre class="verbatim"><ol><li>    "dog" =~ /d/;  # 'd' matches</li><li>    "dogbert =~ //;  # this matches the 'd' regexp used before</li></ol></pre><a name="Global-matching"></a><h3>Global matching</h3>
<p>The final two modifiers we will discuss here,
<code class="inline"><span class="q">//g</span></code>
 and <code class="inline"><span class="q">//c</span></code>
, concern multiple matches.
The modifier <code class="inline"><span class="q">//g</span></code>
 stands for global matching and allows the
matching operator to match within a string as many times as possible.
In scalar context, successive invocations against a string will have
<code class="inline"><span class="q">//g</span></code>
 jump from match to match, keeping track of position in the
string as it goes along.  You can get or set the position with the
<code class="inline"><a class="l_k" href="functions/pos.html">pos()</a></code> function.</p>
<p>The use of <code class="inline"><span class="q">//g</span></code>
 is shown in the following example.  Suppose we have
a string that consists of words separated by spaces.  If we know how
many words there are in advance, we could extract the words using
groupings:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;cat dog house&quot;</span><span class="sc">;</span> <span class="c"># 3 words</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^\s*(\w+)\s+(\w+)\s+(\w+)\s*$/</span><span class="sc">;</span> <span class="c"># matches,</span></li><li>                                           <span class="c"># $1 = &#39;cat&#39;</span></li><li>                                           <span class="c"># $2 = &#39;dog&#39;</span></li><li>                                           <span class="c"># $3 = &#39;house&#39;</span></li></ol></pre><p>But what if we had an indeterminate number of words? This is the sort
of task <code class="inline"><span class="q">//g</span></code>
 was made for.  To extract all words, form the simple
regexp <code class="inline"><span class="s">(</span>\<span class="w">w</span>+<span class="s">)</span></code>
 and loop over all matches with <code class="inline"><span class="q">/(\w+)/g</span></code>
:</p>
<pre class="verbatim"><ol><li>    while <span class="s">(</span><span class="i">$x</span> =~ <span class="q">/(\w+)/g</span><span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;Word is $1, ends at position &quot;</span><span class="cm">,</span> <a class="l_k" href="functions/pos.html">pos</a> <span class="i">$x</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>prints</p>
<pre class="verbatim"><ol><li>    Word is cat, ends at position 3</li><li>    Word is dog, ends at position 7</li><li>    Word is house, ends at position 13</li></ol></pre><p>A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
<code class="inline"><span class="q">//c</span></code>
, as in <code class="inline"><span class="q">/regexp/gc</span></code>
.  The current position in the string is
associated with the string, not the regexp.  This means that different
strings have different positions and their respective positions can be
set or read independently.</p>
<p>In list context, <code class="inline"><span class="q">//g</span></code>
 returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regexp.  So if
we wanted just the words, we could use</p>
<pre class="verbatim"><ol><li>    <span class="i">@words</span> = <span class="s">(</span><span class="i">$x</span> =~ <span class="q">/(\w+)/g</span><span class="s">)</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                                <span class="c"># $words[0] = &#39;cat&#39;</span></li><li>                                <span class="c"># $words[1] = &#39;dog&#39;</span></li><li>                                <span class="c"># $words[2] = &#39;house&#39;</span></li></ol></pre><p>Closely associated with the <code class="inline"><span class="q">//g</span></code>
 modifier is the <code class="inline">\<span class="w">G</span></code>
 anchor.  The
<code class="inline">\<span class="w">G</span></code>
 anchor matches at the point where the previous <code class="inline"><span class="q">//g</span></code>
 match left
off.  <code class="inline">\<span class="w">G</span></code>
 allows us to easily do context-sensitive matching:</p>
<pre class="verbatim"><ol><li>    <span class="i">$metric</span> = <span class="n">1</span><span class="sc">;</span>  <span class="c"># use metric units</span></li><li>    ...</li><li>    <span class="i">$x</span> = <span class="q">&lt;FILE&gt;</span><span class="sc">;</span>  <span class="c"># read in measurement</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^([+-]?\d+)\s*/g</span><span class="sc">;</span>  <span class="c"># get magnitude</span></li><li>    <span class="i">$weight</span> = <span class="i">$1</span><span class="sc">;</span></li><li>    if <span class="s">(</span><span class="i">$metric</span><span class="s">)</span> <span class="s">{</span> <span class="c"># error checking</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;Units error!&quot;</span> unless <span class="i">$x</span> =~ <span class="q">/\Gkg\./g</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    else <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;Units error!&quot;</span> unless <span class="i">$x</span> =~ <span class="q">/\Glbs\./g</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\G\s+(widget|sprocket)/g</span><span class="sc">;</span>  <span class="c"># continue processing</span></li></ol></pre><p>The combination of <code class="inline"><span class="q">//g</span></code>
 and <code class="inline">\<span class="w">G</span></code>
 allows us to process the string a
bit at a time and use arbitrary Perl logic to decide what to do next.
Currently, the <code class="inline">\<span class="w">G</span></code>
 anchor is only fully supported when used to anchor
to the start of the pattern.</p>
<p><code class="inline">\<span class="w">G</span></code>
 is also invaluable in processing fixed-length records with
regexps.  Suppose we have a snippet of coding region DNA, encoded as
base pair letters <code class="inline"><span class="w">ATCGTTGAAT</span>...</code>
 and we want to find all the stop
codons <code class="inline"><span class="w">TGA</span></code>
.  In a coding region, codons are 3-letter sequences, so
we can think of the DNA snippet as a sequence of 3-letter records.  The
naive regexp</p>
<pre class="verbatim"><ol><li>    <span class="c"># expanded, this is &quot;ATC GTT GAA TGC AAA TGA CAT GAC&quot;</span></li><li>    <span class="i">$dna</span> = <span class="q">&quot;ATCGTTGAATGCAAATGACATGAC&quot;</span><span class="sc">;</span></li><li>    <span class="i">$dna</span> =~ <span class="q">/TGA/</span><span class="sc">;</span></li></ol></pre><p>doesn't work; it may match a <code class="inline"><span class="w">TGA</span></code>
, but there is no guarantee that
the match is aligned with codon boundaries, e.g., the substring
<code class="inline"><span class="w">GTT</span> <span class="w">GAA</span></code>
 gives a match.  A better solution is</p>
<pre class="verbatim"><ol><li>    while <span class="s">(</span><span class="i">$dna</span> =~ <span class="q">/(\w\w\w)*?TGA/g</span><span class="s">)</span> <span class="s">{</span>  <span class="c"># note the minimal *?</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;Got a TGA stop codon at position &quot;</span><span class="cm">,</span> <a class="l_k" href="functions/pos.html">pos</a> <span class="i">$dna</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>which prints</p>
<pre class="verbatim"><ol><li>    Got a TGA stop codon at position 18</li><li>    Got a TGA stop codon at position 23</li></ol></pre><p>Position 18 is good, but position 23 is bogus.  What happened?</p>
<p>The answer is that our regexp works well until we get past the last
real match.  Then the regexp will fail to match a synchronized <code class="inline"><span class="w">TGA</span></code>

and start stepping ahead one character position at a time, not what we
want.  The solution is to use <code class="inline">\<span class="w">G</span></code>
 to anchor the match to the codon
alignment:</p>
<pre class="verbatim"><ol><li>    while <span class="s">(</span><span class="i">$dna</span> =~ <span class="q">/\G(\w\w\w)*?TGA/g</span><span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;Got a TGA stop codon at position &quot;</span><span class="cm">,</span> <a class="l_k" href="functions/pos.html">pos</a> <span class="i">$dna</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>This prints</p>
<pre class="verbatim"><ol><li>    <span class="w">Got</span> <span class="w">a</span> <span class="w">TGA</span> <span class="w">stop</span> <span class="w">codon</span> <span class="w">at</span> <span class="w">position</span> <span class="n">18</span></li></ol></pre><p>which is the correct answer.  This example illustrates that it is
important not only to match what is desired, but to reject what is not
desired.</p>
<p>(There are other regexp modifiers that are available, such as
<code class="inline"><span class="q">//o</span></code>
, but their specialized uses are beyond the
scope of this introduction.  )</p>
<a name="Search-and-replace"></a><h3>Search and replace</h3>
<p>Regular expressions also play a big role in <i>search and replace</i>
operations in Perl.  Search and replace is accomplished with the
<code class="inline"><a class="l_k" href="functions/s.html">s///</a></code> operator.  The general form is
<code class="inline"><a class="l_k" href="functions/s.html">s/regexp/replacement/modifiers</a></code>, with everything we know about
regexps and modifiers applying in this case as well.  The
<code class="inline"><span class="w">replacement</span></code>
 is a Perl double-quoted string that replaces in the
string whatever is matched with the <code class="inline"><span class="w">regexp</span></code>
.  The operator <code class="inline">=~</code>
 is
also used here to associate a string with <code class="inline"><a class="l_k" href="functions/s.html">s///</a></code>.  If matching
against <code class="inline"><span class="i">$_</span></code>
, the <code class="inline"><span class="i">$_</span> =~</code>
 can be dropped.  If there is a match,
<code class="inline"><a class="l_k" href="functions/s.html">s///</a></code> returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;Time to feed the cat!&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">s/cat/hacker/</span><span class="sc">;</span>   <span class="c"># $x contains &quot;Time to feed the hacker!&quot;</span></li><li>    if <span class="s">(</span><span class="i">$x</span> =~ <span class="q">s/^(Time.*hacker)!$/$1 now!/</span><span class="s">)</span> <span class="s">{</span></li><li>        <span class="i">$more_insistent</span> = <span class="n">1</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    <span class="i">$y</span> = <span class="q">&quot;&#39;quoted words&#39;&quot;</span><span class="sc">;</span></li><li>    <span class="i">$y</span> =~ <span class="q">s/^&#39;(.*)&#39;$/$1/</span><span class="sc">;</span>  <span class="c"># strip single quotes,</span></li><li>                           <span class="c"># $y contains &quot;quoted words&quot;</span></li></ol></pre><p>In the last example, the whole string was matched, but only the part
inside the single quotes was grouped.  With the <code class="inline"><a class="l_k" href="functions/s.html">s///</a></code> operator, the
matched variables <code class="inline"><span class="i">$1</span></code>
, <code class="inline"><span class="i">$2</span></code>
, etc. are immediately available for use
in the replacement expression, so we use <code class="inline"><span class="i">$1</span></code>
 to replace the quoted
string with just what was quoted.  With the global modifier, <code class="inline"><a class="l_k" href="functions/s.html">s///g</a></code>
will search and replace all occurrences of the regexp in the string:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;I batted 4 for 4&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">s/4/four/</span><span class="sc">;</span>   <span class="c"># doesn&#39;t do it all:</span></li><li>                       <span class="c"># $x contains &quot;I batted four for 4&quot;</span></li><li>    <span class="i">$x</span> = <span class="q">&quot;I batted 4 for 4&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">s/4/four/g</span><span class="sc">;</span>  <span class="c"># does it all:</span></li><li>                       <span class="c"># $x contains &quot;I batted four for four&quot;</span></li></ol></pre><p>If you prefer 'regex' over 'regexp' in this tutorial, you could use
the following program to replace it:</p>
<pre class="verbatim"><ol><li>    <span class="i">% cat</span> &gt; <span class="w">simple_replace</span></li><li>    <span class="c">#!/usr/bin/perl</span></li><li>    <span class="i">$regexp</span> = <a class="l_k" href="functions/shift.html">shift</a><span class="sc">;</span></li><li>    <span class="i">$replacement</span> = <a class="l_k" href="functions/shift.html">shift</a><span class="sc">;</span></li><li>    while <span class="s">(</span>&lt;&gt;<span class="s">)</span> <span class="s">{</span></li><li>        <span class="q">s/$regexp/$replacement/g</span><span class="sc">;</span></li><li>        <a class="l_k" href="functions/print.html">print</a><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    ^<span class="w">D</span></li><li></li><li>    % <span class="w">simple_replace</span> <span class="w">regexp</span> <span class="w">regex</span> <span class="w">perlretut</span>.<span class="w">pod</span></li></ol></pre><p>In <code class="inline"><span class="w">simple_replace</span></code>
 we used the <code class="inline"><a class="l_k" href="functions/s.html">s///g</a></code> modifier to replace all
occurrences of the regexp on each line.  (Even though the regular
expression appears in a loop, Perl is smart enough to compile it
only once.)  As with <code class="inline"><span class="w">simple_grep</span></code>
, both the
<code class="inline"><a class="l_k" href="functions/print.html">print</a></code> and the <code class="inline"><a class="l_k" href="functions/s.html">s/$regexp/$replacement/g</a></code> use <code class="inline"><span class="i">$_</span></code>
 implicitly.</p>
<p>If you don't want <code class="inline"><a class="l_k" href="functions/s.html">s///</a></code> to change your original variable you can use
the non-destructive substitute modifier, <code class="inline"><a class="l_k" href="functions/s.html">s///r</a></code>.  This changes the
behavior so that <code class="inline"><a class="l_k" href="functions/s.html">s///r</a></code> returns the final substituted string
(instead of the number of substitutions):</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;I like dogs.&quot;</span><span class="sc">;</span></li><li>    <span class="i">$y</span> = <span class="i">$x</span> =~ <span class="q">s/dogs/cats/</span><span class="w">r</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;$x $y\n&quot;</span><span class="sc">;</span></li></ol></pre><p>That example will print "I like dogs. I like cats". Notice the original
<code class="inline"><span class="i">$x</span></code>
 variable has not been affected. The overall
result of the substitution is instead stored in <code class="inline"><span class="i">$y</span></code>
. If the
substitution doesn't affect anything then the original string is
returned:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;I like dogs.&quot;</span><span class="sc">;</span></li><li>    <span class="i">$y</span> = <span class="i">$x</span> =~ <span class="q">s/elephants/cougars/</span><span class="w">r</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;$x $y\n&quot;</span><span class="sc">;</span> <span class="c"># prints &quot;I like dogs. I like dogs.&quot;</span></li></ol></pre><p>One other interesting thing that the <code class="inline"><a class="l_k" href="functions/s.html">s///r</a></code> flag allows is chaining
substitutions:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;Cats are great.&quot;</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="i">$x</span> =~ <span class="q">s/Cats/Dogs/</span><span class="w">r</span> =~ <span class="q">s/Dogs/Frogs/</span><span class="w">r</span> =~</li><li>        <span class="q">s/Frogs/Hedgehogs/</span><span class="w">r</span><span class="cm">,</span> <span class="q">&quot;\n&quot;</span><span class="sc">;</span></li><li>    <span class="c"># prints &quot;Hedgehogs are great.&quot;</span></li></ol></pre><p>A modifier available specifically to search and replace is the
<code class="inline"><a class="l_k" href="functions/s.html">s///e</a></code> evaluation modifier.  <code class="inline"><a class="l_k" href="functions/s.html">s///e</a></code> treats the
replacement text as Perl code, rather than a double-quoted
string.  The value that the code returns is substituted for the
matched substring.  <code class="inline"><a class="l_k" href="functions/s.html">s///e</a></code> is useful if you need to do a bit of
computation in the process of replacing text.  This example counts
character frequencies in a line:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;Bill the cat&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">s/(.)/$chars{$1}++;$1/eg</span><span class="sc">;</span> <span class="c"># final $1 replaces char with itself</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;frequency of &#39;$_&#39; is $chars{$_}\n&quot;</span></li><li>        <a class="l_k" href="functions/foreach.html">foreach</a> <span class="s">(</span><a class="l_k" href="functions/sort.html">sort</a> <span class="s">{</span><span class="i">$chars</span>{<span class="i">$b</span>} &lt;=&gt; <span class="i">$chars</span>{<span class="i">$a</span>}<span class="s">}</span> <a class="l_k" href="functions/keys.html">keys</a> <span class="i">%chars</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>This prints</p>
<pre class="verbatim"><ol><li>    frequency of ' ' is 2</li><li>    frequency of 't' is 2</li><li>    frequency of 'l' is 2</li><li>    frequency of 'B' is 1</li><li>    frequency of 'c' is 1</li><li>    frequency of 'e' is 1</li><li>    frequency of 'h' is 1</li><li>    frequency of 'i' is 1</li><li>    frequency of 'a' is 1</li></ol></pre><p>As with the match <code class="inline"><a class="l_k" href="functions/m.html">m//</a></code> operator, <code class="inline"><a class="l_k" href="functions/s.html">s///</a></code> can use other delimiters,
such as <code class="inline"><a class="l_k" href="functions/s.html">s!!!</a></code> and <code class="inline"><a class="l_k" href="functions/s.html">s{}{}</a></code>, and even <code class="inline"><a class="l_k" href="functions/s.html">s{}//</a></code>.  If single quotes are
used <code class="inline"><a class="l_k" href="functions/s.html">s'''</a></code>, then the regexp and replacement are
treated as single-quoted strings and there are no
variable substitutions.  <code class="inline"><a class="l_k" href="functions/s.html">s///</a></code> in list context
returns the same thing as in scalar context, i.e., the number of
matches.</p>
<a name="The-split-function"></a><h3>The split function</h3>
<p>The <code class="inline"><a class="l_k" href="functions/split.html">split()</a></code> function is another place where a regexp is used.
<code class="inline"><a class="l_k" href="functions/split.html">split</a> <span class="q">/regexp/</span><span class="cm">,</span> <span class="w">string</span><span class="cm">,</span> <span class="w">limit</span></code>
 separates the <code class="inline"><span class="w">string</span></code>
 operand into
a list of substrings and returns that list.  The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
The <code class="inline"><span class="w">limit</span></code>
, if present, constrains splitting into no more than <code class="inline"><span class="w">limit</span></code>

number of strings.  For example, to split a string into words, use</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;Calvin and Hobbes&quot;</span><span class="sc">;</span></li><li>    <span class="i">@words</span> = <a class="l_k" href="functions/split.html">split</a> <span class="q">/\s+/</span><span class="cm">,</span> <span class="i">$x</span><span class="sc">;</span>  <span class="c"># $word[0] = &#39;Calvin&#39;</span></li><li>                               <span class="c"># $word[1] = &#39;and&#39;</span></li><li>                               <span class="c"># $word[2] = &#39;Hobbes&#39;</span></li></ol></pre><p>If the empty regexp <code class="inline"><span class="q">//</span></code>
 is used, the regexp always matches and
the string is split into individual characters.  If the regexp has
groupings, then the resulting list contains the matched substrings from the
groupings as well.  For instance,</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;/usr/bin/perl&quot;</span><span class="sc">;</span></li><li>    <span class="i">@dirs</span> = <a class="l_k" href="functions/split.html">split</a> <span class="q">m!/!</span><span class="cm">,</span> <span class="i">$x</span><span class="sc">;</span>  <span class="c"># $dirs[0] = &#39;&#39;</span></li><li>                             <span class="c"># $dirs[1] = &#39;usr&#39;</span></li><li>                             <span class="c"># $dirs[2] = &#39;bin&#39;</span></li><li>                             <span class="c"># $dirs[3] = &#39;perl&#39;</span></li><li>    <span class="i">@parts</span> = <a class="l_k" href="functions/split.html">split</a> <span class="q">m!(/)!</span><span class="cm">,</span> <span class="i">$x</span><span class="sc">;</span>  <span class="c"># $parts[0] = &#39;&#39;</span></li><li>                                <span class="c"># $parts[1] = &#39;/&#39;</span></li><li>                                <span class="c"># $parts[2] = &#39;usr&#39;</span></li><li>                                <span class="c"># $parts[3] = &#39;/&#39;</span></li><li>                                <span class="c"># $parts[4] = &#39;bin&#39;</span></li><li>                                <span class="c"># $parts[5] = &#39;/&#39;</span></li><li>                                <span class="c"># $parts[6] = &#39;perl&#39;</span></li></ol></pre><p>Since the first character of $x matched the regexp, <code class="inline"><a class="l_k" href="functions/split.html">split</a></code> prepended
an empty initial element to the list.</p>
<p>If you have read this far, congratulations! You now have all the basic
tools needed to use regular expressions to solve a wide range of text
processing problems.  If this is your first time through the tutorial,
why not stop here and play around with regexps a while....  Part 2
concerns the more esoteric aspects of regular expressions and those
concepts certainly aren't needed right at the start.</p>
<a name="Part-2%3a-Power-tools"></a><h1>Part 2: Power tools</h1>
<p>OK, you know the basics of regexps and you want to know more.  If
matching regular expressions is analogous to a walk in the woods, then
the tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time.  Most of the tools in part 2
are analogous to flare guns and satellite phones.  They aren't used
too often on a hike, but when we are stuck, they can be invaluable.</p>
<p>What follows are the more advanced, less used, or sometimes esoteric
capabilities of Perl regexps.  In Part 2, we will assume you are
comfortable with the basics and concentrate on the advanced features.</p>
<a name="More-on-characters%2c-strings%2c-and-character-classes"></a><h2>More on characters, strings, and character classes</h2>
<p>There are a number of escape sequences and character classes that we
haven't covered yet.</p>
<p>There are several escape sequences that convert characters or strings
between upper and lower case, and they are also available within
patterns.  <code class="inline">\<span class="w">l</span></code>
 and <code class="inline">\<span class="w">u</span></code>
 convert the next character to lower or
upper case, respectively:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;perl&quot;</span><span class="sc">;</span></li><li>    <span class="i">$string</span> =~ <span class="q">/\u$x/</span><span class="sc">;</span>  <span class="c"># matches &#39;Perl&#39; in $string</span></li><li>    <span class="i">$x</span> = <span class="q">&quot;M(rs?|s)\\.&quot;</span><span class="sc">;</span> <span class="c"># note the double backslash</span></li><li>    <span class="i">$string</span> =~ <span class="q">/\l$x/</span><span class="sc">;</span>  <span class="c"># matches &#39;mr.&#39;, &#39;mrs.&#39;, and &#39;ms.&#39;,</span></li></ol></pre><p>A <code class="inline">\<span class="w">L</span></code>
 or <code class="inline">\<span class="w">U</span></code>
 indicates a lasting conversion of case, until
terminated by <code class="inline">\<span class="w">E</span></code>
 or thrown over by another <code class="inline">\<span class="w">U</span></code>
 or <code class="inline">\<span class="w">L</span></code>
:</p>
<pre class="verbatim"><ol><li>    $x = "This word is in lower case:\L SHOUT\E";</li><li>    $x =~ /shout/;       # matches</li><li>    $x = "I STILL KEYPUNCH CARDS FOR MY 360"</li><li>    $x =~ /\Ukeypunch/;  # matches punch card string</li></ol></pre><p>If there is no <code class="inline">\<span class="w">E</span></code>
, case is converted until the end of the
string. The regexps <code class="inline">\<span class="w">L</span>\<span class="w">u</span><span class="i">$word</span></code>
 or <code class="inline">\<span class="w">u</span>\<span class="w">L</span><span class="i">$word</span></code>
 convert the first
character of <code class="inline"><span class="i">$word</span></code>
 to uppercase and the rest of the characters to
lowercase.</p>
<p>Control characters can be escaped with <code class="inline">\<span class="w">c</span></code>
, so that a control-Z
character would be matched with <code class="inline">\<span class="w">cZ</span></code>
.  The escape sequence
<code class="inline">\<span class="w">Q</span></code>
...<code class="inline">\<span class="w">E</span></code>
 quotes, or protects most non-alphabetic characters.   For
instance,</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;\QThat !^*&amp;%~&amp; cat!&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\Q!^*&amp;%~&amp;\E/</span><span class="sc">;</span>  <span class="c"># check for rough language</span></li></ol></pre><p>It does not protect <code class="inline"><span class="i">$</span></code>
 or <code class="inline"><span class="i">@</span></code>
, so that variables can still be
substituted.</p>
<p><code class="inline">\<span class="w">Q</span></code>
, <code class="inline">\<span class="w">L</span></code>
, <code class="inline">\<span class="w">l</span></code>
, <code class="inline">\<span class="w">U</span></code>
, <code class="inline">\<span class="w">u</span></code>
 and <code class="inline">\<span class="w">E</span></code>
 are actually part of
double-quotish syntax, and not part of regexp syntax proper.  They will
work if they appear in a regular expression embedded directly in a
program, but not when contained in a string that is interpolated in a
pattern.</p>
<p>Perl regexps can handle more than just the
standard ASCII character set.  Perl supports <i>Unicode</i>, a standard
for representing the alphabets from virtually all of the world's written
languages, and a host of symbols.  Perl's text strings are Unicode strings, so
they can contain characters with a value (codepoint or character number) higher
than 255.</p>
<p>What does this mean for regexps? Well, regexp users don't need to know
much about Perl's internal representation of strings.  But they do need
to know 1) how to represent Unicode characters in a regexp and 2) that
a matching operation will treat the string to be searched as a sequence
of characters, not bytes.  The answer to 1) is that Unicode characters
greater than <code class="inline"><a class="l_k" href="functions/chr.html">chr(255)</a></code> are represented using the <code class="inline">\<span class="i">x</span><span class="s">{</span><a class="l_k" href="functions/hex.html">hex</a><span class="s">}</span></code>
 notation, because
\x hex (without curly braces) doesn't go further than 255.  (Starting in Perl
5.14, if you're an octal fan, you can also use <code class="inline">\<span class="i">o</span><span class="s">{</span><a class="l_k" href="functions/oct.html">oct</a><span class="s">}</span></code>
.)</p>
<pre class="verbatim"><ol><li>    <span class="q">/\x{263a}/</span><span class="sc">;</span>  <span class="c"># match a Unicode smiley face :)</span></li></ol></pre><p><b>NOTE</b>: In Perl 5.6.0 it used to be that one needed to say <code class="inline"><a class="l_k" href="functions/use.html">use</a>
<span class="w">utf8</span></code>
 to use any Unicode features.  This is no more the case: for
almost all Unicode processing, the explicit <code class="inline"><span class="w">utf8</span></code>
 pragma is not
needed.  (The only case where it matters is if your Perl script is in
Unicode and encoded in UTF-8, then an explicit <code class="inline"><a class="l_k" href="functions/use.html">use</a> <span class="w">utf8</span></code>
 is needed.)</p>
<p>Figuring out the hexadecimal sequence of a Unicode character you want
or deciphering someone else's hexadecimal Unicode regexp is about as
much fun as programming in machine code.  So another way to specify
Unicode characters is to use the <i>named character</i> escape
sequence <code class="inline">\N{<i>name</i>}</code>.  <i>name</i> is a name for the Unicode character, as
specified in the Unicode standard.  For instance, if we wanted to
represent or match the astrological sign for the planet Mercury, we
could use</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;abc\N{MERCURY}def&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\N{MERCURY}/</span><span class="sc">;</span>   <span class="c"># matches</span></li></ol></pre><p>One can also use "short" names:</p>
<pre class="verbatim"><ol><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;\N{GREEK SMALL LETTER SIGMA} is called sigma.\n&quot;</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;\N{greek:Sigma} is an upper-case sigma.\n&quot;</span><span class="sc">;</span></li></ol></pre><p>You can also restrict names to a certain alphabet by specifying the
<a href="charnames.html">charnames</a> pragma:</p>
<pre class="verbatim"><ol><li>    <a class="l_k" href="functions/use.html">use</a> <span class="w">charnames</span> <span class="q">qw(greek)</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;\N{sigma} is Greek sigma\n&quot;</span><span class="sc">;</span></li></ol></pre><p>An index of character names is available on-line from the Unicode
Consortium, <a href="http://www.unicode.org/charts/charindex.html">http://www.unicode.org/charts/charindex.html</a>; explanatory
material with links to other resources at
<a href="http://www.unicode.org/standard/where">http://www.unicode.org/standard/where</a>.</p>
<p>The answer to requirement 2) is that a regexp (mostly)
uses Unicode characters.  The "mostly" is for messy backward
compatibility reasons, but starting in Perl 5.14, any regex compiled in
the scope of a <code class="inline"><a class="l_k" href="functions/use.html">use</a> <span class="w">feature</span> <span class="q">&#39;unicode_strings&#39;</span></code>
 (which is automatically
turned on within the scope of a <code class="inline"><a class="l_k" href="functions/use.html">use</a> <span class="n">5.012</span></code>
 or higher) will turn that
"mostly" into "always".  If you want to handle Unicode properly, you
should ensure that <code class="inline"><span class="q">&#39;unicode_strings&#39;</span></code>
 is turned on.
Internally, this is encoded to bytes using either UTF-8 or a native 8
bit encoding, depending on the history of the string, but conceptually
it is a sequence of characters, not bytes. See <a href="perlunitut.html">perlunitut</a> for a
tutorial about that.</p>
<p>Let us now discuss Unicode character classes, most usually called
"character properties".  These are represented by the
<code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">name</span><span class="s">}</span></code>
 escape sequence.  Closely associated is the <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">name</span><span class="s">}</span></code>

property, which is the negation of the <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">name</span><span class="s">}</span></code>
 one.  For
example, to match lower and uppercase characters,</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;BOB&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^\p{IsUpper}/</span><span class="sc">;</span>   <span class="c"># matches, uppercase char class</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^\P{IsUpper}/</span><span class="sc">;</span>   <span class="c"># doesn&#39;t match, char class sans uppercase</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^\p{IsLower}/</span><span class="sc">;</span>   <span class="c"># doesn&#39;t match, lowercase char class</span></li><li>    <span class="i">$x</span> =~ <span class="q">/^\P{IsLower}/</span><span class="sc">;</span>   <span class="c"># matches, char class sans lowercase</span></li></ol></pre><p>(The "Is" is optional.)</p>
<p>There are many, many Unicode character properties.  For the full list
see <a href="perluniprops.html">perluniprops</a>.  Most of them have synonyms with shorter names,
also listed there.  Some synonyms are a single character.  For these,
you can drop the braces.  For instance, <code class="inline">\<span class="w">pM</span></code>
 is the same thing as
<code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Mark</span><span class="s">}</span></code>
, meaning things like accent marks.</p>
<p>The Unicode <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Script</span><span class="s">}</span></code>
 property is used to categorize every Unicode
character into the language script it is written in.  For example,
English, French, and a bunch of other European languages are written in
the Latin script.  But there is also the Greek script, the Thai script,
the Katakana script, etc.  You can test whether a character is in a
particular script with, for example <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Latin</span><span class="s">}</span></code>
, <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Greek</span><span class="s">}</span></code>
,
or <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Katakana</span><span class="s">}</span></code>
.  To test if it isn't in the Balinese script, you
would use <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">Balinese</span><span class="s">}</span></code>
.</p>
<p>What we have described so far is the single form of the <code class="inline">\<span class="i">p</span><span class="s">{</span>...<span class="s">}</span></code>
 character
classes.  There is also a compound form which you may run into.  These
look like <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">name</span>=<span class="w">value</span><span class="s">}</span></code>
 or <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">name:</span><span class="w">value</span><span class="s">}</span></code>
 (the equals sign and colon
can be used interchangeably).  These are more general than the single form,
and in fact most of the single forms are just Perl-defined shortcuts for common
compound forms.  For example, the script examples in the previous paragraph
could be written equivalently as <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Script</span>=<span class="w">Latin</span><span class="s">}</span></code>
, <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Script:</span><span class="w">Greek</span><span class="s">}</span></code>
,
<code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">script</span>=<span class="w">katakana</span><span class="s">}</span></code>
, and <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">script</span>=<span class="w">balinese</span><span class="s">}</span></code>
 (case is irrelevant
between the <code class="inline"><span class="s">{</span><span class="s">}</span></code>
 braces).  You may
never have to use the compound forms, but sometimes it is necessary, and their
use can make your code easier to understand.</p>
<p><code class="inline">\<span class="w">X</span></code>
 is an abbreviation for a character class that comprises
a Unicode <i>extended grapheme cluster</i>.  This represents a "logical character":
what appears to be a single character, but may be represented internally by more
than one.  As an example, using the Unicode full names, e.g., <code class="inline"><span class="w">A</span> + <span class="w">COMBINING</span>
<span class="w">RING</span></code>
 is a grapheme cluster with base character <code class="inline"><span class="w">A</span></code>
 and combining character
<code class="inline"><span class="w">COMBINING</span> <span class="w">RING</span></code>
, which translates in Danish to A with the circle atop it,
as in the word &#xc5;ngstrom.</p>
<p>For the full and latest information about Unicode see the latest
Unicode standard, or the Unicode Consortium's website <a href="http://www.unicode.org">http://www.unicode.org</a></p>
<p>As if all those classes weren't enough, Perl also defines POSIX-style
character classes.  These have the form <code class="inline">[:name:]</code>, with <code class="inline"><span class="w">name</span></code>
 the
name of the POSIX class.  The POSIX classes are <code class="inline"><span class="w">alpha</span></code>
, <code class="inline"><span class="w">alnum</span></code>
,
<code class="inline"><span class="w">ascii</span></code>
, <code class="inline"><span class="w">cntrl</span></code>
, <code class="inline"><span class="w">digit</span></code>
, <code class="inline"><span class="w">graph</span></code>
, <code class="inline"><span class="w">lower</span></code>
, <code class="inline"><a class="l_k" href="functions/print.html">print</a></code>, <code class="inline"><span class="w">punct</span></code>
,
<code class="inline"><span class="w">space</span></code>
, <code class="inline"><span class="w">upper</span></code>
, and <code class="inline"><span class="w">xdigit</span></code>
, and two extensions, <code class="inline"><span class="w">word</span></code>
 (a Perl
extension to match <code class="inline">\<span class="w">w</span></code>
), and <code class="inline"><span class="w">blank</span></code>
 (a GNU extension).  The <code class="inline"><span class="q">//</span><span class="w">a</span></code>

modifier restricts these to matching just in the ASCII range; otherwise
they can match the same as their corresponding Perl Unicode classes:
<code class="inline">[:upper:]</code> is the same as <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">IsUpper</span><span class="s">}</span></code>
, etc.  (There are some
exceptions and gotchas with this; see <a href="perlrecharclass.html">perlrecharclass</a> for a full
discussion.) The <code class="inline">[:digit:]</code>, <code class="inline">[:word:]</code>, and
<code class="inline">[:space:]</code> correspond to the familiar <code class="inline">\<span class="w">d</span></code>
, <code class="inline">\<span class="w">w</span></code>
, and <code class="inline">\s</code>
character classes.  To negate a POSIX class, put a <code class="inline">^</code> in front of
the name, so that, e.g., <code class="inline">[:^digit:]</code> corresponds to <code class="inline">\<span class="w">D</span></code>
 and, under
Unicode, <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">IsDigit</span><span class="s">}</span></code>
.  The Unicode and POSIX character classes can
be used just like <code class="inline">\<span class="w">d</span></code>
, with the exception that POSIX character
classes can only be used inside of a character class:</p>
<pre class="verbatim"><ol><li>    <span class="q">/\s+[abc[:digit:]xyz]\s*/</span><span class="sc">;</span>  <span class="c"># match a,b,c,x,y,z, or a digit</span></li><li>    <span class="q">/^=item\s[[:digit:]]/</span><span class="sc">;</span>      <span class="c"># match &#39;=item&#39;,</span></li><li>                                <span class="c"># followed by a space and a digit</span></li><li>    <span class="q">/\s+[abc\p{IsDigit}xyz]\s+/</span><span class="sc">;</span>  <span class="c"># match a,b,c,x,y,z, or a digit</span></li><li>    <span class="q">/^=item\s\p{IsDigit}/</span><span class="sc">;</span>        <span class="c"># match &#39;=item&#39;,</span></li><li>                                  <span class="c"># followed by a space and a digit</span></li></ol></pre><p>Whew! That is all the rest of the characters and character classes.</p>
<a name="Compiling-and-saving-regular-expressions"></a><h2>Compiling and saving regular expressions</h2>
<p>In Part 1 we mentioned that Perl compiles a regexp into a compact
sequence of opcodes.  Thus, a compiled regexp is a data structure
that can be stored once and used again and again.  The regexp quote
<code class="inline"><a class="l_k" href="functions/qr.html">qr//</a></code> does exactly that: <code class="inline"><a class="l_k" href="functions/qr.html">qr/string/</a></code> compiles the <code class="inline"><span class="w">string</span></code>
 as a
regexp and transforms the result into a form that can be assigned to a
variable:</p>
<pre class="verbatim"><ol><li>    <span class="i">$reg</span> = <span class="q">qr/foo+bar?/</span><span class="sc">;</span>  <span class="c"># reg contains a compiled regexp</span></li></ol></pre><p>Then <code class="inline"><span class="i">$reg</span></code>
 can be used as a regexp:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;fooooba&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="i">$reg</span><span class="sc">;</span>     <span class="c"># matches, just like /foo+bar?/</span></li><li>    <span class="i">$x</span> =~ <span class="q">/$reg/</span><span class="sc">;</span>   <span class="c"># same thing, alternate form</span></li></ol></pre><p><code class="inline"><span class="i">$reg</span></code>
 can also be interpolated into a larger regexp:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(abc)?$reg/</span><span class="sc">;</span>  <span class="c"># still matches</span></li></ol></pre><p>As with the matching operator, the regexp quote can use different
delimiters, e.g., <code class="inline"><a class="l_k" href="functions/qr.html">qr!!</a></code>, <code class="inline"><a class="l_k" href="functions/qr.html">qr{}</a></code> or <code class="inline"><a class="l_k" href="functions/qr.html">qr~~</a></code>.  Apostrophes
as delimiters (<code class="inline"><a class="l_k" href="functions/qr.html">qr''</a></code>) inhibit any interpolation.</p>
<p>Pre-compiled regexps are useful for creating dynamic matches that
don't need to be recompiled each time they are encountered.  Using
pre-compiled regexps, we write a <code class="inline"><span class="w">grep_step</span></code>
 program which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.</p>
<pre class="verbatim"><ol><li>    <span class="i">% cat</span> &gt; <span class="w">grep_step</span></li><li>    <span class="c">#!/usr/bin/perl</span></li><li>    <span class="c"># grep_step - match &lt;number&gt; regexps, one after the other</span></li><li>    <span class="c"># usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...</span></li><li></li><li>    <span class="i">$number</span> = <a class="l_k" href="functions/shift.html">shift</a><span class="sc">;</span></li><li>    <span class="i">$regexp</span>[<span class="i">$_</span>] = <a class="l_k" href="functions/shift.html">shift</a> foreach <span class="s">(</span><span class="n">0</span>..<span class="i">$number</span>-<span class="n">1</span><span class="s">)</span><span class="sc">;</span></li><li>    <span class="i">@compiled</span> = <a class="l_k" href="functions/map.html">map</a> <span class="q">qr/$_/</span><span class="cm">,</span> <span class="i">@regexp</span><span class="sc">;</span></li><li>    while <span class="s">(</span><span class="i">$line</span> = &lt;&gt;<span class="s">)</span> <span class="s">{</span></li><li>        if <span class="s">(</span><span class="i">$line</span> =~ <span class="q">/$compiled[0]/</span><span class="s">)</span> <span class="s">{</span></li><li>            <a class="l_k" href="functions/print.html">print</a> <span class="i">$line</span><span class="sc">;</span></li><li>            <a class="l_k" href="functions/shift.html">shift</a> <span class="i">@compiled</span><span class="sc">;</span></li><li>            <a class="l_k" href="functions/last.html">last</a> unless <span class="i">@compiled</span><span class="sc">;</span></li><li>        <span class="s">}</span></li><li>    <span class="s">}</span></li><li>    ^<span class="w">D</span></li><li></li><li>    % <span class="w">grep_step</span> <span class="n">3</span> <a class="l_k" href="functions/shift.html">shift</a> <a class="l_k" href="functions/print.html">print</a> <a class="l_k" href="functions/last.html">last</a> <span class="j">grep_step</span></li><li>    <span class="i">$number</span> = <a class="l_k" href="functions/shift.html">shift</a><span class="sc">;</span></li><li>            <a class="l_k" href="functions/print.html">print</a> <span class="i">$line</span><span class="sc">;</span></li><li>            <a class="l_k" href="functions/last.html">last</a> unless <span class="i">@compiled</span><span class="sc">;</span></li></ol></pre><p>Storing pre-compiled regexps in an array <code class="inline"><span class="i">@compiled</span></code>
 allows us to
simply loop through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.</p>
<a name="Composing-regular-expressions-at-runtime"></a><h2>Composing regular expressions at runtime</h2>
<p>Backtracking is more efficient than repeated tries with different regular
expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the <code class="inline"><span class="w">simple_grep</span></code>
 program: a program that matches
multiple patterns:</p>
<pre class="verbatim"><ol><li>    <span class="i">% cat</span> &gt; <span class="w">multi_grep</span></li><li>    <span class="c">#!/usr/bin/perl</span></li><li>    <span class="c"># multi_grep - match any of &lt;number&gt; regexps</span></li><li>    <span class="c"># usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...</span></li><li></li><li>    <span class="i">$number</span> = <a class="l_k" href="functions/shift.html">shift</a><span class="sc">;</span></li><li>    <span class="i">$regexp</span>[<span class="i">$_</span>] = <a class="l_k" href="functions/shift.html">shift</a> foreach <span class="s">(</span><span class="n">0</span>..<span class="i">$number</span>-<span class="n">1</span><span class="s">)</span><span class="sc">;</span></li><li>    <span class="i">$pattern</span> = <a class="l_k" href="functions/join.html">join</a> <span class="q">&#39;|&#39;</span><span class="cm">,</span> <span class="i">@regexp</span><span class="sc">;</span></li><li></li><li>    while <span class="s">(</span><span class="i">$line</span> = &lt;&gt;<span class="s">)</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="i">$line</span> if <span class="i">$line</span> =~ <span class="q">/$pattern/</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li>    ^<span class="w">D</span></li><li></li><li>    % <span class="w">multi_grep</span> <span class="n">2</span> <a class="l_k" href="functions/shift.html">shift</a> for <span class="w">multi_grep</span></li><li>    <span class="i">$number</span> = <a class="l_k" href="functions/shift.html">shift</a><span class="sc">;</span></li><li>    <span class="i">$regexp</span>[<span class="i">$_</span>] = <a class="l_k" href="functions/shift.html">shift</a> foreach <span class="s">(</span><span class="n">0</span>..<span class="i">$number</span>-<span class="n">1</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>Sometimes it is advantageous to construct a pattern from the <i>input</i>
that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.</p>
<pre class="verbatim"><ol><li>    <span class="i">% cat</span> &gt; <span class="w">keymatch</span></li><li>    <span class="c">#!/usr/bin/perl</span></li><li>    <span class="i">$kwds</span> = <span class="q">&#39;copy compare list print&#39;</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/while.html">while</a><span class="s">(</span> <span class="i">$cmd</span> = &lt;&gt; <span class="s">)</span><span class="s">{</span></li><li>        <span class="i">$cmd</span> =~ <span class="q">s/^\s+|\s+$//g</span><span class="sc">;</span>  <span class="c"># trim leading and trailing spaces</span></li><li>        <a class="l_k" href="functions/if.html">if</a><span class="s">(</span> <span class="s">(</span> <span class="i">@matches</span> = <span class="i">$kwds</span> =~ <span class="q">/\b$cmd\w*/g</span> <span class="s">)</span> == <span class="n">1</span> <span class="s">)</span><span class="s">{</span></li><li>            <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;command: &#39;@matches&#39;\n&quot;</span><span class="sc">;</span></li><li>        <span class="s">}</span> <a class="l_k" href="functions/elsif.html">elsif</a><span class="s">(</span> <span class="i">@matches</span> == <span class="n">0</span> <span class="s">)</span><span class="s">{</span></li><li>            <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;no such command: &#39;$cmd&#39;\n&quot;</span><span class="sc">;</span></li><li>        <span class="s">}</span> <a class="l_k" href="functions/else.html">else</a> <span class="s">{</span></li><li>            <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;not unique: &#39;$cmd&#39; (could be one of: @matches)\n&quot;</span><span class="sc">;</span></li><li>        <span class="s">}</span></li><li>    <span class="s">}</span></li><li>    ^<span class="w">D</span></li><li></li><li>    % <span class="w">keymatch</span></li><li>    <span class="w">li</span></li><li>    <span class="w">command</span><span class="co">:</span> <span class="q">&#39;list&#39;</span></li><li>    <span class="w">co</span></li><li>    <a class="l_k" href="functions/not.html">not</a> <span class="w">unique</span><span class="co">:</span> <span class="q">&#39;co&#39;</span> <span class="s">(</span><span class="w">could</span> <span class="w">be</span> <span class="w">one</span> <span class="w">of</span><span class="co">:</span> <span class="w">copy</span> <span class="w">compare</span><span class="s">)</span></li><li>    <span class="w">printer</span></li><li>    <a class="l_k" href="functions/no.html">no</a> <span class="w">such</span> <span class="w">command</span><span class="co">:</span> <span class="q">&#39;printer&#39;</span></li></ol></pre><p>Rather than trying to match the input against the keywords, we match the
combined set of keywords against the input.  The pattern matching
operation <code class="inline"><span class="i">$kwds</span> =~ <span class="q">/\b($cmd\w*)/g</span></code>
 does several things at the
same time. It makes sure that the given command begins where a keyword
begins (<code class="inline">\<span class="w">b</span></code>
). It tolerates abbreviations due to the added <code class="inline">\<span class="w">w</span>*</code>
. It
tells us the number of matches (<code class="inline"><a class="l_k" href="functions/scalar.html">scalar</a> <span class="i">@matches</span></code>
) and all the keywords
that were actually matched.  You could hardly ask for more.</p>
<a name="Embedding-comments-and-modifiers-in-a-regular-expression"></a><h2>Embedding comments and modifiers in a regular expression</h2>
<p>Starting with this section, we will be discussing Perl's set of
<i>extended patterns</i>.  These are extensions to the traditional regular
expression syntax that provide powerful new tools for pattern
matching.  We have already seen extensions in the form of the minimal
matching constructs <code class="inline"><span class="q">??</span></code>
, <code class="inline"><span class="i">*?</span></code>
, <code class="inline">+?</code>, <code class="inline">{n,m}?</code>, and <code class="inline">{n,}?</code>.  Most
of the extensions below have the form <code class="inline">(?char...)</code>, where the
<code class="inline"><span class="w">char</span></code>
 is a character that determines the type of extension.</p>
<p>The first extension is an embedded comment <code class="inline">(?#text)</code>.  This embeds a
comment into the regular expression without affecting its meaning.  The
comment should not have any closing parentheses in the text.  An
example is</p>
<pre class="verbatim"><ol><li>    <span class="q">/(?# Match an integer:)[+-]?\d+/</span><span class="sc">;</span></li></ol></pre><p>This style of commenting has been largely superseded by the raw,
freeform commenting that is allowed with the <code class="inline"><span class="q">//x</span></code>
 modifier.</p>
<p>Most modifiers, such as <code class="inline"><span class="q">//i</span></code>
, <code class="inline"><span class="q">//m</span></code>
, <code class="inline"><span class="q">//s</span></code>
 and <code class="inline"><span class="q">//x</span></code>
 (or any
combination thereof) can also be embedded in
a regexp using <code class="inline">(?i)</code>, <code class="inline">(?m)</code>, <code class="inline">(?s)</code>, and <code class="inline">(?x)</code>.  For instance,</p>
<pre class="verbatim"><ol><li>    <span class="q">/(?i)yes/</span><span class="sc">;</span>  <span class="c"># match &#39;yes&#39; case insensitively</span></li><li>    <span class="q">/yes/i</span><span class="sc">;</span>     <span class="c"># same thing</span></li><li>    <span class="q">/(?x)(          # freeform version of an integer regexp</span></li><li>             <span class="q">             [+-]?  # match an optional sign</span></li><li>             <span class="q">             \d+    # match a sequence of digits</span></li><li>         <span class="q">         )</span></li><li>    <span class="q">    /x</span><span class="sc">;</span></li></ol></pre><p>Embedded modifiers can have two important advantages over the usual
modifiers.  Embedded modifiers allow a custom set of modifiers to
<i>each</i> regexp pattern.  This is great for matching an array of regexps
that must have different modifiers:</p>
<pre class="verbatim"><ol><li>    <span class="i">$pattern</span>[<span class="n">0</span>] = <span class="q">&#39;(?i)doctor&#39;</span><span class="sc">;</span></li><li>    <span class="i">$pattern</span>[<span class="n">1</span>] = <span class="q">&#39;Johnson&#39;</span><span class="sc">;</span></li><li>    ...</li><li>    while <span class="s">(</span>&lt;&gt;<span class="s">)</span> <span class="s">{</span></li><li>        foreach <span class="i">$patt</span> <span class="s">(</span><span class="i">@pattern</span><span class="s">)</span> <span class="s">{</span></li><li>            <a class="l_k" href="functions/print.html">print</a> if <span class="q">/$patt/</span><span class="sc">;</span></li><li>        <span class="s">}</span></li><li>    <span class="s">}</span></li></ol></pre><p>The second advantage is that embedded modifiers (except <code class="inline"><span class="q">//p</span></code>
, which
modifies the entire regexp) only affect the regexp
inside the group the embedded modifier is contained in.  So grouping
can be used to localize the modifier's effects:</p>
<pre class="verbatim"><ol><li>    <span class="q">/Answer: ((?i)yes)/</span><span class="sc">;</span>  <span class="c"># matches &#39;Answer: yes&#39;, &#39;Answer: YES&#39;, etc.</span></li></ol></pre><p>Embedded modifiers can also turn off any modifiers already present
by using, e.g., <code class="inline">(?-i)</code>.  Modifiers can also be combined into
a single expression, e.g., <code class="inline">(?s-i)</code> turns on single line mode and
turns off case insensitivity.</p>
<p>Embedded modifiers may also be added to a non-capturing grouping.
<code class="inline">(?i-m:regexp)</code> is a non-capturing grouping that matches <code class="inline"><span class="w">regexp</span></code>

case insensitively and turns off multi-line mode.</p>
<a name="Looking-ahead-and-looking-behind"></a><h2>Looking ahead and looking behind</h2>
<p>This section concerns the lookahead and lookbehind assertions.  First,
a little background.</p>
<p>In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match.  For instance, the regexp element
<code class="inline">[abc}]</code> eats up one character of the string when it matches, in the
sense that Perl moves to the next character position in the string
after the match.  There are some elements, however, that don't eat up
characters (advance the character position) if they match.  The examples
we have seen so far are the anchors.  The anchor <code class="inline">^</code> matches the
beginning of the line, but doesn't eat any characters.  Similarly, the
word boundary anchor <code class="inline">\<span class="w">b</span></code>
 matches wherever a character matching <code class="inline">\<span class="w">w</span></code>

is next to a character that doesn't, but it doesn't eat up any
characters itself.  Anchors are examples of <i>zero-width assertions</i>:
zero-width, because they consume
no characters, and assertions, because they test some property of the
string.  In the context of our walk in the woods analogy to regexp
matching, most regexp elements move us along a trail, but anchors have
us stop a moment and check our surroundings.  If the local environment
checks out, we can proceed forward.  But if the local environment
doesn't satisfy us, we must backtrack.</p>
<p>Checking the environment entails either looking ahead on the trail,
looking behind, or both.  <code class="inline">^</code> looks behind, to see that there are no
characters before.  <code class="inline"><span class="i">$</span></code>
 looks ahead, to see that there are no
characters after.  <code class="inline">\<span class="w">b</span></code>
 looks both ahead and behind, to see if the
characters on either side differ in their "word-ness".</p>
<p>The lookahead and lookbehind assertions are generalizations of the
anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by <code class="inline">(?=regexp)</code> and the lookbehind
assertion is denoted by <code class="inline">(?&lt;=fixed-regexp)</code>.  Some examples are</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;I catch the housecat 'Tom-cat' with catnip&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/cat(?=\s)/</span><span class="sc">;</span>   <span class="c"># matches 'cat' in 'housecat'</span></li><li>    <span class="i">@catwords</span> = <span class="s">(</span><span class="i">$x</span> =~ <span class="q">/(?&lt;=\s)cat\w+/g</span><span class="s">)</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                                           <span class="c"># $catwords[0] = 'catch'</span></li><li>                                           <span class="c"># $catwords[1] = 'catnip'</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\bcat\b/</span><span class="sc">;</span>  <span class="c"># matches 'cat' in 'Tom-cat'</span></li><li>    <span class="i">$x</span> =~ <span class="q">/(?&lt;=\s)cat(?=\s)/</span><span class="sc">;</span> <span class="c"># doesn't match; no isolated 'cat' in</span></li><li>                              <span class="c"># middle of $x</span></li></ol></pre><p>Note that the parentheses in <code class="inline">(?=regexp)</code> and <code class="inline">(?&lt;=regexp)</code> are
non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead <code class="inline">(?=regexp)</code> can match arbitrary regexps, but
lookbehind <code class="inline">(?&lt;=fixed-regexp)</code> only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
<code class="inline">(?&lt;=(ab|bc))</code> is fine, but <code class="inline">(?&lt;=(ab)*)</code> is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by <code class="inline">(?!regexp)</code> and <code class="inline">(?&lt;!fixed-regexp)</code> respectively.
They evaluate true if the regexps do <i>not</i> match:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;foobar&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/foo(?!bar)/</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match, &#39;bar&#39; follows &#39;foo&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/foo(?!baz)/</span><span class="sc">;</span>  <span class="c"># matches, &#39;baz&#39; doesn&#39;t follow &#39;foo&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/(?&lt;!\s)foo/</span><span class="sc">;</span>  <span class="c"># matches, there is no \s before &#39;foo&#39;</span></li></ol></pre><p>The <code class="inline">\<span class="w">C</span></code>
 is unsupported in lookbehind, because the already
treacherous definition of <code class="inline">\<span class="w">C</span></code>
 would become even more so
when going backwards.</p>
<p>Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using <code class="inline"><span class="q">/\s+/</span></code>
 alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:</p>
<pre class="verbatim"><ol><li>    <span class="i">$str</span> = <span class="q">&quot;one two - --6-8&quot;</span><span class="sc">;</span></li><li>    <span class="i">@toks</span> = <a class="l_k" href="functions/split.html">split</a> <span class="q">/ \s+              # a run of spaces</span></li><li>                  <span class="q">                  | (?&lt;=\S) (?=-)    # any non-space followed by '-'</span></li><li>                  <span class="q">                  | (?&lt;=-)  (?=\S)   # a '-' followed by any non-space</span></li><li>                  <span class="q">                  /x</span><span class="cm">,</span> <span class="i">$str</span><span class="sc">;</span>          <span class="c"># @toks = qw(one two - - - 6 - 8)</span></li></ol></pre><a name="Using-independent-subexpressions-to-prevent-backtracking"></a><h2>Using independent subexpressions to prevent backtracking</h2>
<p><i>Independent subexpressions</i> are regular expressions, in the
context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by <code class="inline">(?&gt;regexp)</code>.  We can illustrate their behavior by first
considering an ordinary regexp:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;ab&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/a*ab/</span><span class="sc">;</span>  <span class="c"># matches</span></li></ol></pre><p>This obviously matches, but in the process of matching, the
subexpression <code class="inline"><span class="w">a</span>*</code>
 first grabbed the <code class="inline"><span class="w">a</span></code>
.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, <code class="inline"><span class="w">a</span>*</code>

eventually gave back the <code class="inline"><span class="w">a</span></code>
 and matched the empty string.  Here, what
<code class="inline"><span class="w">a</span>*</code>
 matched was <i>dependent</i> on what the rest of the regexp matched.</p>
<p>Contrast that with an independent subexpression:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(?&gt;a*)ab/</span><span class="sc">;</span>  <span class="c"># doesn&#39;t match!</span></li></ol></pre><p>The independent subexpression <code class="inline">(?&gt;a*)</code> doesn't care about the rest
of the regexp, so it sees an <code class="inline"><span class="w">a</span></code>
 and grabs it.  Then the rest of the
regexp <code class="inline"><span class="w">ab</span></code>
 cannot match.  Because <code class="inline">(?&gt;a*)</code> is independent, there
is no backtracking and the independent subexpression does not give
up its <code class="inline"><span class="w">a</span></code>
.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;ab&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/a*/g</span><span class="sc">;</span>   <span class="c"># matches, eats an &#39;a&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\Gab/g</span><span class="sc">;</span> <span class="c"># doesn&#39;t match, no &#39;a&#39; available</span></li></ol></pre><p>Here <code class="inline"><span class="q">//g</span></code>
 and <code class="inline">\<span class="w">G</span></code>
 create a 'tag team' handoff of the string from
one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.</p>
<p>The ability of an independent subexpression to prevent backtracking
can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;abc(de(fg)h&quot;</span><span class="sc">;</span>  <span class="c"># unbalanced parentheses</span></li><li>    <span class="i">$x</span> =~ <span class="q">/\( ( [^()]+ | \([^()]*\) )+ \)/x</span><span class="sc">;</span></li></ol></pre><p>The regexp matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative <code class="inline">[^()]+</code> matching a substring with no
parentheses and the second alternative <code class="inline">\([^()]*\)</code>  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form <code class="inline">(a+|b)+</code>.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/\( ( (?&gt;[^()]+) | \([^()]*\) )+ \)/x</span><span class="sc">;</span></li></ol></pre><p>Here, <code class="inline">(?&gt;[^()]+)</code> breaks the degeneracy of string partitioning
by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.</p>
<a name="Conditional-expressions"></a><h2>Conditional expressions</h2>
<p>A <i>conditional expression</i> is a form of if-then-else statement
that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
<code class="inline">(?(condition)yes-regexp)</code> and
<code class="inline">(?(condition)yes-regexp|no-regexp)</code>.  <code class="inline">(?(condition)yes-regexp)</code> is
like an <code class="inline"><span class="q">&#39;if () {}&#39;</span></code>
 statement in Perl.  If the <code class="inline"><span class="w">condition</span></code>
 is true,
the <code class="inline"><span class="w">yes</span>-<span class="w">regexp</span></code>
 will be matched.  If the <code class="inline"><span class="w">condition</span></code>
 is false, the
<code class="inline"><span class="w">yes</span>-<span class="w">regexp</span></code>
 will be skipped and Perl will move onto the next regexp
element.  The second form is like an <code class="inline"><span class="q">&#39;if () {} else {}&#39;</span></code>
 statement
in Perl.  If the <code class="inline"><span class="w">condition</span></code>
 is true, the <code class="inline"><span class="w">yes</span>-<span class="w">regexp</span></code>
 will be
matched, otherwise the <code class="inline"><a class="l_k" href="functions/no.html">no-regexp</a></code> will be matched.</p>
<p>The <code class="inline"><span class="w">condition</span></code>
 can have several forms.  The first form is simply an
integer in parentheses <code class="inline"><span class="s">(</span><span class="w">integer</span><span class="s">)</span></code>
.  It is true if the corresponding
backreference <code class="inline">\<span class="w">integer</span></code>
 matched earlier in the regexp.  The same
thing can be done with a name associated with a capture group, written
as <code class="inline"><span class="s">(</span><span class="q">&lt;name&gt;</span><span class="s">)</span></code>
 or <code class="inline"><span class="s">(</span><span class="q">'name'</span><span class="s">)</span></code>
.  The second form is a bare
zero-width assertion <code class="inline">(?...)</code>, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (<code class="inline"><span class="s">(</span><span class="w">R</span><span class="s">)</span></code>
) or is being called from some capturing group,
referenced either by number (<code class="inline"><span class="s">(</span><span class="w">R1</span><span class="s">)</span></code>
, <code class="inline"><span class="s">(</span><span class="w">R2</span><span class="s">)</span></code>
,...) or by name
(<code class="inline"><span class="s">(</span><span class="w">R</span><span class="i">&amp;name</span><span class="s">)</span></code>
).</p>
<p>The integer or name form of the <code class="inline"><span class="w">condition</span></code>
 allows us to choose,
with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form <code class="inline"><span class="q">&quot;$x$x&quot;</span></code>
 or <code class="inline"><span class="q">&quot;$x$y$y$x&quot;</span></code>
:</p>
<pre class="verbatim"><ol><li>    <span class="i">% simple_grep</span> <span class="q">&#39;^(\w+)(\w+)?(?(2)\g2\g1|\g1)$&#39;</span> /<span class="w">usr</span><span class="q">/dict/</span><span class="w">words</span></li><li>    <span class="w">beriberi</span></li><li>    <span class="w">coco</span></li><li>    <span class="w">couscous</span></li><li>    <span class="w">deed</span></li><li>    ...</li><li>    <span class="w">toot</span></li><li>    <span class="w">toto</span></li><li>    <span class="w">tutu</span></li></ol></pre><p>The lookbehind <code class="inline"><span class="w">condition</span></code>
 allows, along with backreferences,
an earlier part of the match to influence a later part of the
match.  For instance,</p>
<pre class="verbatim"><ol><li>    <span class="q">/[ATGC]+(?(?&lt;=AA)G|C)$/</span><span class="sc">;</span></li></ol></pre><p>matches a DNA sequence such that it either ends in <code class="inline"><span class="w">AAG</span></code>
, or some
other base pair combination and <code class="inline"><span class="w">C</span></code>
.  Note that the form is
<code class="inline">(?(?&lt;=AA)G|C)</code> and not <code class="inline">(?((?&lt;=AA))G|C)</code>; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.</p>
<a name="Defining-named-patterns"></a><h2>Defining named patterns</h2>
<p>Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is <code class="inline">(?(DEFINE)(?&lt;name&gt;pattern)...)</code>.  An insertion
of a named pattern is written as <code class="inline">(?&amp;name)</code>.</p>
<p>The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The DEFINE
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.</p>
<pre class="verbatim"><ol><li>   <span class="q">/^ (?&amp;osg)\ * ( (?&amp;int)(?&amp;dec)? | (?&amp;dec) )</span></li><li>      <span class="q">      (?: [eE](?&amp;osg)(?&amp;int) )?</span></li><li>    <span class="q">    $</span></li><li>    <span class="q">    (?(DEFINE)</span></li><li>      <span class="q">      (?&lt;osg&gt;[-+]?)         # optional sign</span></li><li>      <span class="q">      (?&lt;int&gt;\d++)          # integer</span></li><li>      <span class="q">      (?&lt;dec&gt;\.(?&amp;int))     # decimal fraction</span></li><li>    <span class="q">    )/x</span></li></ol></pre><a name="Recursive-patterns"></a><h2>Recursive patterns</h2>
<p>This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
<code class="inline">(?group-ref)</code>, the <i>pattern</i> within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained <i>within</i> the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.</p>
<p>To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.</p>
<pre class="verbatim"><ol><li>    <span class="q">/(?: (\w) (?...Here be a palindrome...) \g{-1} | \w? )/x</span></li></ol></pre><p>Adding <code class="inline">\<span class="w">W</span>*</code>
 at either end to eliminate what is to be ignored, we already
have the full pattern:</p>
<pre class="verbatim"><ol><li>    <a class="l_k" href="functions/my.html">my</a> <span class="i">$pp</span> = <span class="q">qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix</span><span class="sc">;</span></li><li>    for <span class="i">$s</span> <span class="s">(</span> <span class="q">&quot;saippuakauppias&quot;</span><span class="cm">,</span> <span class="q">&quot;A man, a plan, a canal: Panama!&quot;</span> <span class="s">)</span><span class="s">{</span></li><li>        <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;'$s' is a palindrome\n&quot;</span> if <span class="i">$s</span> =~ <span class="q">/$pp/</span><span class="sc">;</span></li><li>    <span class="s">}</span></li></ol></pre><p>In <code class="inline">(?...)</code> both absolute and relative backreferences may be used.
The entire pattern can be reinserted with <code class="inline">(?R)</code> or <code class="inline">(?0)</code>.
If you prefer to name your groups, you can use <code class="inline">(?&amp;name)</code> to
recurse into that group.</p>
<a name="A-bit-of-magic%3a-executing-Perl-code-in-a-regular-expression"></a><h2>A bit of magic: executing Perl code in a regular expression</h2>
<p>Normally, regexps are a part of Perl expressions.
<i>Code evaluation</i> expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted <code class="inline">(?{code})</code>, with <i>code</i> a string of Perl
statements.</p>
<p>Be warned that this feature is considered experimental, and may be
changed without notice.</p>
<p>Code expressions are zero-width assertions, and the value they return
depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
<code class="inline">(?(condition)...)</code>, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
<code class="inline"><span class="i">$^R</span></code>
.  The variable <code class="inline"><span class="i">$^R</span></code>
 can then be used in code expressions later
in the regexp.  Here are some silly examples:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;abcdef&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/abc(?{print &quot;Hi Mom!&quot;;})def/</span><span class="sc">;</span> <span class="c"># matches,</span></li><li>                                         <span class="c"># prints &#39;Hi Mom!&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/aaa(?{print &quot;Hi Mom!&quot;;})def/</span><span class="sc">;</span> <span class="c"># doesn&#39;t match,</span></li><li>                                         <span class="c"># no &#39;Hi Mom!&#39;</span></li></ol></pre><p>Pay careful attention to the next example:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/abc(?{print &quot;Hi Mom!&quot;;})ddd/</span><span class="sc">;</span> <span class="c"># doesn&#39;t match,</span></li><li>                                         <span class="c"># no &#39;Hi Mom!&#39;</span></li><li>                                         <span class="c"># but why not?</span></li></ol></pre><p>At first glance, you'd think that it shouldn't print, because obviously
the <code class="inline"><span class="w">ddd</span></code>
 isn't going to match the target string. But look at this
example:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/abc(?{print &quot;Hi Mom!&quot;;})[dD]dd/</span><span class="sc">;</span> <span class="c"># doesn&#39;t match,</span></li><li>                                            <span class="c"># but _does_ print</span></li></ol></pre><p>Hmm. What happened here? If you've been following along, you know that
the above pattern should be effectively (almost) the same as the last one;
enclosing the <code class="inline"><span class="w">d</span></code>
 in a character class isn't going to change what it
matches. So why does the first not print while the second one does?</p>
<p>The answer lies in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside from the
<code class="inline">?{}</code> construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.</p>
<p>To take a closer look at how the engine does optimizations, see the
section <a href="#Pragmas-and-debugging">Pragmas and debugging</a> below.</p>
<p>More fun with <code class="inline">?{}</code>:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> =~ <span class="q">/(?{print &quot;Hi Mom!&quot;;})/</span><span class="sc">;</span>       <span class="c"># matches,</span></li><li>                                         <span class="c"># prints &#39;Hi Mom!&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/(?{$c = 1;})(?{print &quot;$c&quot;;})/</span><span class="sc">;</span>  <span class="c"># matches,</span></li><li>                                           <span class="c"># prints &#39;1&#39;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/(?{$c = 1;})(?{print &quot;$^R&quot;;})/</span><span class="sc">;</span> <span class="c"># matches,</span></li><li>                                           <span class="c"># prints &#39;1&#39;</span></li></ol></pre><p>The bit of magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using <code class="inline"><a class="l_k" href="functions/local.html">local</a></code>, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;aaaa&quot;</span><span class="sc">;</span></li><li>    <span class="i">$count</span> = <span class="n">0</span><span class="sc">;</span>  <span class="c"># initialize &#39;a&#39; count</span></li><li>    <span class="i">$c</span> = <span class="q">&quot;bob&quot;</span><span class="sc">;</span>  <span class="c"># test if $c gets clobbered</span></li><li>    <span class="i">$x</span> =~ <span class="q">/(?{local $c = 0;})         # initialize count</span></li><li>           <span class="q">           ( a                        # match &#39;a&#39;</span></li><li>             <span class="q">             (?{local $c = $c + 1;})  # increment count</span></li><li>           <span class="q">           )*                         # do this any number of times,</span></li><li>           <span class="q">           aa                         # but match &#39;aa&#39; at the end</span></li><li>           <span class="q">           (?{$count = $c;})          # copy local $c var into $count</span></li><li>          <span class="q">          /x</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;&#39;a&#39; count is $count, \$c variable is &#39;$c&#39;\n&quot;</span><span class="sc">;</span></li></ol></pre><p>This prints</p>
<pre class="verbatim"><ol><li>    'a' count is 2, $c variable is 'bob'</li></ol></pre><p>If we replace the <code class="inline"> (?{local $c = $c + 1;})</code> with
<code class="inline"> (?{$c = $c + 1;})</code>, the variable changes are <i>not</i> undone
during backtracking, and we get</p>
<pre class="verbatim"><ol><li>    'a' count is 4, $c variable is 'bob'</li></ol></pre><p>Note that only localized variable changes are undone.  Other side
effects of code expression execution are permanent.  Thus</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;aaaa&quot;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/(a(?{print &quot;Yow\n&quot;;}))*aa/</span><span class="sc">;</span></li></ol></pre><p>produces</p>
<pre class="verbatim"><ol><li>   <span class="w">Yow</span></li><li>   <span class="w">Yow</span></li><li>   <span class="w">Yow</span></li><li>   <span class="w">Yow</span></li></ol></pre><p>The result <code class="inline"><span class="i">$^R</span></code>
 is automatically localized, so that it will behave
properly in the presence of backtracking.</p>
<p>This example uses a code expression in a conditional to match a
definite article, either 'the' in English or 'der|die|das' in German:</p>
<pre class="verbatim"><ol><li>    <span class="i">$lang</span> = <span class="q">'DE'</span><span class="sc">;</span>  <span class="c"># use German</span></li><li>    ...</li><li>    <span class="i">$text</span> = <span class="q">&quot;das&quot;</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;matched\n&quot;</span></li><li>        if <span class="i">$text</span> =~ <span class="q">/(?(?{</span></li><li>                          <span class="q">                          $lang eq 'EN'; # is the language English?</span></li><li>                         <span class="q">                         })</span></li><li>                       <span class="q">                       the |             # if so, then match 'the'</span></li><li>                       <span class="q">                       (der|die|das)     # else, match 'der|die|das'</span></li><li>                     <span class="q">                     )</span></li><li>                    <span class="q">                    /xi</span><span class="sc">;</span></li></ol></pre><p>Note that the syntax here is <code class="inline">(?(?{...})yes-regexp|no-regexp)</code>, not
<code class="inline">(?((?{...}))yes-regexp|no-regexp)</code>.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.</p>
<p>If you try to use code expressions where the code text is contained within
an interpolated variable, rather than appearing literally in the pattern,
Perl may surprise you:</p>
<pre class="verbatim"><ol><li>    <span class="i">$bar</span> = <span class="n">5</span><span class="sc">;</span></li><li>    <span class="i">$pat</span> = <span class="q">&#39;(?{ 1 })&#39;</span><span class="sc">;</span></li><li>    <span class="q">/foo(?{ $bar })bar/</span><span class="sc">;</span> <span class="c"># compiles ok, $bar not interpolated</span></li><li>    <span class="q">/foo(?{ 1 })$bar/</span><span class="sc">;</span>   <span class="c"># compiles ok, $bar interpolated</span></li><li>    <span class="q">/foo${pat}bar/</span><span class="sc">;</span>      <span class="c"># compile error!</span></li><li></li><li>    <span class="i">$pat</span> = <span class="q">qr/(?{ $foo = 1 })/</span><span class="sc">;</span>  <span class="c"># precompile code regexp</span></li><li>    <span class="q">/foo${pat}bar/</span><span class="sc">;</span>      <span class="c"># compiles ok</span></li></ol></pre><p>If a regexp has a variable that interpolates a code expression, Perl
treats the regexp as an error. If the code expression is precompiled into
a variable, however, interpolating is ok. The question is, why is this an
error?</p>
<p>The reason is that variable interpolation and code expressions
together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:</p>
<pre class="verbatim"><ol><li>    $regexp = &lt;&gt;;       # read user-supplied regexp</li><li>    $chomp $regexp;     # get rid of possible newline</li><li>    $text =~ /$regexp/; # search $text for the $regexp</li></ol></pre><p>If the <code class="inline"><span class="i">$regexp</span></code>
 variable contains a code expression, the user could
then execute arbitrary Perl code.  For instance, some joker could
search for <code class="inline"><a class="l_k" href="functions/system.html">system</a><span class="s">(</span><span class="q">&#39;rm -rf *&#39;</span><span class="s">)</span><span class="sc">;</span></code>
 to erase your files.  In this
sense, the combination of interpolation and code expressions <i>taints</i>
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking <code class="inline"><a class="l_k" href="functions/use.html">use</a> <span class="w">re</span> <span class="q">&#39;eval&#39;</span></code>
:</p>
<pre class="verbatim"><ol><li>    <a class="l_k" href="functions/use.html">use</a> <span class="w">re</span> <span class="q">&#39;eval&#39;</span><span class="sc">;</span>       <span class="c"># throw caution out the door</span></li><li>    <span class="i">$bar</span> = <span class="n">5</span><span class="sc">;</span></li><li>    <span class="i">$pat</span> = <span class="q">&#39;(?{ 1 })&#39;</span><span class="sc">;</span></li><li>    <span class="q">/foo${pat}bar/</span><span class="sc">;</span>      <span class="c"># compiles ok</span></li></ol></pre><p>Another form of code expression is the <i>pattern code expression</i>.
The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is</p>
<pre class="verbatim"><ol><li>    <span class="i">$length</span> = <span class="n">5</span><span class="sc">;</span></li><li>    <span class="i">$char</span> = <span class="q">&#39;a&#39;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> = <span class="q">&#39;aaaaabb&#39;</span><span class="sc">;</span></li><li>    <span class="i">$x</span> =~ <span class="q">/(??{$char x $length})/x</span><span class="sc">;</span> <span class="c"># matches, there are 5 of &#39;a&#39;</span></li></ol></pre><p>This final example contains both ordinary and pattern code
expressions.  It detects whether a binary string <code class="inline"><span class="n">1101010010001</span>...</code>
 has a
Fibonacci spacing 0,1,1,2,3,5,...  of the <code class="inline"><span class="n">1</span></code>
's:</p>
<pre class="verbatim"><ol><li>    <span class="i">$x</span> = <span class="q">&quot;1101010010001000001&quot;</span><span class="sc">;</span></li><li>    <span class="i">$z0</span> = <span class="q">''</span><span class="sc">;</span> <span class="i">$z1</span> = <span class="q">'0'</span><span class="sc">;</span>   <span class="c"># initial conditions</span></li><li>    <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;It is a Fibonacci sequence\n&quot;</span></li><li>        if <span class="i">$x</span> =~ <span class="q">/^1         # match an initial '1'</span></li><li>                    <span class="q">                    (?:</span></li><li>                       <span class="q">                       ((??{ $z0 })) # match some '0'</span></li><li>                       <span class="q">                       1             # and then a '1'</span></li><li>		       <span class="q">		       (?{ $z0 = $z1; $z1 .= $^N; })</span></li><li>                    <span class="q">                    )+   # repeat as needed</span></li><li>                  <span class="q">                  $      # that is all there is</span></li><li>                 <span class="q">                 /x</span><span class="sc">;</span></li><li>    <a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;Largest sequence matched was %d\n&quot;</span><span class="cm">,</span> <a class="l_k" href="functions/length.html">length</a><span class="s">(</span><span class="i">$z1</span><span class="s">)</span>-<a class="l_k" href="functions/length.html">length</a><span class="s">(</span><span class="i">$z0</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>Remember that <code class="inline"><span class="i">$^N</span></code>
 is set to whatever was matched by the last
completed capture group. This prints</p>
<pre class="verbatim"><ol><li>    <span class="w">It</span> <span class="w">is</span> <span class="w">a</span> <span class="w">Fibonacci</span> <span class="w">sequence</span></li><li>    <span class="w">Largest</span> <span class="w">sequence</span> <span class="w">matched</span> <span class="w">was</span> <span class="n">5</span></li></ol></pre><p>Ha! Try that with your garden variety regexp package...</p>
<p>Note that the variables <code class="inline"><span class="i">$z0</span></code>
 and <code class="inline"><span class="i">$z1</span></code>
 are not substituted when the
regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the whole code block is parsed as perl code at the
same time as perl is compiling the code containing the literal regexp
pattern.</p>
<p>The regexp without the <code class="inline"><span class="q">//x</span></code>
 modifier is</p>
<pre class="verbatim"><ol><li>    <span class="q">/^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/</span></li></ol></pre><p>which shows that spaces are still possible in the code parts. Nevertheless,
when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.</p>
<a name="Backtracking-control-verbs"></a><h2>Backtracking control verbs</h2>
<p>Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to <a href="perlre.html#Special-Backtracking-Control-Verbs">Special Backtracking Control Verbs in perlre</a> for a
detailed description.</p>
<p>Below is just one example, illustrating the control verb <code class="inline"><span class="s">(</span><span class="i">*FAIL</span><span class="s">)</span></code>
,
which may be abbreviated as <code class="inline"><span class="s">(</span><span class="i">*F</span><span class="s">)</span></code>
. If this is inserted in a regexp
it will cause it to fail, just as it would at some
mismatch between the pattern and the string. Processing
of the regexp continues as it would after any "normal"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
groups or produce results, it may be necessary to use this in
combination with embedded code.</p>
<pre class="verbatim"><ol><li>   <span class="i">%count</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li>   <span class="q">&quot;supercalifragilisticexpialidocious&quot;</span> =~</li><li>       <span class="q">/([aeiou])(?{ $count{$1}++; })(*FAIL)/i</span><span class="sc">;</span></li><li>   <a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;%3d &#39;%s&#39;\n&quot;</span><span class="cm">,</span> <span class="i">$count</span>{<span class="i">$_</span>}<span class="cm">,</span> <span class="i">$_</span> <a class="l_k" href="functions/for.html">for</a> <span class="s">(</span><a class="l_k" href="functions/sort.html">sort</a> <a class="l_k" href="functions/keys.html">keys</a> <span class="i">%count</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like <code class="inline"><span class="i">$count</span>{<span class="q">'a'</span>}++<span class="sc">;</span></code>
 is executed, incrementing
the letter's counter. Then <code class="inline"><span class="s">(</span><span class="i">*FAIL</span><span class="s">)</span></code>
 does what it says, and
the regexp engine proceeds according to the book: as long as the end of
the string hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the entire string has been inspected.
(It's remarkable that an alternative solution using something like</p>
<pre class="verbatim"><ol><li>   <span class="i">$count</span>{<a class="l_k" href="functions/lc.html">lc</a><span class="s">(</span><span class="i">$_</span><span class="s">)</span>}++ <a class="l_k" href="functions/for.html">for</a> <a class="l_k" href="functions/split.html">split</a><span class="s">(</span><span class="q">&#39;&#39;</span><span class="cm">,</span> <span class="q">&quot;supercalifragilisticexpialidocious&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>   <a class="l_k" href="functions/printf.html">printf</a> <span class="q">&quot;%3d &#39;%s&#39;\n&quot;</span><span class="cm">,</span> <span class="i">$count2</span>{<span class="i">$_</span>}<span class="cm">,</span> <span class="i">$_</span> <a class="l_k" href="functions/for.html">for</a> <span class="s">(</span> <span class="q">qw{ a e i o u }</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>is considerably slower.)</p>
<a name="Pragmas-and-debugging"></a><h2>Pragmas and debugging</h2>
<p>Speaking of debugging, there are several pragmas available to control
and debug regexps in Perl.  We have already encountered one pragma in
the previous section, <code class="inline"><a class="l_k" href="functions/use.html">use</a> <span class="w">re</span> <span class="q">&#39;eval&#39;</span><span class="sc">;</span></code>
, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are</p>
<pre class="verbatim"><ol><li>    use re 'taint';</li><li>    $tainted = &lt;&gt;;</li><li>    @parts = ($tainted =~ /(\w+)\s+(\w+)/; # @parts is now tainted</li></ol></pre><p>The <code class="inline"><span class="w">taint</span></code>
 pragma causes any substrings from a match with a tainted
variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use <code class="inline"><span class="w">taint</span></code>
 when you are not extracting safe bits, but are
performing some other processing.  Both <code class="inline"><span class="w">taint</span></code>
 and <code class="inline"><a class="l_k" href="functions/eval.html">eval</a></code> pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.</p>
<pre class="verbatim"><ol><li>    <a class="l_k" href="functions/use.html">use</a> <span class="w">re</span> <span class="q">&#39;/m&#39;</span><span class="sc">;</span>  <span class="c"># or any other flags</span></li><li>    <span class="i">$multiline_string</span> =~ <span class="q">/^foo/</span><span class="sc">;</span> <span class="c"># /m is implied</span></li></ol></pre><p>The <code class="inline"><span class="w">re</span> <span class="q">&#39;/flags&#39;</span></code>
 pragma (introduced in Perl
5.14) turns on the given regular expression flags
until the end of the lexical scope.  See
<a href="re.html#'%2fflags'-mode">'/flags' mode in re</a> for more
detail.</p>
<pre class="verbatim"><ol><li>    <a class="l_k" href="functions/use.html">use</a> <span class="w">re</span> <span class="q">&#39;debug&#39;</span><span class="sc">;</span></li><li>    <span class="q">/^(.*)$/s</span><span class="sc">;</span>       <span class="c"># output debugging info</span></li><li></li><li>    <a class="l_k" href="functions/use.html">use</a> <span class="w">re</span> <span class="q">&#39;debugcolor&#39;</span><span class="sc">;</span></li><li>    <span class="q">/^(.*)$/s</span><span class="sc">;</span>       <span class="c"># output debugging info in living color</span></li></ol></pre><p>The global <code class="inline"><span class="w">debug</span></code>
 and <code class="inline"><span class="w">debugcolor</span></code>
 pragmas allow one to get
detailed debugging info about regexp compilation and
execution.  <code class="inline"><span class="w">debugcolor</span></code>
 is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:</p>
<pre class="verbatim"><ol><li>    <span class="i">% perl</span> -<span class="w">e</span> <span class="q">&#39;use re &quot;debug&quot;; &quot;abc&quot; =~ /a*b+c/;&#39;</span></li><li>    <span class="w">Compiling</span> <span class="w">REx</span> <span class="q">&#39;a*b+c&#39;</span></li><li>    <span class="w">size</span> <span class="n">9</span> <span class="w">first</span> <span class="w">at</span> <span class="n">1</span></li><li>       <span class="n">1</span><span class="co">:</span> <span class="i">STAR</span><span class="s">(</span><span class="n">4</span><span class="s">)</span></li><li>       <span class="n">2</span><span class="co">:</span>   <span class="w">EXACT</span> <span class="q">&lt;a&gt;</span><span class="s">(</span><span class="n">0</span><span class="s">)</span></li><li>       <span class="n">4</span><span class="co">:</span> <span class="i">PLUS</span><span class="s">(</span><span class="n">7</span><span class="s">)</span></li><li>       <span class="n">5</span><span class="co">:</span>   <span class="w">EXACT</span> <span class="q">&lt;b&gt;</span><span class="s">(</span><span class="n">0</span><span class="s">)</span></li><li>       <span class="n">7</span><span class="co">:</span> <span class="w">EXACT</span> <span class="q">&lt;c&gt;</span><span class="s">(</span><span class="n">9</span><span class="s">)</span></li><li>       <span class="n">9</span><span class="co">:</span> <a class="l_k" href="functions/END.html">END</a><span class="s">(</span><span class="n">0</span><span class="s">)</span></li><li>    <span class="w">floating</span> <span class="q">&#39;bc&#39;</span> <span class="w">at</span> <span class="n">0</span>..<span class="n">2147483647</span> <span class="s">(</span><span class="w">checking</span> <span class="w">floating</span><span class="s">)</span> <span class="w">minlen</span> <span class="n">2</span></li><li>    <span class="w">Guessing</span> <span class="w">start</span> <span class="w">of</span> <span class="w">match</span><span class="cm">,</span> <span class="w">REx</span> <span class="q">&#39;a*b+c&#39;</span> <span class="w">against</span> <span class="q">&#39;abc&#39;</span>...</li><li>    <span class="w">Found</span> <span class="w">floating</span> <a class="l_k" href="functions/substr.html">substr</a> <span class="q">&#39;bc&#39;</span> <span class="w">at</span> <span class="w">offset</span> <span class="n">1</span>...</li><li>    <span class="w">Guessed</span><span class="co">:</span> <span class="w">match</span> <span class="w">at</span> <span class="w">offset</span> <span class="n">0</span></li><li>    <span class="w">Matching</span> <span class="w">REx</span> <span class="q">&#39;a*b+c&#39;</span> <span class="w">against</span> <span class="q">&#39;abc&#39;</span></li><li>      <span class="w">Setting</span> <span class="w">an</span> <span class="w">EVAL</span> <span class="w">scope</span><span class="cm">,</span> <span class="w">savestack</span>=<span class="n">3</span></li><li>       <span class="n">0</span> &lt;&gt; &lt;<span class="w">abc</span>&gt;           |  <span class="n">1</span><span class="co">:</span>  <span class="w">STAR</span></li><li>                             <span class="w">EXACT</span> <span class="q">&lt;a&gt;</span> <span class="w">can</span> <span class="w">match</span> <span class="n">1</span> <a class="l_k" href="functions/times.html">times</a> <span class="w">out</span> <span class="w">of</span> <span class="n">32767</span>...</li><li>      <span class="w">Setting</span> <span class="w">an</span> <span class="w">EVAL</span> <span class="w">scope</span><span class="cm">,</span> <span class="w">savestack</span>=<span class="n">3</span></li><li>       <span class="n">1</span> &lt;<span class="w">a</span>&gt; <span class="q">&lt;bc&gt;</span>           |  <span class="n">4</span><span class="co">:</span>    <span class="w">PLUS</span></li><li>                             <span class="w">EXACT</span> <span class="q">&lt;b&gt;</span> <span class="w">can</span> <span class="w">match</span> <span class="n">1</span> <a class="l_k" href="functions/times.html">times</a> <span class="w">out</span> <span class="w">of</span> <span class="n">32767</span>...</li><li>      <span class="w">Setting</span> <span class="w">an</span> <span class="w">EVAL</span> <span class="w">scope</span><span class="cm">,</span> <span class="w">savestack</span>=<span class="n">3</span></li><li>       <span class="n">2</span> &lt;<span class="w">ab</span>&gt; <span class="q">&lt;c&gt;</span>           |  <span class="n">7</span><span class="co">:</span>      <span class="w">EXACT</span> <span class="q">&lt;c&gt;</span></li><li>       <span class="n">3</span> &lt;<span class="w">abc</span>&gt; &lt;&gt;           |  <span class="n">9</span><span class="co">:</span>      <a class="l_k" href="functions/END.html">END</a></li><li>    <span class="w">Match</span> <span class="w">successful</span>!</li><li>    <span class="w">Freeing</span> <span class="w">REx</span><span class="co">:</span> <span class="q">&#39;a*b+c&#39;</span></li></ol></pre><p>If you have gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.  The first
part</p>
<pre class="verbatim"><ol><li>    <span class="w">Compiling</span> <span class="w">REx</span> <span class="q">&#39;a*b+c&#39;</span></li><li>    <span class="w">size</span> <span class="n">9</span> <span class="w">first</span> <span class="w">at</span> <span class="n">1</span></li><li>       <span class="n">1</span><span class="co">:</span> <span class="i">STAR</span><span class="s">(</span><span class="n">4</span><span class="s">)</span></li><li>       <span class="n">2</span><span class="co">:</span>   <span class="w">EXACT</span> <span class="q">&lt;a&gt;</span><span class="s">(</span><span class="n">0</span><span class="s">)</span></li><li>       <span class="n">4</span><span class="co">:</span> <span class="i">PLUS</span><span class="s">(</span><span class="n">7</span><span class="s">)</span></li><li>       <span class="n">5</span><span class="co">:</span>   <span class="w">EXACT</span> <span class="q">&lt;b&gt;</span><span class="s">(</span><span class="n">0</span><span class="s">)</span></li><li>       <span class="n">7</span><span class="co">:</span> <span class="w">EXACT</span> <span class="q">&lt;c&gt;</span><span class="s">(</span><span class="n">9</span><span class="s">)</span></li><li>       <span class="n">9</span><span class="co">:</span> <a class="l_k" href="functions/END.html">END</a><span class="s">(</span><span class="n">0</span><span class="s">)</span></li></ol></pre><p>describes the compilation stage.  <code class="inline"><span class="i">STAR</span><span class="s">(</span><span class="n">4</span><span class="s">)</span></code>
 means that there is a
starred object, in this case <code class="inline"><span class="q">&#39;a&#39;</span></code>
, and if it matches, goto line 4,
i.e., <code class="inline"><span class="i">PLUS</span><span class="s">(</span><span class="n">7</span><span class="s">)</span></code>
.  The middle lines describe some heuristics and
optimizations performed before a match:</p>
<pre class="verbatim"><ol><li>    <span class="w">floating</span> <span class="q">&#39;bc&#39;</span> <span class="w">at</span> <span class="n">0</span>..<span class="n">2147483647</span> <span class="s">(</span><span class="w">checking</span> <span class="w">floating</span><span class="s">)</span> <span class="w">minlen</span> <span class="n">2</span></li><li>    <span class="w">Guessing</span> <span class="w">start</span> <span class="w">of</span> <span class="w">match</span><span class="cm">,</span> <span class="w">REx</span> <span class="q">&#39;a*b+c&#39;</span> <span class="w">against</span> <span class="q">&#39;abc&#39;</span>...</li><li>    <span class="w">Found</span> <span class="w">floating</span> <a class="l_k" href="functions/substr.html">substr</a> <span class="q">&#39;bc&#39;</span> <span class="w">at</span> <span class="w">offset</span> <span class="n">1</span>...</li><li>    <span class="w">Guessed</span><span class="co">:</span> <span class="w">match</span> <span class="w">at</span> <span class="w">offset</span> <span class="n">0</span></li></ol></pre><p>Then the match is executed and the remaining lines describe the
process:</p>
<pre class="verbatim"><ol><li>    <span class="w">Matching</span> <span class="w">REx</span> <span class="q">&#39;a*b+c&#39;</span> <span class="w">against</span> <span class="q">&#39;abc&#39;</span></li><li>      <span class="w">Setting</span> <span class="w">an</span> <span class="w">EVAL</span> <span class="w">scope</span><span class="cm">,</span> <span class="w">savestack</span>=<span class="n">3</span></li><li>       <span class="n">0</span> &lt;&gt; &lt;<span class="w">abc</span>&gt;           |  <span class="n">1</span><span class="co">:</span>  <span class="w">STAR</span></li><li>                             <span class="w">EXACT</span> <span class="q">&lt;a&gt;</span> <span class="w">can</span> <span class="w">match</span> <span class="n">1</span> <a class="l_k" href="functions/times.html">times</a> <span class="w">out</span> <span class="w">of</span> <span class="n">32767</span>...</li><li>      <span class="w">Setting</span> <span class="w">an</span> <span class="w">EVAL</span> <span class="w">scope</span><span class="cm">,</span> <span class="w">savestack</span>=<span class="n">3</span></li><li>       <span class="n">1</span> &lt;<span class="w">a</span>&gt; <span class="q">&lt;bc&gt;</span>           |  <span class="n">4</span><span class="co">:</span>    <span class="w">PLUS</span></li><li>                             <span class="w">EXACT</span> <span class="q">&lt;b&gt;</span> <span class="w">can</span> <span class="w">match</span> <span class="n">1</span> <a class="l_k" href="functions/times.html">times</a> <span class="w">out</span> <span class="w">of</span> <span class="n">32767</span>...</li><li>      <span class="w">Setting</span> <span class="w">an</span> <span class="w">EVAL</span> <span class="w">scope</span><span class="cm">,</span> <span class="w">savestack</span>=<span class="n">3</span></li><li>       <span class="n">2</span> &lt;<span class="w">ab</span>&gt; <span class="q">&lt;c&gt;</span>           |  <span class="n">7</span><span class="co">:</span>      <span class="w">EXACT</span> <span class="q">&lt;c&gt;</span></li><li>       <span class="n">3</span> &lt;<span class="w">abc</span>&gt; &lt;&gt;           |  <span class="n">9</span><span class="co">:</span>      <a class="l_k" href="functions/END.html">END</a></li><li>    <span class="w">Match</span> <span class="w">successful</span>!</li><li>    <span class="w">Freeing</span> <span class="w">REx</span><span class="co">:</span> <span class="q">&#39;a*b+c&#39;</span></li></ol></pre><p>Each step is of the form <code class="inline">n &lt;x&gt; &lt;y&gt;</code>, with <code class="inline"><span class="q">&lt;x&gt;</span></code>
 the
part of the string matched and <code class="inline"><span class="q">&lt;y&gt;</span></code>
 the part not yet
matched.  The <code class="inline">|  1:  STAR</code> says that Perl is at line number 1
in the compilation list above.  See
<a href="perldebguts.html#Debugging-Regular-Expressions">Debugging Regular Expressions in perldebguts</a> for much more detail.</p>
<p>An alternative method of debugging regexps is to embed <code class="inline"><a class="l_k" href="functions/print.html">print</a></code>
statements within the regexp.  This provides a blow-by-blow account of
the backtracking in an alternation:</p>
<pre class="verbatim"><ol><li>    <span class="q">&quot;that this&quot;</span> =~ <span class="q">m@(?{print &quot;Start at position &quot;, pos, &quot;\n&quot;;})</span></li><li>                     <span class="q">                     t(?{print &quot;t1\n&quot;;})</span></li><li>                     <span class="q">                     h(?{print &quot;h1\n&quot;;})</span></li><li>                     <span class="q">                     i(?{print &quot;i1\n&quot;;})</span></li><li>                     <span class="q">                     s(?{print &quot;s1\n&quot;;})</span></li><li>                         <span class="q">                         |</span></li><li>                     <span class="q">                     t(?{print &quot;t2\n&quot;;})</span></li><li>                     <span class="q">                     h(?{print &quot;h2\n&quot;;})</span></li><li>                     <span class="q">                     a(?{print &quot;a2\n&quot;;})</span></li><li>                     <span class="q">                     t(?{print &quot;t2\n&quot;;})</span></li><li>                     <span class="q">                     (?{print &quot;Done at position &quot;, pos, &quot;\n&quot;;})</span></li><li>                    <span class="q">                    @x</span><span class="sc">;</span></li></ol></pre><p>prints</p>
<pre class="verbatim"><ol><li>    Start at position 0</li><li>    t1</li><li>    h1</li><li>    t2</li><li>    h2</li><li>    a2</li><li>    t2</li><li>    Done at position 4</li></ol></pre><a name="BUGS"></a><h1>BUGS</h1>
<p>Code expressions, conditional expressions, and independent expressions
are <i>experimental</i>.  Don't use them in production code.  Yet.</p>
<a name="SEE-ALSO"></a><h1>SEE ALSO</h1>
<p>This is just a tutorial.  For the full story on Perl regular
expressions, see the <a href="perlre.html">perlre</a> regular expressions reference page.</p>
<p>For more information on the matching <code class="inline"><a class="l_k" href="functions/m.html">m//</a></code> and substitution <code class="inline"><a class="l_k" href="functions/s.html">s///</a></code>
operators, see <a href="perlop.html#Regexp-Quote-Like-Operators">Regexp Quote-Like Operators in perlop</a>.  For
information on the <code class="inline"><a class="l_k" href="functions/split.html">split</a></code> operation, see <a href="functions/split.html">split</a>.</p>
<p>For an excellent all-around resource on the care and feeding of
regular expressions, see the book <i>Mastering Regular Expressions</i> by
Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).</p>
<a name="AUTHOR-AND-COPYRIGHT"></a><h1>AUTHOR AND COPYRIGHT</h1>
<p>Copyright (c) 2000 Mark Kvale
All rights reserved.</p>
<p>This document may be distributed under the same terms as Perl itself.</p>
<a name="Acknowledgments"></a><h2>Acknowledgments</h2>
<p>The inspiration for the stop codon DNA example came from the ZIP
code example in chapter 7 of <i>Mastering Regular Expressions</i>.</p>
<p>The author would like to thank Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, and Joe Smith for all their helpful
comments.</p>




  <div id="page_index" class="hud_container">
    <div id="page_index_header" class="hud_header">
      <div id="page_index_close" class="hud_close"><a href="#" onClick="pageIndex.hide();return false;"></a></div>
      <div id="page_index_title" class="hud_title"><span class="hud_span_top">Page index</span></div>
      <div id="page_index_topright" class="hud_topright"></div>
    </div>
    <div id="page_index_content" class="hud_content">
      <ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION</a><li><a href="#Part-1%3a-The-basics">Part 1: The basics</a><ul><li><a href="#Simple-word-matching">Simple word matching</a><li><a href="#Using-character-classes">Using character classes</a><li><a href="#Matching-this-or-that">Matching this or that</a><li><a href="#Grouping-things-and-hierarchical-matching">Grouping things and hierarchical matching</a><li><a href="#Extracting-matches">Extracting matches</a><li><a href="#Backreferences">Backreferences</a><li><a href="#Relative-backreferences">Relative backreferences</a><li><a href="#Named-backreferences">Named backreferences</a><li><a href="#Alternative-capture-group-numbering">Alternative capture group numbering</a><li><a href="#Position-information">Position information</a><li><a href="#Non-capturing-groupings">Non-capturing groupings</a><li><a href="#Matching-repetitions">Matching repetitions</a><li><a href="#Possessive-quantifiers">Possessive quantifiers</a><li><a href="#Building-a-regexp">Building a regexp</a><li><a href="#Using-regular-expressions-in-Perl">Using regular expressions in Perl</a></ul><li><a href="#Part-2%3a-Power-tools">Part 2: Power tools</a><ul><li><a href="#More-on-characters%2c-strings%2c-and-character-classes">More on characters, strings, and character classes</a><li><a href="#Compiling-and-saving-regular-expressions">Compiling and saving regular expressions</a><li><a href="#Composing-regular-expressions-at-runtime">Composing regular expressions at runtime</a><li><a href="#Embedding-comments-and-modifiers-in-a-regular-expression">Embedding comments and modifiers in a regular expression</a><li><a href="#Looking-ahead-and-looking-behind">Looking ahead and looking behind</a><li><a href="#Using-independent-subexpressions-to-prevent-backtracking">Using independent subexpressions to prevent backtracking</a><li><a href="#Conditional-expressions">Conditional expressions</a><li><a href="#Defining-named-patterns">Defining named patterns</a><li><a href="#Recursive-patterns">Recursive patterns</a><li><a href="#A-bit-of-magic%3a-executing-Perl-code-in-a-regular-expression">A bit of magic: executing Perl code in a regular expression</a><li><a href="#Backtracking-control-verbs">Backtracking control verbs</a><li><a href="#Pragmas-and-debugging">Pragmas and debugging</a></ul><li><a href="#BUGS">BUGS</a><li><a href="#SEE-ALSO">SEE ALSO</a><li><a href="#AUTHOR-AND-COPYRIGHT">AUTHOR AND COPYRIGHT</a><ul><li><a href="#Acknowledgments">Acknowledgments</a></ul></ul>
    </div>
    <div id="page_index_footer" class="hud_footer">
      <div id="page_index_bottomleft" class="hud_bottomleft"></div>
      <div id="page_index_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
      <div id="page_index_resize" class="hud_resize"></div>
    </div>
  </div>


	    &nbsp;
          </div>
          <div id="content_footer">
          </div>
        </div>
        <div class="clear"></div>
      </div>
      
    <div id="footer">
      <div id="footer_content">
        <div id="footer_strapline">
          perldoc.perl.org - Official documentation for the Perl programming language
        </div>
        <div id="footer_links">
          <div id="address">
            <p class="name">Contact details</p>
            <p class="address">
	      Site maintained by <a href="mailto:jj@jonallen.info">Jon Allen (JJ)</a><br>
	    </p>
            <p class="contact">
              Documentation maintained by the <a href="http://lists.cpan.org/showlist.cgi?name=perl5-porters">Perl 5 Porters</a>
            </p>
          </div>
          <ul class="f1">
            <li>Manual
              <ul class="f2">
                <li><a href="index-overview.html">Overview</a>
                <li><a href="index-tutorials.html">Tutorials</a>
                <li><a href="index-faq.html">FAQs</a>
                <li><a href="index-history.html">Changes</a>
              </ul>
            <li>Reference
              <ul class="f2">
                <li><a href="index-language.html">Language</a>
                <li><a href="index-functions.html">Functions</a>
                <li><a href="perlop.html">Operators</a>
                <li><a href="perlvar.html">Variables</a>
              </ul>
            <li>Modules
              <ul class="f2">
                <li><a href="index-modules-A.html">Modules</a>
                <li><a href="index-pragmas.html">Pragmas</a>
                <li><a href="index-utilities.html">Utilities</a>
              </ul>
            <li>Misc
              <ul class="f2">
                <li><a href="index-licence.html">License</a>
                <li><a href="index-internals.html">Internals</a>
                <li><a href="index-platforms.html">Platforms</a>
              </ul>          </ul>
          <div class="clear"></div>
        </div>
      </div>
      <div id="footer_end">
      </div>
    </div>
      
    </div>
      <script language="JavaScript" type="text/javascript" src="static/exploreperl.js"></script>
      <script language="JavaScript" src="static/combined-20100403.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
  perldoc.setPath(0);
  perldoc.pageName    = 'perlretut';
  perldoc.pageAddress = 'perlretut.html';
  perldoc.contentPage = 1;
  explorePerl.render();
  explorePerl.addEvents('explore_anchor');
</script>
    
  </body>
</html>
