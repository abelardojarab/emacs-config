<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>Text::Balanced</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta http-equiv="Content-Language" content="en-gb">
  <link rel="search" type="application/opensearchdescription+xml" title="Search perldoc.perl.org" href="/static/search.xml"/>
  <link href="../static/css-20100830.css" rel="stylesheet" rev="stylesheet" type="text/css" media="screen">
  <link href="../static/exploreperl.css" rel="stylesheet" rev="stylesheet" type="text/css">
</head>

<body onLoad="perldoc.startup();" onPageShow="if (event.persisted) perldoc.startup();">
    <div id="page">
      
      <div id="header">
	<div id="homepage_link">
	  <a href="../index.html"></a>
	</div>
	<div id="strapline">
	  Perl Programming Documentation
	</div>
	<div id="download_link" class="download">
	  <a href="http://www.perl.org/get.html">Download Perl</a>
	</div>
	<div id="explore_link" class="download">
	  <a id="explore_anchor" href="#">Explore</a>
	</div>
      </div>
      
      <div id="body">
        <div id="left_column">
          <div class="side_group">
            
	    <div class="side_panel doc_panel">
              <p>Manual</p>
              <ul>
                <li><a href="../index-overview.html">Overview</a>
                <li><a href="../index-tutorials.html">Tutorials</a>
                <li><a href="../index-faq.html">FAQs</a>
                <li><a href="../index-history.html">History / Changes</a>
                <li><a href="../index-licence.html">License</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Reference</p>
              <ul>
                <li><a href="../index-language.html">Language</a>
                <li><a href="../index-functions.html">Functions</a>
                <li><a href="../perlop.html">Operators</a>
                <li><a href="../perlvar.html">Special Variables</a>
                <li><a href="../index-pragmas.html">Pragmas</a>
                <li><a href="../index-utilities.html">Utilities</a>
                <li><a href="../index-internals.html">Internals</a>
                <li><a href="../index-platforms.html">Platform Specific</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Modules</p>
              <ul>
		<li>
		
                
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		
                  
		
		
                    <a href="../index-modules-A.html">A</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-B.html">B</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-C.html">C</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-D.html">D</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-E.html">E</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="../index-modules-F.html">F</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-G.html">G</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-H.html">H</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-I.html">I</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-L.html">L</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="../index-modules-M.html">M</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-N.html">N</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-O.html">O</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-P.html">P</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-S.html">S</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="../index-modules-T.html">T</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-U.html">U</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="../index-modules-X.html">X</a>
                    
                
              </ul>
            </div>
            
	      <div class="side_panel doc_panel">
		<p>Tools</p>
		<ul>
		  <li><a href="../preferences.html">Preferences</a>
		</ul>
	      </div>
            
          </div>
        </div>
        <div id="centre_column">
          <div id="content_header">
            <div id="title_bar">
              <div id="page_name">
                <h1>Text::Balanced</h1>
              </div>
              <div id="perl_version">
                Perl 5 version 22.0 documentation
              </div>
              <div class="page_links" id="page_links_top">
                <a href="#" onClick="toolbar.goToTop();return false;">Go to top</a>
		
              </div>
	      <div class="page_links" id="page_links_bottom">
		
                  <a href="#" id="page_index_toggle">Show page index</a> &bull;
		
                <a href="#" id="recent_pages_toggle">Show recent pages</a>		
	      </div>
	      <div id="search_form">
		<form action="../search.html" method="GET" id="search">
		  <input type="text" name="q" id="search_box" alt="Search">
		</form>
	      </div>
            </div>
            <div id="breadcrumbs">
                
    <a href="../index.html">Home</a> &gt;
    
      
        <a href="../index-modules-T.html">Core modules (T)</a> &gt;
      
    
    Text::Balanced
  

            </div>
          </div>
          <div id="content_body">
	    <!--[if lt IE 7]>
 <div class="noscript">
   <p>
     <strong>It looks like you're using Internet Explorer 6. This is a very old
     browser which does not offer full support for modern websites.</strong>
   </p>
   <p>
     Unfortunately this means that this website will not work on
     your computer.
   </p>
   <p>
     Don't miss out though! To view the site (and get a better experience from
     many other websites), simply upgrade to
     <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet
Explorer 8</a>
     or download an alternative browser such as
     <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>,
     <a href="http://www.apple.com/safari/download/">Safari</a>, or
     <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
   </p>
   <p>
     All of these browsers are free. If you're using a PC at work, you may
     need to contact your IT administrator.
   </p>
 </div>
<![endif]-->
	    <noscript>
	      <div class="noscript">
	      <p>
                <strong>Please note: Many features of this site require JavaScript. You appear to have JavaScript disabled,
	        or are running a non-JavaScript capable web browser.</strong>
	      </p>
	      <p>
		To get the best experience, please enable JavaScript or download a modern web browser such as <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet Explorer 8</a>, <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>, <a href="http://www.apple.com/safari/download/">Safari</a>, or <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
              </p>
	      </div>
	    </noscript>

	    <div id="recent_pages" class="hud_container">
	      <div id="recent_pages_header" class="hud_header">
		<div id="recent_pages_close" class="hud_close"><a href="#" onClick="recentPages.hide();return false;"></a></div>
		<div id="recent_pages_title" class="hud_title"><span class="hud_span_top">Recently read</span></div>
		<div id="recent_pages_topright" class="hud_topright"></div>
	      </div>
	      <div id="recent_pages_content" class="hud_content">
	      </div>
	      <div id="recent_pages_footer" class="hud_footer">
		<div id="recent_pages_bottomleft" class="hud_bottomleft"></div>
		<div id="recent_pages_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
		<div id="recent_pages_resize" class="hud_resize"></div>
	      </div>
	    </div>
  
	    <div id="from_search"></div>
            <h1>Text::Balanced</h1>


  <!--    -->
<ul><li><a href="#NAME">NAME</a><li><a href="#SYNOPSIS">SYNOPSIS</a><li><a href="#DESCRIPTION">DESCRIPTION</a><ul><li><a href="#General-behaviour-in-list-contexts">General behaviour in list contexts</a><li><a href="#General-behaviour-in-scalar-and-void-contexts">General behaviour in scalar and void contexts</a><li><a href="#A-note-about-prefixes">A note about prefixes</a><li><a href="#extract_delimited">extract_delimited</a><li><a href="#extract_bracketed">extract_bracketed</a><li><a href="#extract_variable">extract_variable</a><li><a href="#extract_tagged">extract_tagged</a><li><a href="#gen_extract_tagged">gen_extract_tagged</a><li><a href="#extract_quotelike">extract_quotelike</a><li><a href="#extract_quotelike-and-%22here-documents%22">extract_quotelike and "here documents"</a><li><a href="#extract_codeblock">extract_codeblock</a><li><a href="#extract_multiple">extract_multiple</a><li><a href="#gen_delimited_pat">gen_delimited_pat</a><li><a href="#delimited_pat">delimited_pat</a></ul><li><a href="#DIAGNOSTICS">DIAGNOSTICS</a><li><a href="#AUTHOR">AUTHOR</a><li><a href="#BUGS-AND-IRRITATIONS">BUGS AND IRRITATIONS</a><li><a href="#COPYRIGHT">COPYRIGHT</a></ul><a name="NAME"></a><h1>NAME</h1>
<p>Text::Balanced - Extract delimited text sequences from strings.</p>
<a name="SYNOPSIS"></a><h1>SYNOPSIS</h1>
<pre class="verbatim"><ol><li> <a class="l_k" href="../functions/use.html">use</a> <span class="w">Text::Balanced</span> <span class="q">qw (</span></li><li>			<span class="q">extract_delimited</span></li><li>			<span class="q">extract_bracketed</span></li><li>			<span class="q">extract_quotelike</span></li><li>			<span class="q">extract_codeblock</span></li><li>			<span class="q">extract_variable</span></li><li>			<span class="q">extract_tagged</span></li><li>			<span class="q">extract_multiple</span></li><li>			<span class="q">gen_delimited_pat</span></li><li>			<span class="q">gen_extract_tagged</span></li><li>		       <span class="q">)</span><span class="sc">;</span></li><li></li><li> <span class="c"># Extract the initial substring of $text that is delimited by</span></li><li> <span class="c"># two (unescaped) instances of the first character in $delim.</span></li><li></li><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span> <span class="i">$remainder</span><span class="s">)</span> = <span class="i">extract_delimited</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span><span class="i">$delim</span><span class="s">)</span><span class="sc">;</span></li><li></li><li></li><li> <span class="c"># Extract the initial substring of $text that is bracketed</span></li><li> <span class="c"># with a delimiter(s) specified by $delim (where the string</span></li><li> <span class="c"># in $delim contains one or more of &#39;(){}[]&lt;&gt;&#39;).</span></li><li></li><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span> <span class="i">$remainder</span><span class="s">)</span> = <span class="i">extract_bracketed</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span><span class="i">$delim</span><span class="s">)</span><span class="sc">;</span></li><li></li><li></li><li> <span class="c"># Extract the initial substring of $text that is bounded by</span></li><li> <span class="c"># an XML tag.</span></li><li></li><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span> <span class="i">$remainder</span><span class="s">)</span> = <span class="i">extract_tagged</span><span class="s">(</span><span class="i">$text</span><span class="s">)</span><span class="sc">;</span></li><li></li><li></li><li> <span class="c"># Extract the initial substring of $text that is bounded by</span></li><li> <span class="c"># a C&lt;BEGIN&gt;...C&lt;END&gt; pair. Don&#39;t allow nested C&lt;BEGIN&gt; tags</span></li><li></li><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span> <span class="i">$remainder</span><span class="s">)</span> =</li><li>		<span class="i">extract_tagged</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span><span class="q">&quot;BEGIN&quot;</span><span class="cm">,</span><span class="q">&quot;END&quot;</span><span class="cm">,</span><a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span><span class="s">{</span><span class="w">bad</span><span class="cm">=&gt;</span><span class="s">[</span><span class="q">&quot;BEGIN&quot;</span><span class="s">]</span><span class="s">}</span><span class="s">)</span><span class="sc">;</span></li><li></li><li></li><li> <span class="c"># Extract the initial substring of $text that represents a</span></li><li> <span class="c"># Perl &quot;quote or quote-like operation&quot;</span></li><li></li><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span> <span class="i">$remainder</span><span class="s">)</span> = <span class="i">extract_quotelike</span><span class="s">(</span><span class="i">$text</span><span class="s">)</span><span class="sc">;</span></li><li></li><li></li><li> <span class="c"># Extract the initial substring of $text that represents a block</span></li><li> <span class="c"># of Perl code, bracketed by any of character(s) specified by $delim</span></li><li> <span class="c"># (where the string $delim contains one or more of &#39;(){}[]&lt;&gt;&#39;).</span></li><li></li><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span> <span class="i">$remainder</span><span class="s">)</span> = <span class="i">extract_codeblock</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span><span class="i">$delim</span><span class="s">)</span><span class="sc">;</span></li><li></li><li></li><li> <span class="c"># Extract the initial substrings of $text that would be extracted by</span></li><li> <span class="c"># one or more sequential applications of the specified functions</span></li><li> <span class="c"># or regular expressions</span></li><li></li><li>	<span class="i">@extracted</span> = <span class="i">extract_multiple</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span></li><li>				      <span class="s">[</span> \<span class="i">&amp;extract_bracketed</span><span class="cm">,</span></li><li>					\<span class="i">&amp;extract_quotelike</span><span class="cm">,</span></li><li>					\<span class="i">&amp;some_other_extractor_sub</span><span class="cm">,</span></li><li>					<span class="q">qr/[xyz]*/</span><span class="cm">,</span></li><li>					<span class="q">&#39;literal&#39;</span><span class="cm">,</span></li><li>				      <span class="s">]</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p># Create a string representing an optimized pattern (a la Friedl)
# that matches a substring delimited by any of the specified characters
# (in this case: any type of quote or a slash)</p>
<pre class="verbatim"><ol><li>	<span class="i">$patstring</span> = <span class="i">gen_delimited_pat</span><span class="s">(</span><span class="q">q{&#39;&quot;`/}</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p># Generate a reference to an anonymous sub that is just like extract_tagged
# but pre-compiled and optimized for a specific pair of tags, and consequently
# much faster (i.e. 3 times faster). It uses qr// for better performance on
# repeated calls, so it only works under Perl 5.005 or later.</p>
<pre class="verbatim"><ol><li>	<span class="i">$extract_head</span> = <span class="i">gen_extract_tagged</span><span class="s">(</span><span class="q">&#39;&lt;HEAD&gt;&#39;</span><span class="cm">,</span><span class="q">&#39;&lt;/HEAD&gt;&#39;</span><span class="s">)</span><span class="sc">;</span></li><li></li><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span> <span class="i">$remainder</span><span class="s">)</span> = <span class="i">$extract_head</span>-&gt;<span class="s">(</span><span class="i">$text</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><a name="DESCRIPTION"></a><h1>DESCRIPTION</h1>
<p>The various <code class="inline"><span class="w">extract_</span>...</code>
 subroutines may be used to
extract a delimited substring, possibly after skipping a
specified prefix string. By default, that prefix is
optional whitespace (<code class="inline"><span class="q">/\s*/</span></code>
), but you can change it to whatever
you wish (see below).</p>
<p>The substring to be extracted must appear at the
current <code class="inline"><a class="l_k" href="../functions/pos.html">pos</a></code> location of the string's variable
(or at index zero, if no <code class="inline"><a class="l_k" href="../functions/pos.html">pos</a></code> position is defined).
In other words, the <code class="inline"><span class="w">extract_</span>...</code>
 subroutines <i>don't</i>
extract the first occurrence of a substring anywhere
in a string (like an unanchored regex would). Rather,
they extract an occurrence of the substring appearing
immediately at the current matching position in the
string (like a <code class="inline">\<span class="w">G</span></code>
-anchored regex would).</p>
<a name="General-behaviour-in-list-contexts"></a><h2>General behaviour in list contexts</h2>
<p>In a list context, all the subroutines return a list, the first three
elements of which are always:</p>
<ul>
<li><a name="%5b0%5d"></a><b>[0]</b>
<p>The extracted string, including the specified delimiters.
If the extraction fails <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code> is returned.</p>
</li>
<li><a name="%5b1%5d"></a><b>[1]</b>
<p>The remainder of the input string (i.e. the characters after the
extracted string). On failure, the entire string is returned.</p>
</li>
<li><a name="%5b2%5d"></a><b>[2]</b>
<p>The skipped prefix (i.e. the characters before the extracted string).
On failure, <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code> is returned.</p>
</li>
</ul>
<p>Note that in a list context, the contents of the original input text (the first
argument) are not modified in any way.</p>
<p>However, if the input text was passed in a variable, that variable's
<code class="inline"><a class="l_k" href="../functions/pos.html">pos</a></code> value is updated to point at the first character after the
extracted text. That means that in a list context the various
subroutines can be used much like regular expressions. For example:</p>
<pre class="verbatim"><ol><li>	while <span class="s">(</span> <span class="i">$next</span> = <span class="s">(</span><span class="i">extract_quotelike</span><span class="s">(</span><span class="i">$text</span><span class="s">)</span><span class="s">)</span>[<span class="n">0</span>] <span class="s">)</span></li><li>	<span class="s">{</span></li><li>		<span class="c"># process next quote-like (in $next)</span></li><li>	<span class="s">}</span></li></ol></pre><a name="General-behaviour-in-scalar-and-void-contexts"></a><h2>General behaviour in scalar and void contexts</h2>
<p>In a scalar context, the extracted string is returned, having first been
removed from the input text. Thus, the following code also processes
each quote-like operation, but actually removes them from $text:</p>
<pre class="verbatim"><ol><li>	while <span class="s">(</span> <span class="i">$next</span> = <span class="i">extract_quotelike</span><span class="s">(</span><span class="i">$text</span><span class="s">)</span> <span class="s">)</span></li><li>	<span class="s">{</span></li><li>		<span class="c"># process next quote-like (in $next)</span></li><li>	<span class="s">}</span></li></ol></pre><p>Note that if the input text is a read-only string (i.e. a literal),
no attempt is made to remove the extracted text.</p>
<p>In a void context the behaviour of the extraction subroutines is
exactly the same as in a scalar context, except (of course) that the
extracted substring is not returned.</p>
<a name="A-note-about-prefixes"></a><h2>A note about prefixes</h2>
<p>Prefix patterns are matched without any trailing modifiers (<code class="inline">/gimsox</code> etc.)
This can bite you if you're expecting a prefix specification like
'.*?(?=&lt;H1&gt;)' to skip everything up to the first &lt;H1&gt; tag. Such a prefix
pattern will only succeed if the &lt;H1&gt; tag is on the current line, since
. normally doesn't match newlines.</p>
<p>To overcome this limitation, you need to turn on /s matching within
the prefix pattern, using the <code class="inline">(?s)</code> directive: '(?s).*?(?=&lt;H1&gt;)'</p>
<a name="extract_delimited"></a><h2><code class="inline"><span class="w">extract_delimited</span></code>
</h2>
<p>The <code class="inline"><span class="w">extract_delimited</span></code>
 function formalizes the common idiom
of extracting a single-character-delimited substring from the start of
a string. For example, to extract a single-quote delimited string, the
following code is typically used:</p>
<pre class="verbatim"><ol><li>	<span class="s">(</span><span class="i">$remainder</span> = <span class="i">$text</span><span class="s">)</span> =~ <span class="q">s/\A(&#39;(\\.|[^&#39;])*&#39;)//s</span><span class="sc">;</span></li><li>	<span class="i">$extracted</span> = <span class="i">$1</span><span class="sc">;</span></li></ol></pre><p>but with <code class="inline"><span class="w">extract_delimited</span></code>
 it can be simplified to:</p>
<pre class="verbatim"><ol><li>	<span class="s">(</span><span class="i">$extracted</span><span class="cm">,</span><span class="i">$remainder</span><span class="s">)</span> = <span class="i">extract_delimited</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span> <span class="q">&quot;&#39;&quot;</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p><code class="inline"><span class="w">extract_delimited</span></code>
 takes up to four scalars (the input text, the
delimiters, a prefix pattern to be skipped, and any escape characters)
and extracts the initial substring of the text that
is appropriately delimited. If the delimiter string has multiple
characters, the first one encountered in the text is taken to delimit
the substring.
The third argument specifies a prefix pattern that is to be skipped
(but must be present!) before the substring is extracted.
The final argument specifies the escape character to be used for each
delimiter.</p>
<p>All arguments are optional. If the escape characters are not specified,
every delimiter is escaped with a backslash (<code class="inline">\</code>
).
If the prefix is not specified, the
pattern <code class="inline"><span class="q">&#39;\s*&#39;</span></code>
 - optional whitespace - is used. If the delimiter set
is also not specified, the set <code class="inline"><span class="q">/[&quot;&#39;`]/</span></code>
 is used. If the text to be processed
is not specified either, <code class="inline"><span class="i">$_</span></code>
 is used.</p>
<p>In list context, <code class="inline"><span class="w">extract_delimited</span></code>
 returns a array of three
elements, the extracted substring (<i>including the surrounding
delimiters</i>), the remainder of the text, and the skipped prefix (if
any). If a suitable delimited substring is not found, the first
element of the array is the empty string, the second is the complete
original text, and the prefix returned in the third element is an
empty string.</p>
<p>In a scalar context, just the extracted substring is returned. In
a void context, the extracted substring (and any prefix) are simply
removed from the beginning of the first argument.</p>
<p>Examples:</p>
<pre class="verbatim"><ol><li>	# Remove a single-quoted substring from the very beginning of $text:</li><li></li><li>		$substring = extract_delimited($text, "'", '');</li><li></li><li>	# Remove a single-quoted Pascalish substring (i.e. one in which</li><li>	# doubling the quote character escapes it) from the very</li><li>	# beginning of $text:</li><li></li><li>		$substring = extract_delimited($text, "'", '', "'");</li><li></li><li>	# Extract a single- or double- quoted substring from the</li><li>	# beginning of $text, optionally after some whitespace</li><li>	# (note the list context to protect $text from modification):</li><li></li><li>		($substring) = extract_delimited $text, q{"'};</li><li></li><li>	# Delete the substring delimited by the first '/' in $text:</li><li></li><li>		$text = join '', (extract_delimited($text,'/','[^/]*')[2,1];</li></ol></pre><p>Note that this last example is <i>not</i> the same as deleting the first
quote-like pattern. For instance, if <code class="inline"><span class="i">$text</span></code>
 contained the string:</p>
<pre class="verbatim"><ol><li>	<span class="q">&quot;if (&#39;./cmd&#39; =~ m/$UNIXCMD/s) { $cmd = $1; }&quot;</span></li></ol></pre><p>then after the deletion it would contain:</p>
<pre class="verbatim"><ol><li>	<span class="q">&quot;if (&#39;.$UNIXCMD/s) { $cmd = $1; }&quot;</span></li></ol></pre><p>not:</p>
<pre class="verbatim"><ol><li>	<span class="q">&quot;if (&#39;./cmd&#39; =~ ms) { $cmd = $1; }&quot;</span></li></ol></pre><p>See <a href="#extract_quotelike">extract_quotelike</a> for a (partial) solution to this problem.</p>
<a name="extract_bracketed"></a><h2><code class="inline"><span class="w">extract_bracketed</span></code>
</h2>
<p>Like <code class="inline"><span class="q">&quot;extract_delimited&quot;</span></code>
, the <code class="inline"><span class="w">extract_bracketed</span></code>
 function takes
up to three optional scalar arguments: a string to extract from, a delimiter
specifier, and a prefix pattern. As before, a missing prefix defaults to
optional whitespace and a missing text defaults to <code class="inline"><span class="i">$_</span></code>
. However, a missing
delimiter specifier defaults to <code class="inline"><span class="q">&#39;{}()[]&lt;&gt;&#39;</span></code>
 (see below).</p>
<p><code class="inline"><span class="w">extract_bracketed</span></code>
 extracts a balanced-bracket-delimited
substring (using any one (or more) of the user-specified delimiter
brackets: '(..)', '{..}', '[..]', or '&lt;..&gt;'). Optionally it will also
respect quoted unbalanced brackets (see below).</p>
<p>A "delimiter bracket" is a bracket in list of delimiters passed as
<code class="inline"><span class="w">extract_bracketed</span></code>
's second argument. Delimiter brackets are
specified by giving either the left or right (or both!) versions
of the required bracket(s). Note that the order in which
two or more delimiter brackets are specified is not significant.</p>
<p>A "balanced-bracket-delimited substring" is a substring bounded by
matched brackets, such that any other (left or right) delimiter
bracket <i>within</i> the substring is also matched by an opposite
(right or left) delimiter bracket <i>at the same level of nesting</i>. Any
type of bracket not in the delimiter list is treated as an ordinary
character.</p>
<p>In other words, each type of bracket specified as a delimiter must be
balanced and correctly nested within the substring, and any other kind of
("non-delimiter") bracket in the substring is ignored.</p>
<p>For example, given the string:</p>
<pre class="verbatim"><ol><li>	<span class="i">$text</span> = <span class="q">&quot;{ an &#39;[irregularly :-(] {} parenthesized &gt;:-)&#39; string }&quot;</span><span class="sc">;</span></li></ol></pre><p>then a call to <code class="inline"><span class="w">extract_bracketed</span></code>
 in a list context:</p>
<pre class="verbatim"><ol><li>	<span class="i">@result</span> = <span class="i">extract_bracketed</span><span class="s">(</span> <span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;{}&#39;</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>would return:</p>
<pre class="verbatim"><ol><li>	<span class="s">(</span> <span class="q">&quot;{ an &#39;[irregularly :-(] {} parenthesized &gt;:-)&#39; string }&quot;</span> <span class="cm">,</span> <span class="q">&quot;&quot;</span> <span class="cm">,</span> <span class="q">&quot;&quot;</span> <span class="s">)</span></li></ol></pre><p>since both sets of <code class="inline"><span class="q">&#39;{..}&#39;</span></code>
 brackets are properly nested and evenly balanced.
(In a scalar context just the first element of the array would be returned. In
a void context, <code class="inline"><span class="i">$text</span></code>
 would be replaced by an empty string.)</p>
<p>Likewise the call in:</p>
<pre class="verbatim"><ol><li>	<span class="i">@result</span> = <span class="i">extract_bracketed</span><span class="s">(</span> <span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;{[&#39;</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>would return the same result, since all sets of both types of specified
delimiter brackets are correctly nested and balanced.</p>
<p>However, the call in:</p>
<pre class="verbatim"><ol><li>	<span class="i">@result</span> = <span class="i">extract_bracketed</span><span class="s">(</span> <span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;{([&lt;&#39;</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>would fail, returning:</p>
<pre class="verbatim"><ol><li>	<span class="s">(</span> <a class="l_k" href="../functions/undef.html">undef</a> <span class="cm">,</span> <span class="q">&quot;{ an &#39;[irregularly :-(] {} parenthesized &gt;:-)&#39; string }&quot;</span>  <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>because the embedded pairs of <code class="inline"><span class="q">&#39;(..)&#39;</span></code>
s and <code class="inline"><span class="q">&#39;[..]&#39;</span></code>
s are "cross-nested" and
the embedded <code class="inline"><span class="q">&#39;&gt;&#39;</span></code>
 is unbalanced. (In a scalar context, this call would
return an empty string. In a void context, <code class="inline"><span class="i">$text</span></code>
 would be unchanged.)</p>
<p>Note that the embedded single-quotes in the string don't help in this
case, since they have not been specified as acceptable delimiters and are
therefore treated as non-delimiter characters (and ignored).</p>
<p>However, if a particular species of quote character is included in the
delimiter specification, then that type of quote will be correctly handled.
for example, if <code class="inline"><span class="i">$text</span></code>
 is:</p>
<pre class="verbatim"><ol><li>	<span class="i">$text</span> = <span class="q">&#39;&lt;A HREF=&quot;&gt;&gt;&gt;&gt;&quot;&gt;link&lt;/A&gt;&#39;</span><span class="sc">;</span></li></ol></pre><p>then</p>
<pre class="verbatim"><ol><li>	<span class="i">@result</span> = <span class="i">extract_bracketed</span><span class="s">(</span> <span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;&lt;&quot;&gt;&#39;</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>returns:</p>
<pre class="verbatim"><ol><li>	<span class="s">(</span> <span class="q">&#39;&lt;A HREF=&quot;&gt;&gt;&gt;&gt;&quot;&gt;&#39;</span><span class="cm">,</span> <span class="q">&#39;link&lt;/A&gt;&#39;</span><span class="cm">,</span> <span class="q">&quot;&quot;</span> <span class="s">)</span></li></ol></pre><p>as expected. Without the specification of <code class="inline">"</code> as an embedded quoter:</p>
<pre class="verbatim"><ol><li>	<span class="i">@result</span> = <span class="i">extract_bracketed</span><span class="s">(</span> <span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;&lt;&gt;&#39;</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>the result would be:</p>
<pre class="verbatim"><ol><li>	<span class="s">(</span> <span class="q">&#39;&lt;A HREF=&quot;&gt;&#39;</span><span class="cm">,</span> <span class="q">&#39;&gt;&gt;&gt;&quot;&gt;link&lt;/A&gt;&#39;</span><span class="cm">,</span> <span class="q">&quot;&quot;</span> <span class="s">)</span></li></ol></pre><p>In addition to the quote delimiters <code class="inline">'</code>, <code class="inline">"</code>, and <code class="inline">`</code>, full Perl quote-like
quoting (i.e. q{string}, qq{string}, etc) can be specified by including the
letter 'q' as a delimiter. Hence:</p>
<pre class="verbatim"><ol><li>	<span class="i">@result</span> = <span class="i">extract_bracketed</span><span class="s">(</span> <span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;&lt;q&gt;&#39;</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>would correctly match something like this:</p>
<pre class="verbatim"><ol><li>	<span class="i">$text</span> = <span class="q">&#39;&lt;leftop: conj /and/ conj&gt;&#39;</span><span class="sc">;</span></li></ol></pre><p>See also: <code class="inline"><span class="q">&quot;extract_quotelike&quot;</span></code>
 and <code class="inline"><span class="q">&quot;extract_codeblock&quot;</span></code>
.</p>
<a name="extract_variable"></a><h2><code class="inline"><span class="w">extract_variable</span></code>
</h2>
<p><code class="inline"><span class="w">extract_variable</span></code>
 extracts any valid Perl variable or
variable-involved expression, including scalars, arrays, hashes, array
accesses, hash look-ups, method calls through objects, subroutine calls
through subroutine references, etc.</p>
<p>The subroutine takes up to two optional arguments:</p>
<dl>
<dt>1.</dt><dd>
<p>A string to be processed (<code class="inline"><span class="i">$_</span></code>
 if the string is omitted or <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>)</p>
</dd>
<dt>2.</dt><dd>
<p>A string specifying a pattern to be matched as a prefix (which is to be
skipped). If omitted, optional whitespace is skipped.</p>
</dd>
</dl>
<p>On success in a list context, an array of 3 elements is returned. The
elements are:</p>
<ul>
<li><a name="%5b0%5d"></a><b>[0]</b>
<p>the extracted variable, or variablish expression</p>
</li>
<li><a name="%5b1%5d"></a><b>[1]</b>
<p>the remainder of the input text,</p>
</li>
<li><a name="%5b2%5d"></a><b>[2]</b>
<p>the prefix substring (if any),</p>
</li>
</ul>
<p>On failure, all of these values (except the remaining text) are <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>.</p>
<p>In a scalar context, <code class="inline"><span class="w">extract_variable</span></code>
 returns just the complete
substring that matched a variablish expression. <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code> is returned on
failure. In addition, the original input text has the returned substring
(and any prefix) removed from it.</p>
<p>In a void context, the input text just has the matched substring (and
any specified prefix) removed.</p>
<a name="extract_tagged"></a><h2><code class="inline"><span class="w">extract_tagged</span></code>
</h2>
<p><code class="inline"><span class="w">extract_tagged</span></code>
 extracts and segments text between (balanced)
specified tags.</p>
<p>The subroutine takes up to five optional arguments:</p>
<dl>
<dt>1.</dt><dd>
<p>A string to be processed (<code class="inline"><span class="i">$_</span></code>
 if the string is omitted or <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>)</p>
</dd>
<dt>2.</dt><dd>
<p>A string specifying a pattern to be matched as the opening tag.
If the pattern string is omitted (or <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>) then a pattern
that matches any standard XML tag is used.</p>
</dd>
<dt>3.</dt><dd>
<p>A string specifying a pattern to be matched at the closing tag. 
If the pattern string is omitted (or <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>) then the closing
tag is constructed by inserting a <code class="inline">/</code> after any leading bracket
characters in the actual opening tag that was matched (<i>not</i> the pattern
that matched the tag). For example, if the opening tag pattern
is specified as <code class="inline"><span class="q">&#39;{{\w+}}&#39;</span></code>
 and actually matched the opening tag 
<code class="inline"><span class="q">&quot;{{DATA}}&quot;</span></code>
, then the constructed closing tag would be <code class="inline"><span class="q">&quot;{{/DATA}}&quot;</span></code>
.</p>
</dd>
<dt>4.</dt><dd>
<p>A string specifying a pattern to be matched as a prefix (which is to be
skipped). If omitted, optional whitespace is skipped.</p>
</dd>
<dt>5.</dt><dd>
<p>A hash reference containing various parsing options (see below)</p>
</dd>
</dl>
<p>The various options that can be specified are:</p>
<ul>
<li><a name="reject-%3d%3e-%24listref"></a><b><code class="inline"><span class="w">reject</span> <span class="cm">=&gt;</span> <span class="i">$listref</span></code>
</b>
<p>The list reference contains one or more strings specifying patterns
that must <i>not</i> appear within the tagged text.</p>
<p>For example, to extract
an HTML link (which should not contain nested links) use:</p>
<pre class="verbatim"><ol><li>        <span class="i">extract_tagged</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;&lt;A&gt;&#39;</span><span class="cm">,</span> <span class="q">&#39;&lt;/A&gt;&#39;</span><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <span class="s">{</span><span class="w">reject</span> <span class="cm">=&gt;</span> <span class="s">[</span><span class="q">&#39;&lt;A&gt;&#39;</span><span class="s">]</span><span class="s">}</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre></li>
<li><a name="ignore-%3d%3e-%24listref"></a><b><code class="inline"><span class="w">ignore</span> <span class="cm">=&gt;</span> <span class="i">$listref</span></code>
</b>
<p>The list reference contains one or more strings specifying patterns
that are <i>not</i> be be treated as nested tags within the tagged text
(even if they would match the start tag pattern).</p>
<p>For example, to extract an arbitrary XML tag, but ignore "empty" elements:</p>
<pre class="verbatim"><ol><li>        <span class="i">extract_tagged</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <span class="s">{</span><span class="w">ignore</span> <span class="cm">=&gt;</span> <span class="s">[</span><span class="q">&#39;&lt;[^&gt;]*/&gt;&#39;</span><span class="s">]</span><span class="s">}</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>(also see <a href="#gen_delimited_pat">gen_delimited_pat</a> below).</p>
</li>
<li><a name="fail-%3d%3e-%24str"></a><b><code class="inline"><span class="w">fail</span> <span class="cm">=&gt;</span> <span class="i">$str</span></code>
</b>
<p>The <code class="inline"><span class="w">fail</span></code>
 option indicates the action to be taken if a matching end
tag is not encountered (i.e. before the end of the string or some
<code class="inline"><span class="w">reject</span></code>
 pattern matches). By default, a failure to match a closing
tag causes <code class="inline"><span class="w">extract_tagged</span></code>
 to immediately fail.</p>
<p>However, if the string value associated with &lt;reject&gt; is "MAX", then
<code class="inline"><span class="w">extract_tagged</span></code>
 returns the complete text up to the point of failure.
If the string is "PARA", <code class="inline"><span class="w">extract_tagged</span></code>
 returns only the first paragraph
after the tag (up to the first line that is either empty or contains
only whitespace characters).
If the string is "", the the default behaviour (i.e. failure) is reinstated.</p>
<p>For example, suppose the start tag "/para" introduces a paragraph, which then
continues until the next "/endpara" tag or until another "/para" tag is
encountered:</p>
<pre class="verbatim"><ol><li>        $text = "/para line 1\n\nline 3\n/para line 4";</li><li></li><li>        extract_tagged($text, '/para', '/endpara', undef,</li><li>                                {reject =&gt; '/para', fail =&gt; MAX );</li><li></li><li>        # EXTRACTED: "/para line 1\n\nline 3\n"</li></ol></pre><p>Suppose instead, that if no matching "/endpara" tag is found, the "/para"
tag refers only to the immediately following paragraph:</p>
<pre class="verbatim"><ol><li>        $text = "/para line 1\n\nline 3\n/para line 4";</li><li></li><li>        extract_tagged($text, '/para', '/endpara', undef,</li><li>                        {reject =&gt; '/para', fail =&gt; MAX );</li><li></li><li>        # EXTRACTED: "/para line 1\n"</li></ol></pre><p>Note that the specified <code class="inline"><span class="w">fail</span></code>
 behaviour applies to nested tags as well.</p>
</li>
</ul>
<p>On success in a list context, an array of 6 elements is returned. The elements are:</p>
<ul>
<li><a name="%5b0%5d"></a><b>[0]</b>
<p>the extracted tagged substring (including the outermost tags),</p>
</li>
<li><a name="%5b1%5d"></a><b>[1]</b>
<p>the remainder of the input text,</p>
</li>
<li><a name="%5b2%5d"></a><b>[2]</b>
<p>the prefix substring (if any),</p>
</li>
<li><a name="%5b3%5d"></a><b>[3]</b>
<p>the opening tag</p>
</li>
<li><a name="%5b4%5d"></a><b>[4]</b>
<p>the text between the opening and closing tags</p>
</li>
<li><a name="%5b5%5d"></a><b>[5]</b>
<p>the closing tag (or "" if no closing tag was found)</p>
</li>
</ul>
<p>On failure, all of these values (except the remaining text) are <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>.</p>
<p>In a scalar context, <code class="inline"><span class="w">extract_tagged</span></code>
 returns just the complete
substring that matched a tagged text (including the start and end
tags). <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code> is returned on failure. In addition, the original input
text has the returned substring (and any prefix) removed from it.</p>
<p>In a void context, the input text just has the matched substring (and
any specified prefix) removed.</p>
<a name="gen_extract_tagged"></a><h2><code class="inline"><span class="w">gen_extract_tagged</span></code>
</h2>
<p>(Note: This subroutine is only available under Perl5.005)</p>
<p><code class="inline"><span class="w">gen_extract_tagged</span></code>
 generates a new anonymous subroutine which
extracts text between (balanced) specified tags. In other words,
it generates a function identical in function to <code class="inline"><span class="w">extract_tagged</span></code>
.</p>
<p>The difference between <code class="inline"><span class="w">extract_tagged</span></code>
 and the anonymous
subroutines generated by
<code class="inline"><span class="w">gen_extract_tagged</span></code>
, is that those generated subroutines:</p>
<ul>
<li>
<p>do not have to reparse tag specification or parsing options every time
they are called (whereas <code class="inline"><span class="w">extract_tagged</span></code>
 has to effectively rebuild
its tag parser on every call);</p>
</li>
<li>
<p>make use of the new qr// construct to pre-compile the regexes they use
(whereas <code class="inline"><span class="w">extract_tagged</span></code>
 uses standard string variable interpolation 
to create tag-matching patterns).</p>
</li>
</ul>
<p>The subroutine takes up to four optional arguments (the same set as
<code class="inline"><span class="w">extract_tagged</span></code>
 except for the string to be processed). It returns
a reference to a subroutine which in turn takes a single argument (the text to
be extracted from).</p>
<p>In other words, the implementation of <code class="inline"><span class="w">extract_tagged</span></code>
 is exactly
equivalent to:</p>
<pre class="verbatim"><ol><li><a name="extract_tagged"></a>        sub <span class="m">extract_tagged</span></li><li>        <span class="s">{</span></li><li>                <a class="l_k" href="../functions/my.html">my</a> <span class="i">$text</span> = <a class="l_k" href="../functions/shift.html">shift</a><span class="sc">;</span></li><li>                <span class="i">$extractor</span> = <span class="i">gen_extract_tagged</span><span class="s">(</span><span class="i">@_</span><span class="s">)</span><span class="sc">;</span></li><li>                <a class="l_k" href="../functions/return.html">return</a> <span class="i">$extractor</span>-&gt;<span class="s">(</span><span class="i">$text</span><span class="s">)</span><span class="sc">;</span></li><li>        <span class="s">}</span></li></ol></pre><p>(although <code class="inline"><span class="w">extract_tagged</span></code>
 is not currently implemented that way, in order
to preserve pre-5.005 compatibility).</p>
<p>Using <code class="inline"><span class="w">gen_extract_tagged</span></code>
 to create extraction functions for specific tags 
is a good idea if those functions are going to be called more than once, since
their performance is typically twice as good as the more general-purpose
<code class="inline"><span class="w">extract_tagged</span></code>
.</p>
<a name="extract_quotelike"></a><h2><code class="inline"><span class="w">extract_quotelike</span></code>
</h2>
<p><code class="inline"><span class="w">extract_quotelike</span></code>
 attempts to recognize, extract, and segment any
one of the various Perl quotes and quotelike operators (see
<i>perlop(3)</i>) Nested backslashed delimiters, embedded balanced bracket
delimiters (for the quotelike operators), and trailing modifiers are
all caught. For example, in:</p>
<pre class="verbatim"><ol><li>        extract_quotelike 'q # an octothorpe: \# (not the end of the q!) #'</li><li>        </li><li>        extract_quotelike '  "You said, \"Use sed\"."  '</li><li></li><li>        extract_quotelike ' s{([A-Z]{1,8}\.[A-Z]{3})} /\L$1\E/; '</li><li></li><li>        extract_quotelike ' tr/\\\/\\\\/\\\//ds; '</li></ol></pre><p>the full Perl quotelike operations are all extracted correctly.</p>
<p>Note too that, when using the /x modifier on a regex, any comment
containing the current pattern delimiter will cause the regex to be
immediately terminated. In other words:</p>
<pre class="verbatim"><ol><li>        <span class="q">&#39;m /</span></li><li>                <span class="q">                (?i)            # CASE INSENSITIVE</span></li><li>                <span class="q">                [a-z_]          # LEADING ALPHABETIC/UNDERSCORE</span></li><li>                <span class="q">                [a-z0-9]*       # FOLLOWED BY ANY NUMBER OF ALPHANUMERICS</span></li><li>           <span class="q">           /x&#39;</span></li></ol></pre><p>will be extracted as if it were:</p>
<pre class="verbatim"><ol><li>        <span class="q">&#39;m /</span></li><li>                <span class="q">                (?i)            # CASE INSENSITIVE</span></li><li>                <span class="q">                [a-z_]          # LEADING ALPHABETIC/&#39;</span></li></ol></pre><p>This behaviour is identical to that of the actual compiler.</p>
<p><code class="inline"><span class="w">extract_quotelike</span></code>
 takes two arguments: the text to be processed and
a prefix to be matched at the very beginning of the text. If no prefix 
is specified, optional whitespace is the default. If no text is given,
<code class="inline"><span class="i">$_</span></code>
 is used.</p>
<p>In a list context, an array of 11 elements is returned. The elements are:</p>
<ul>
<li><a name="%5b0%5d"></a><b>[0]</b>
<p>the extracted quotelike substring (including trailing modifiers),</p>
</li>
<li><a name="%5b1%5d"></a><b>[1]</b>
<p>the remainder of the input text,</p>
</li>
<li><a name="%5b2%5d"></a><b>[2]</b>
<p>the prefix substring (if any),</p>
</li>
<li><a name="%5b3%5d"></a><b>[3]</b>
<p>the name of the quotelike operator (if any),</p>
</li>
<li><a name="%5b4%5d"></a><b>[4]</b>
<p>the left delimiter of the first block of the operation,</p>
</li>
<li><a name="%5b5%5d"></a><b>[5]</b>
<p>the text of the first block of the operation
(that is, the contents of
a quote, the regex of a match or substitution or the target list of a
translation),</p>
</li>
<li><a name="%5b6%5d"></a><b>[6]</b>
<p>the right delimiter of the first block of the operation,</p>
</li>
<li><a name="%5b7%5d"></a><b>[7]</b>
<p>the left delimiter of the second block of the operation
(that is, if it is a <code class="inline"><a class="l_k" href="../functions/s.html">s</a></code>, <code class="inline"><a class="l_k" href="../functions/tr.html">tr</a></code>, or <code class="inline"><a class="l_k" href="../functions/y.html">y</a></code>),</p>
</li>
<li><a name="%5b8%5d"></a><b>[8]</b>
<p>the text of the second block of the operation 
(that is, the replacement of a substitution or the translation list
of a translation),</p>
</li>
<li><a name="%5b9%5d"></a><b>[9]</b>
<p>the right delimiter of the second block of the operation (if any),</p>
</li>
<li><a name="%5b10%5d"></a><b>[10]</b>
<p>the trailing modifiers on the operation (if any).</p>
</li>
</ul>
<p>For each of the fields marked "(if any)" the default value on success is
an empty string.
On failure, all of these values (except the remaining text) are <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>.</p>
<p>In a scalar context, <code class="inline"><span class="w">extract_quotelike</span></code>
 returns just the complete substring
that matched a quotelike operation (or <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code> on failure). In a scalar or
void context, the input text has the same substring (and any specified
prefix) removed.</p>
<p>Examples:</p>
<pre class="verbatim"><ol><li>        <span class="c"># Remove the first quotelike literal that appears in text</span></li><li></li><li>                <span class="i">$quotelike</span> = <span class="i">extract_quotelike</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span><span class="q">&#39;.*?&#39;</span><span class="s">)</span><span class="sc">;</span></li><li></li><li>        <span class="c"># Replace one or more leading whitespace-separated quotelike</span></li><li>        <span class="c"># literals in $_ with &quot;&lt;QLL&gt;&quot;</span></li><li></li><li>                <a class="l_k" href="../functions/do.html">do</a> <span class="s">{</span> <span class="i">$_</span> = <a class="l_k" href="../functions/join.html">join</a> <span class="q">&#39;&lt;QLL&gt;&#39;</span><span class="cm">,</span> <span class="s">(</span><span class="w">extract_quotelike</span><span class="s">)</span>[<span class="n">2</span><span class="cm">,</span><span class="n">1</span>] <span class="s">}</span> until <span class="i">$@</span><span class="sc">;</span></li><li></li><li></li><li>        <span class="c"># Isolate the search pattern in a quotelike operation from $text</span></li><li></li><li>                <span class="s">(</span><span class="i">$op</span><span class="cm">,</span><span class="i">$pat</span><span class="s">)</span> = <span class="s">(</span><span class="w">extract_quotelike</span> <span class="i">$text</span><span class="s">)</span>[<span class="n">3</span><span class="cm">,</span><span class="n">5</span>]<span class="sc">;</span></li><li>                if <span class="s">(</span><span class="i">$op</span> =~ <span class="q">/[ms]/</span><span class="s">)</span></li><li>                <span class="s">{</span></li><li>                        <a class="l_k" href="../functions/print.html">print</a> <span class="q">&quot;search pattern: $pat\n&quot;</span><span class="sc">;</span></li><li>                <span class="s">}</span></li><li>                else</li><li>                <span class="s">{</span></li><li>                        <a class="l_k" href="../functions/print.html">print</a> <span class="q">&quot;$op is not a pattern matching operation\n&quot;</span><span class="sc">;</span></li><li>                <span class="s">}</span></li></ol></pre><a name="extract_quotelike-and-%22here-documents%22"></a><h2><code class="inline"><span class="w">extract_quotelike</span></code>
 and "here documents"</h2>
<p><code class="inline"><span class="w">extract_quotelike</span></code>
 can successfully extract "here documents" from an input
string, but with an important caveat in list contexts.</p>
<p>Unlike other types of quote-like literals, a here document is rarely
a contiguous substring. For example, a typical piece of code using
here document might look like this:</p>
<pre class="verbatim"><ol><li>        &lt;&lt;'EOMSG' || die;</li><li>        This is the message.</li><li>        EOMSG</li><li>        exit;</li></ol></pre><p>Given this as an input string in a scalar context, <code class="inline"><span class="w">extract_quotelike</span></code>

would correctly return the string "&lt;&lt;'EOMSG'\nThis is the message.\nEOMSG",
leaving the string " || die;\nexit;" in the original variable. In other words,
the two separate pieces of the here document are successfully extracted and
concatenated.</p>
<p>In a list context, <code class="inline"><span class="w">extract_quotelike</span></code>
 would return the list</p>
<ul>
<li><a name="%5b0%5d"></a><b>[0]</b>
<p>"&lt;&lt;'EOMSG'\nThis is the message.\nEOMSG\n" (i.e. the full extracted here document,
including fore and aft delimiters),</p>
</li>
<li><a name="%5b1%5d"></a><b>[1]</b>
<p>" || die;\nexit;" (i.e. the remainder of the input text, concatenated),</p>
</li>
<li><a name="%5b2%5d"></a><b>[2]</b>
<p>"" (i.e. the prefix substring -- trivial in this case),</p>
</li>
<li><a name="%5b3%5d"></a><b>[3]</b>
<p>"&lt;&lt;" (i.e. the "name" of the quotelike operator)</p>
</li>
<li><a name="%5b4%5d"></a><b>[4]</b>
<p>"'EOMSG'" (i.e. the left delimiter of the here document, including any quotes),</p>
</li>
<li><a name="%5b5%5d"></a><b>[5]</b>
<p>"This is the message.\n" (i.e. the text of the here document),</p>
</li>
<li><a name="%5b6%5d"></a><b>[6]</b>
<p>"EOMSG" (i.e. the right delimiter of the here document),</p>
</li>
<li><a name="%5b7..10%5d"></a><b>[7..10]</b>
<p>"" (a here document has no second left delimiter, second text, second right
delimiter, or trailing modifiers).</p>
</li>
</ul>
<p>However, the matching position of the input variable would be set to
"exit;" (i.e. <i>after</i> the closing delimiter of the here document),
which would cause the earlier " || die;\nexit;" to be skipped in any
sequence of code fragment extractions.</p>
<p>To avoid this problem, when it encounters a here document whilst
extracting from a modifiable string, <code class="inline"><span class="w">extract_quotelike</span></code>
 silently
rearranges the string to an equivalent piece of Perl:</p>
<pre class="verbatim"><ol><li>        &lt;&lt;'EOMSG'</li><li>        This is the message.</li><li>        EOMSG</li><li>        || die;</li><li>        exit;</li></ol></pre><p>in which the here document <i>is</i> contiguous. It still leaves the
matching position after the here document, but now the rest of the line
on which the here document starts is not skipped.</p>
<p>To prevent &lt;extract_quotelike&gt; from mucking about with the input in this way
(this is the only case where a list-context <code class="inline"><span class="w">extract_quotelike</span></code>
 does so),
you can pass the input variable as an interpolated literal:</p>
<pre class="verbatim"><ol><li>        <span class="i">$quotelike</span> = <span class="i">extract_quotelike</span><span class="s">(</span><span class="q">&quot;$var&quot;</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><a name="extract_codeblock"></a><h2><code class="inline"><span class="w">extract_codeblock</span></code>
</h2>
<p><code class="inline"><span class="w">extract_codeblock</span></code>
 attempts to recognize and extract a balanced
bracket delimited substring that may contain unbalanced brackets
inside Perl quotes or quotelike operations. That is, <code class="inline"><span class="w">extract_codeblock</span></code>

is like a combination of <code class="inline"><span class="q">&quot;extract_bracketed&quot;</span></code>
 and
<code class="inline"><span class="q">&quot;extract_quotelike&quot;</span></code>
.</p>
<p><code class="inline"><span class="w">extract_codeblock</span></code>
 takes the same initial three parameters as <code class="inline"><span class="w">extract_bracketed</span></code>
:
a text to process, a set of delimiter brackets to look for, and a prefix to
match first. It also takes an optional fourth parameter, which allows the
outermost delimiter brackets to be specified separately (see below).</p>
<p>Omitting the first argument (input text) means process <code class="inline"><span class="i">$_</span></code>
 instead.
Omitting the second argument (delimiter brackets) indicates that only <code class="inline"><span class="q">&#39;{&#39;</span></code>
 is to be used.
Omitting the third argument (prefix argument) implies optional whitespace at the start.
Omitting the fourth argument (outermost delimiter brackets) indicates that the
value of the second argument is to be used for the outermost delimiters.</p>
<p>Once the prefix an dthe outermost opening delimiter bracket have been
recognized, code blocks are extracted by stepping through the input text and
trying the following alternatives in sequence:</p>
<dl>
<dt>1.</dt><dd>
<p>Try and match a closing delimiter bracket. If the bracket was the same
species as the last opening bracket, return the substring to that
point. If the bracket was mismatched, return an error.</p>
</dd>
<dt>2.</dt><dd>
<p>Try to match a quote or quotelike operator. If found, call
<code class="inline"><span class="w">extract_quotelike</span></code>
 to eat it. If <code class="inline"><span class="w">extract_quotelike</span></code>
 fails, return
the error it returned. Otherwise go back to step 1.</p>
</dd>
<dt>3.</dt><dd>
<p>Try to match an opening delimiter bracket. If found, call
<code class="inline"><span class="w">extract_codeblock</span></code>
 recursively to eat the embedded block. If the
recursive call fails, return an error. Otherwise, go back to step 1.</p>
</dd>
<dt>4.</dt><dd>
<p>Unconditionally match a bareword or any other single character, and
then go back to step 1.</p>
</dd>
</dl>
<p>Examples:</p>
<pre class="verbatim"><ol><li>        <span class="c"># Find a while loop in the text</span></li><li></li><li>                if <span class="s">(</span><span class="i">$text</span> =~ <span class="q">s/.*?while\s*\{/{/</span><span class="s">)</span></li><li>                <span class="s">{</span></li><li>                        <span class="i">$loop</span> = <span class="q">&quot;while &quot;</span> . <span class="i">extract_codeblock</span><span class="s">(</span><span class="i">$text</span><span class="s">)</span><span class="sc">;</span></li><li>                <span class="s">}</span></li><li></li><li>        <span class="c"># Remove the first round-bracketed list (which may include</span></li><li>        <span class="c"># round- or curly-bracketed code blocks or quotelike operators)</span></li><li></li><li>                <span class="w">extract_codeblock</span> <span class="i">$text</span><span class="cm">,</span> <span class="q">&quot;(){}&quot;</span><span class="cm">,</span> <span class="q">&#39;[^(]*&#39;</span><span class="sc">;</span></li></ol></pre><p>The ability to specify a different outermost delimiter bracket is useful
in some circumstances. For example, in the Parse::RecDescent module,
parser actions which are to be performed only on a successful parse
are specified using a <code class="inline"><span class="q">&lt;defer:...&gt;</span></code>
 directive. For example:</p>
<pre class="verbatim"><ol><li>        sentence: subject verb object</li><li>                        &lt;defer: {$::theVerb = $item{verb}} &gt;</li></ol></pre><p>Parse::RecDescent uses <code class="inline"><span class="i">extract_codeblock</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;{}&lt;&gt;&#39;</span><span class="s">)</span></code>
 to extract the code
within the <code class="inline"><span class="q">&lt;defer:...&gt;</span></code>
 directive, but there's a problem.</p>
<p>A deferred action like this:</p>
<pre class="verbatim"><ol><li>                        &lt;defer: {if ($count&gt;10) {$count--}} &gt;</li></ol></pre><p>will be incorrectly parsed as:</p>
<pre class="verbatim"><ol><li>                        <span class="q">&lt;defer: {if ($count&gt;</span></li></ol></pre><p>because the "less than" operator is interpreted as a closing delimiter.</p>
<p>But, by extracting the directive using
<code class="inline"><span class="i">extract_codeblock</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span> <span class="q">&#39;{}&#39;</span><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <span class="q">&#39;&lt;&gt;&#39;</span><span class="s">)</span></code>

the '&gt;' character is only treated as a delimited at the outermost
level of the code block, so the directive is parsed correctly.</p>
<a name="extract_multiple"></a><h2><code class="inline"><span class="w">extract_multiple</span></code>
</h2>
<p>The <code class="inline"><span class="w">extract_multiple</span></code>
 subroutine takes a string to be processed and a 
list of extractors (subroutines or regular expressions) to apply to that string.</p>
<p>In an array context <code class="inline"><span class="w">extract_multiple</span></code>
 returns an array of substrings
of the original string, as extracted by the specified extractors.
In a scalar context, <code class="inline"><span class="w">extract_multiple</span></code>
 returns the first
substring successfully extracted from the original string. In both
scalar and void contexts the original string has the first successfully
extracted substring removed from it. In all contexts
<code class="inline"><span class="w">extract_multiple</span></code>
 starts at the current <code class="inline"><a class="l_k" href="../functions/pos.html">pos</a></code> of the string, and
sets that <code class="inline"><a class="l_k" href="../functions/pos.html">pos</a></code> appropriately after it matches.</p>
<p>Hence, the aim of of a call to <code class="inline"><span class="w">extract_multiple</span></code>
 in a list context
is to split the processed string into as many non-overlapping fields as
possible, by repeatedly applying each of the specified extractors
to the remainder of the string. Thus <code class="inline"><span class="w">extract_multiple</span></code>
 is
a generalized form of Perl's <code class="inline"><a class="l_k" href="../functions/split.html">split</a></code> subroutine.</p>
<p>The subroutine takes up to four optional arguments:</p>
<dl>
<dt>1.</dt><dd>
<p>A string to be processed (<code class="inline"><span class="i">$_</span></code>
 if the string is omitted or <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>)</p>
</dd>
<dt>2.</dt><dd>
<p>A reference to a list of subroutine references and/or qr// objects and/or
literal strings and/or hash references, specifying the extractors
to be used to split the string. If this argument is omitted (or
<code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>) the list:</p>
<pre class="verbatim"><ol><li>        <span class="s">[</span></li><li>                <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_variable</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="cm">,</span> <span class="q">&#39;&#39;</span><span class="s">)</span> <span class="s">}</span><span class="cm">,</span></li><li>                <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_quotelike</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="cm">,</span><span class="q">&#39;&#39;</span><span class="s">)</span> <span class="s">}</span><span class="cm">,</span></li><li>                <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_codeblock</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="cm">,</span><span class="q">&#39;{}&#39;</span><span class="cm">,</span><span class="q">&#39;&#39;</span><span class="s">)</span> <span class="s">}</span><span class="cm">,</span></li><li>        <span class="s">]</span></li></ol></pre><p>is used.</p>
</dd>
<dt>3.</dt><dd>
<p>An number specifying the maximum number of fields to return. If this
argument is omitted (or <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>), split continues as long as possible.</p>
<p>If the third argument is <i>N</i>, then extraction continues until <i>N</i> fields
have been successfully extracted, or until the string has been completely 
processed.</p>
<p>Note that in scalar and void contexts the value of this argument is 
automatically reset to 1 (under <code class="inline">-w</code>
, a warning is issued if the argument 
has to be reset).</p>
</dd>
<dt>4.</dt><dd>
<p>A value indicating whether unmatched substrings (see below) within the
text should be skipped or returned as fields. If the value is true,
such substrings are skipped. Otherwise, they are returned.</p>
</dd>
</dl>
<p>The extraction process works by applying each extractor in
sequence to the text string.</p>
<p>If the extractor is a subroutine it is called in a list context and is
expected to return a list of a single element, namely the extracted
text. It may optionally also return two further arguments: a string
representing the text left after extraction (like $' for a pattern
match), and a string representing any prefix skipped before the
extraction (like $` in a pattern match). Note that this is designed
to facilitate the use of other Text::Balanced subroutines with
<code class="inline"><span class="w">extract_multiple</span></code>
. Note too that the value returned by an extractor
subroutine need not bear any relationship to the corresponding substring
of the original text (see examples below).</p>
<p>If the extractor is a precompiled regular expression or a string,
it is matched against the text in a scalar context with a leading
'\G' and the gc modifiers enabled. The extracted value is either
$1 if that variable is defined after the match, or else the
complete match (i.e. $&amp;).</p>
<p>If the extractor is a hash reference, it must contain exactly one element.
The value of that element is one of the
above extractor types (subroutine reference, regular expression, or string).
The key of that element is the name of a class into which the successful
return value of the extractor will be blessed.</p>
<p>If an extractor returns a defined value, that value is immediately
treated as the next extracted field and pushed onto the list of fields.
If the extractor was specified in a hash reference, the field is also
blessed into the appropriate class,</p>
<p>If the extractor fails to match (in the case of a regex extractor), or returns an empty list or an undefined value (in the case of a subroutine extractor), it is
assumed to have failed to extract.
If none of the extractor subroutines succeeds, then one
character is extracted from the start of the text and the extraction
subroutines reapplied. Characters which are thus removed are accumulated and
eventually become the next field (unless the fourth argument is true, in which
case they are discarded).</p>
<p>For example, the following extracts substrings that are valid Perl variables:</p>
<pre class="verbatim"><ol><li>        <span class="i">@fields</span> = <span class="i">extract_multiple</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span></li><li>                                   <span class="s">[</span> <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_variable</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="s">)</span> <span class="s">}</span> <span class="s">]</span><span class="cm">,</span></li><li>                                   <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>This example separates a text into fields which are quote delimited,
curly bracketed, and anything else. The delimited and bracketed
parts are also blessed to identify them (the "anything else" is unblessed):</p>
<pre class="verbatim"><ol><li>        <span class="i">@fields</span> = <span class="i">extract_multiple</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span></li><li>                   <span class="s">[</span></li><li>                        <span class="s">{</span> <span class="w">Delim</span> <span class="cm">=&gt;</span> <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_delimited</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="cm">,</span><span class="q">q{&#39;&quot;}</span><span class="s">)</span> <span class="s">}</span> <span class="s">}</span><span class="cm">,</span></li><li>                        <span class="s">{</span> <span class="w">Brack</span> <span class="cm">=&gt;</span> <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_bracketed</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="cm">,</span><span class="q">&#39;{}&#39;</span><span class="s">)</span> <span class="s">}</span> <span class="s">}</span><span class="cm">,</span></li><li>                   <span class="s">]</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>This call extracts the next single substring that is a valid Perl quotelike
operator (and removes it from $text):</p>
<pre class="verbatim"><ol><li>        <span class="i">$quotelike</span> = <span class="i">extract_multiple</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span></li><li>                                      <span class="s">[</span></li><li>                                        <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_quotelike</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="s">)</span> <span class="s">}</span><span class="cm">,</span></li><li>                                      <span class="s">]</span><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <span class="n">1</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>Finally, here is yet another way to do comma-separated value parsing:</p>
<pre class="verbatim"><ol><li>        <span class="i">@fields</span> = <span class="i">extract_multiple</span><span class="s">(</span><span class="i">$csv_text</span><span class="cm">,</span></li><li>                                  <span class="s">[</span></li><li>                                        <a class="l_k" href="../functions/sub.html">sub</a> <span class="s">{</span> <span class="i">extract_delimited</span><span class="s">(</span><span class="i">$_</span>[<span class="n">0</span>]<span class="cm">,</span><span class="q">q{&#39;&quot;}</span><span class="s">)</span> <span class="s">}</span><span class="cm">,</span></li><li>                                        <span class="q">qr/([^,]+)(.*)/</span><span class="cm">,</span></li><li>                                  <span class="s">]</span><span class="cm">,</span></li><li>                                  <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span><span class="n">1</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The list in the second argument means:
<i>"Try and extract a ' or " delimited string, otherwise extract anything up to a comma..."</i>.
The undef third argument means:
<i>"...as many times as possible..."</i>,
and the true value in the fourth argument means
<i>"...discarding anything else that appears (i.e. the commas)"</i>.</p>
<p>If you wanted the commas preserved as separate fields (i.e. like split
does if your split pattern has capturing parentheses), you would
just make the last parameter undefined (or remove it).</p>
<a name="gen_delimited_pat"></a><h2><code class="inline"><span class="w">gen_delimited_pat</span></code>
</h2>
<p>The <code class="inline"><span class="w">gen_delimited_pat</span></code>
 subroutine takes a single (string) argument and
   &gt; builds a Friedl-style optimized regex that matches a string delimited
by any one of the characters in the single argument. For example:</p>
<pre class="verbatim"><ol><li>        <span class="i">gen_delimited_pat</span><span class="s">(</span><span class="q">q{&#39;&quot;}</span><span class="s">)</span></li></ol></pre><p>returns the regex:</p>
<pre class="verbatim"><ol><li>        (?:\"(?:\\\"|(?!\").)*\"|\'(?:\\\'|(?!\').)*\')</li></ol></pre><p>Note that the specified delimiters are automatically quotemeta'd.</p>
<p>A typical use of <code class="inline"><span class="w">gen_delimited_pat</span></code>
 would be to build special purpose tags
for <code class="inline"><span class="w">extract_tagged</span></code>
. For example, to properly ignore "empty" XML elements
(which might contain quoted strings):</p>
<pre class="verbatim"><ol><li>        <a class="l_k" href="../functions/my.html">my</a> <span class="i">$empty_tag</span> = <span class="q">&#39;&lt;(&#39;</span> . <span class="i">gen_delimited_pat</span><span class="s">(</span><span class="q">q{&#39;&quot;}</span><span class="s">)</span> . <span class="q">&#39;|.)+/&gt;&#39;</span><span class="sc">;</span></li><li></li><li>        <span class="i">extract_tagged</span><span class="s">(</span><span class="i">$text</span><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span> <span class="s">{</span><span class="w">ignore</span> <span class="cm">=&gt;</span> <span class="s">[</span><span class="i">$empty_tag</span><span class="s">]</span><span class="s">}</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p><code class="inline"><span class="w">gen_delimited_pat</span></code>
 may also be called with an optional second argument,
which specifies the "escape" character(s) to be used for each delimiter.
For example to match a Pascal-style string (where ' is the delimiter
and '' is a literal ' within the string):</p>
<pre class="verbatim"><ol><li>        <span class="i">gen_delimited_pat</span><span class="s">(</span><span class="q">q{&#39;}</span><span class="cm">,</span><span class="q">q{&#39;}</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>Different escape characters can be specified for different delimiters.
For example, to specify that '/' is the escape for single quotes
and '%' is the escape for double quotes:</p>
<pre class="verbatim"><ol><li>        <span class="i">gen_delimited_pat</span><span class="s">(</span><span class="q">q{&#39;&quot;}</span><span class="cm">,</span><span class="q">q{/%}</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>If more delimiters than escape chars are specified, the last escape char
is used for the remaining delimiters.
If no escape char is specified for a given specified delimiter, '\' is used.</p>
<a name="delimited_pat"></a><h2><code class="inline"><span class="w">delimited_pat</span></code>
</h2>
<p>Note that <code class="inline"><span class="w">gen_delimited_pat</span></code>
 was previously called <code class="inline"><span class="w">delimited_pat</span></code>
.
That name may still be used, but is now deprecated.</p>
<a name="DIAGNOSTICS"></a><h1>DIAGNOSTICS</h1>
<p>In a list context, all the functions return <code class="inline"><span class="s">(</span><a class="l_k" href="../functions/undef.html">undef</a><span class="cm">,</span><span class="i">$original_text</span><span class="s">)</span></code>

on failure. In a scalar context, failure is indicated by returning <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>
(in this case the input text is not modified in any way).</p>
<p>In addition, on failure in <i>any</i> context, the <code class="inline"><span class="i">$@</span></code>
 variable is set.
Accessing <code class="inline"><span class="i">$@</span>-&gt;{<span class="w">error</span>}</code>
 returns one of the error diagnostics listed
below.
Accessing <code class="inline"><span class="i">$@</span>-&gt;{<span class="w">pos</span>}</code>
 returns the offset into the original string at
which the error was detected (although not necessarily where it occurred!)
Printing <code class="inline"><span class="i">$@</span></code>
 directly produces the error message, with the offset appended.
On success, the <code class="inline"><span class="i">$@</span></code>
 variable is guaranteed to be <code class="inline"><a class="l_k" href="../functions/undef.html">undef</a></code>.</p>
<p>The available diagnostics are:</p>
<ul>
<li><a name="Did-not-find-a-suitable-bracket%3a-%22%25s%22"></a><b><code class="inline">Did not find a suitable bracket: "%s"</code></b>
<p>The delimiter provided to <code class="inline"><span class="w">extract_bracketed</span></code>
 was not one of
<code class="inline"><span class="q">&#39;()[]&lt;&gt;{}&#39;</span></code>
.</p>
</li>
<li><a name="Did-not-find-prefix%3a-%2f%25s%2f"></a><b><code class="inline">Did not find prefix: /%s/</code></b>
<p>A non-optional prefix was specified but wasn't found at the start of the text.</p>
</li>
<li><a name="Did-not-find-opening-bracket-after-prefix%3a-%22%25s%22"></a><b><code class="inline">Did not find opening bracket after prefix: "%s"</code></b>
<p><code class="inline"><span class="w">extract_bracketed</span></code>
 or <code class="inline"><span class="w">extract_codeblock</span></code>
 was expecting a
particular kind of bracket at the start of the text, and didn't find it.</p>
</li>
<li><a name="No-quotelike-operator-found-after-prefix%3a-%22%25s%22"></a><b><code class="inline">No quotelike operator found after prefix: "%s"</code></b>
<p><code class="inline"><span class="w">extract_quotelike</span></code>
 didn't find one of the quotelike operators <code class="inline"><a class="l_k" href="../functions/q.html">q</a></code>,
<code class="inline"><a class="l_k" href="../functions/qq.html">qq</a></code>, <code class="inline"><a class="l_k" href="../functions/qw.html">qw</a></code>, <code class="inline"><a class="l_k" href="../functions/qx.html">qx</a></code>, <code class="inline"><a class="l_k" href="../functions/s.html">s</a></code>, <code class="inline"><a class="l_k" href="../functions/tr.html">tr</a></code> or <code class="inline"><a class="l_k" href="../functions/y.html">y</a></code> at the start of the substring
it was extracting.</p>
</li>
<li><a name="Unmatched-closing-bracket%3a-%22%25c%22"></a><b><code class="inline">Unmatched closing bracket: "%c"</code></b>
<p><code class="inline"><span class="w">extract_bracketed</span></code>
, <code class="inline"><span class="w">extract_quotelike</span></code>
 or <code class="inline"><span class="w">extract_codeblock</span></code>
 encountered
a closing bracket where none was expected.</p>
</li>
<li><a name="Unmatched-opening-bracket(s)%3a-%22%25s%22"></a><b><code class="inline">Unmatched opening bracket(s): "%s"</code></b>
<p><code class="inline"><span class="w">extract_bracketed</span></code>
, <code class="inline"><span class="w">extract_quotelike</span></code>
 or <code class="inline"><span class="w">extract_codeblock</span></code>
 ran 
out of characters in the text before closing one or more levels of nested
brackets.</p>
</li>
<li><a name="Unmatched-embedded-quote-(%25s)"></a><b><code class="inline"><span class="w">Unmatched</span> <span class="w">embedded</span> <span class="w">quote</span> <span class="s">(</span><span class="i">%s</span><span class="s">)</span></code>
</b>
<p><code class="inline"><span class="w">extract_bracketed</span></code>
 attempted to match an embedded quoted substring, but
failed to find a closing quote to match it.</p>
</li>
<li><a name="Did-not-find-closing-delimiter-to-match-'%25s'"></a><b><code class="inline"><span class="w">Did</span> not <span class="w">find</span> <span class="w">closing</span> <span class="w">delimiter</span> <span class="w">to</span> <span class="w">match</span> <span class="q">&#39;%s&#39;</span></code>
</b>
<p><code class="inline"><span class="w">extract_quotelike</span></code>
 was unable to find a closing delimiter to match the
one that opened the quote-like operation.</p>
</li>
<li><a name="Mismatched-closing-bracket%3a-expected-%22%25c%22-but-found-%22%25s%22"></a><b><code class="inline">Mismatched closing bracket: expected "%c" but found "%s"</code></b>
<p><code class="inline"><span class="w">extract_bracketed</span></code>
, <code class="inline"><span class="w">extract_quotelike</span></code>
 or <code class="inline"><span class="w">extract_codeblock</span></code>
 found
a valid bracket delimiter, but it was the wrong species. This usually
indicates a nesting error, but may indicate incorrect quoting or escaping.</p>
</li>
<li><a name="No-block-delimiter-found-after-quotelike-%22%25s%22"></a><b><code class="inline"><span class="w">No</span> <span class="w">block</span> <span class="w">delimiter</span> <span class="w">found</span> <span class="w">after</span> <span class="w">quotelike</span> <span class="q">&quot;%s&quot;</span></code>
</b>
<p><code class="inline"><span class="w">extract_quotelike</span></code>
 or <code class="inline"><span class="w">extract_codeblock</span></code>
 found one of the
quotelike operators <code class="inline"><a class="l_k" href="../functions/q.html">q</a></code>, <code class="inline"><a class="l_k" href="../functions/qq.html">qq</a></code>, <code class="inline"><a class="l_k" href="../functions/qw.html">qw</a></code>, <code class="inline"><a class="l_k" href="../functions/qx.html">qx</a></code>, <code class="inline"><a class="l_k" href="../functions/s.html">s</a></code>, <code class="inline"><a class="l_k" href="../functions/tr.html">tr</a></code> or <code class="inline"><a class="l_k" href="../functions/y.html">y</a></code>
without a suitable block after it.</p>
</li>
<li><a name="Did-not-find-leading-dereferencer"></a><b><code class="inline"><span class="w">Did</span> not <span class="w">find</span> <span class="w">leading</span> <span class="w">dereferencer</span></code>
</b>
<p><code class="inline"><span class="w">extract_variable</span></code>
 was expecting one of '$', '@', or '%' at the start of
a variable, but didn't find any of them.</p>
</li>
<li><a name="Bad-identifier-after-dereferencer"></a><b><code class="inline"><span class="w">Bad</span> <span class="w">identifier</span> <span class="w">after</span> <span class="w">dereferencer</span></code>
</b>
<p><code class="inline"><span class="w">extract_variable</span></code>
 found a '$', '@', or '%' indicating a variable, but that
character was not followed by a legal Perl identifier.</p>
</li>
<li><a name="Did-not-find-expected-opening-bracket-at-%25s"></a><b><code class="inline"><span class="w">Did</span> not <span class="w">find</span> <span class="w">expected</span> <span class="w">opening</span> <span class="w">bracket</span> <span class="w">at</span> <span class="i">%s</span></code>
</b>
<p><code class="inline"><span class="w">extract_codeblock</span></code>
 failed to find any of the outermost opening brackets
that were specified.</p>
</li>
<li><a name="Improperly-nested-codeblock-at-%25s"></a><b><code class="inline"><span class="w">Improperly</span> <span class="w">nested</span> <span class="w">codeblock</span> <span class="w">at</span> <span class="i">%s</span></code>
</b>
<p>A nested code block was found that started with a delimiter that was specified
as being only to be used as an outermost bracket.</p>
</li>
<li><a name="Missing-second-block-for-quotelike-%22%25s%22"></a><b><code class="inline"><span class="w">Missing</span> <span class="w">second</span> <span class="w">block</span> for <span class="w">quotelike</span> <span class="q">&quot;%s&quot;</span></code>
</b>
<p><code class="inline"><span class="w">extract_codeblock</span></code>
 or <code class="inline"><span class="w">extract_quotelike</span></code>
 found one of the
quotelike operators <code class="inline"><a class="l_k" href="../functions/s.html">s</a></code>, <code class="inline"><a class="l_k" href="../functions/tr.html">tr</a></code> or <code class="inline"><a class="l_k" href="../functions/y.html">y</a></code> followed by only one block.</p>
</li>
<li><a name="No-match-found-for-opening-bracket"></a><b><code class="inline"><span class="w">No</span> <span class="w">match</span> <span class="w">found</span> for <span class="w">opening</span> <span class="w">bracket</span></code>
</b>
<p><code class="inline"><span class="w">extract_codeblock</span></code>
 failed to find a closing bracket to match the outermost
opening bracket.</p>
</li>
<li><a name="Did-not-find-opening-tag%3a-%2f%25s%2f"></a><b><code class="inline">Did not find opening tag: /%s/</code></b>
<p><code class="inline"><span class="w">extract_tagged</span></code>
 did not find a suitable opening tag (after any specified
prefix was removed).</p>
</li>
<li><a name="Unable-to-construct-closing-tag-to-match%3a-%2f%25s%2f"></a><b><code class="inline">Unable to construct closing tag to match: /%s/</code></b>
<p><code class="inline"><span class="w">extract_tagged</span></code>
 matched the specified opening tag and tried to
modify the matched text to produce a matching closing tag (because
none was specified). It failed to generate the closing tag, almost
certainly because the opening tag did not start with a
bracket of some kind.</p>
</li>
<li><a name="Found-invalid-nested-tag%3a-%25s"></a><b><code class="inline">Found invalid nested tag: %s</code></b>
<p><code class="inline"><span class="w">extract_tagged</span></code>
 found a nested tag that appeared in the "reject" list
(and the failure mode was not "MAX" or "PARA").</p>
</li>
<li><a name="Found-unbalanced-nested-tag%3a-%25s"></a><b><code class="inline">Found unbalanced nested tag: %s</code></b>
<p><code class="inline"><span class="w">extract_tagged</span></code>
 found a nested opening tag that was not matched by a
corresponding nested closing tag (and the failure mode was not "MAX" or "PARA").</p>
</li>
<li><a name="Did-not-find-closing-tag"></a><b><code class="inline"><span class="w">Did</span> not <span class="w">find</span> <span class="w">closing</span> <span class="w">tag</span></code>
</b>
<p><code class="inline"><span class="w">extract_tagged</span></code>
 reached the end of the text without finding a closing tag
to match the original opening tag (and the failure mode was not
"MAX" or "PARA").</p>
</li>
</ul>
<a name="AUTHOR"></a><h1>AUTHOR</h1>
<p>Damian Conway (damian@conway.org)</p>
<a name="BUGS-AND-IRRITATIONS"></a><h1>BUGS AND IRRITATIONS</h1>
<p>There are undoubtedly serious bugs lurking somewhere in this code, if
only because parts of it give the impression of understanding a great deal
more about Perl than they really do.</p>
<p>Bug reports and other feedback are most welcome.</p>
<a name="COPYRIGHT"></a><h1>COPYRIGHT</h1>
<p>Copyright 1997 - 2001 Damian Conway. All Rights Reserved.</p>
<p>Some (minor) parts copyright 2009 Adam Kennedy.</p>
<p>This module is free software. It may be used, redistributed
and/or modified under the same terms as Perl itself.</p>




  <div id="page_index" class="hud_container">
    <div id="page_index_header" class="hud_header">
      <div id="page_index_close" class="hud_close"><a href="#" onClick="pageIndex.hide();return false;"></a></div>
      <div id="page_index_title" class="hud_title"><span class="hud_span_top">Page index</span></div>
      <div id="page_index_topright" class="hud_topright"></div>
    </div>
    <div id="page_index_content" class="hud_content">
      <ul><li><a href="#NAME">NAME</a><li><a href="#SYNOPSIS">SYNOPSIS</a><li><a href="#DESCRIPTION">DESCRIPTION</a><ul><li><a href="#General-behaviour-in-list-contexts">General behaviour in list contexts</a><li><a href="#General-behaviour-in-scalar-and-void-contexts">General behaviour in scalar and void contexts</a><li><a href="#A-note-about-prefixes">A note about prefixes</a><li><a href="#extract_delimited">extract_delimited</a><li><a href="#extract_bracketed">extract_bracketed</a><li><a href="#extract_variable">extract_variable</a><li><a href="#extract_tagged">extract_tagged</a><li><a href="#gen_extract_tagged">gen_extract_tagged</a><li><a href="#extract_quotelike">extract_quotelike</a><li><a href="#extract_quotelike-and-%22here-documents%22">extract_quotelike and "here documents"</a><li><a href="#extract_codeblock">extract_codeblock</a><li><a href="#extract_multiple">extract_multiple</a><li><a href="#gen_delimited_pat">gen_delimited_pat</a><li><a href="#delimited_pat">delimited_pat</a></ul><li><a href="#DIAGNOSTICS">DIAGNOSTICS</a><li><a href="#AUTHOR">AUTHOR</a><li><a href="#BUGS-AND-IRRITATIONS">BUGS AND IRRITATIONS</a><li><a href="#COPYRIGHT">COPYRIGHT</a></ul>
    </div>
    <div id="page_index_footer" class="hud_footer">
      <div id="page_index_bottomleft" class="hud_bottomleft"></div>
      <div id="page_index_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
      <div id="page_index_resize" class="hud_resize"></div>
    </div>
  </div>


	    &nbsp;
          </div>
          <div id="content_footer">
          </div>
        </div>
        <div class="clear"></div>
      </div>
      
    <div id="footer">
      <div id="footer_content">
        <div id="footer_strapline">
          perldoc.perl.org - Official documentation for the Perl programming language
        </div>
        <div id="footer_links">
          <div id="address">
            <p class="name">Contact details</p>
            <p class="address">
	      Site maintained by <a href="mailto:jj@jonallen.info">Jon Allen (JJ)</a><br>
	    </p>
            <p class="contact">
              Documentation maintained by the <a href="http://lists.cpan.org/showlist.cgi?name=perl5-porters">Perl 5 Porters</a>
            </p>
          </div>
          <ul class="f1">
            <li>Manual
              <ul class="f2">
                <li><a href="../index-overview.html">Overview</a>
                <li><a href="../index-tutorials.html">Tutorials</a>
                <li><a href="../index-faq.html">FAQs</a>
                <li><a href="../index-history.html">Changes</a>
              </ul>
            <li>Reference
              <ul class="f2">
                <li><a href="../index-language.html">Language</a>
                <li><a href="../index-functions.html">Functions</a>
                <li><a href="../perlop.html">Operators</a>
                <li><a href="../perlvar.html">Variables</a>
              </ul>
            <li>Modules
              <ul class="f2">
                <li><a href="../index-modules-A.html">Modules</a>
                <li><a href="../index-pragmas.html">Pragmas</a>
                <li><a href="../index-utilities.html">Utilities</a>
              </ul>
            <li>Misc
              <ul class="f2">
                <li><a href="../index-licence.html">License</a>
                <li><a href="../index-internals.html">Internals</a>
                <li><a href="../index-platforms.html">Platforms</a>
              </ul>          </ul>
          <div class="clear"></div>
        </div>
      </div>
      <div id="footer_end">
      </div>
    </div>
      
    </div>
      <script language="JavaScript" type="text/javascript" src="../static/exploreperl.js"></script>
      <script language="JavaScript" src="../static/combined-20100403.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
  perldoc.setPath(1);
  perldoc.pageName    = 'Text::Balanced';
  perldoc.pageAddress = 'Text/Balanced.html';
  perldoc.contentPage = 1;
  explorePerl.render();
  explorePerl.addEvents('explore_anchor');
</script>
    
  </body>
</html>
