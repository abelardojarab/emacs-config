<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>perlxs</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta http-equiv="Content-Language" content="en-gb">
  <link rel="search" type="application/opensearchdescription+xml" title="Search perldoc.perl.org" href="/static/search.xml"/>
  <link href="static/css-20100830.css" rel="stylesheet" rev="stylesheet" type="text/css" media="screen">
  <link href="static/exploreperl.css" rel="stylesheet" rev="stylesheet" type="text/css">
</head>

<body onLoad="perldoc.startup();" onPageShow="if (event.persisted) perldoc.startup();">
    <div id="page">
      
      <div id="header">
	<div id="homepage_link">
	  <a href="index.html"></a>
	</div>
	<div id="strapline">
	  Perl Programming Documentation
	</div>
	<div id="download_link" class="download">
	  <a href="http://www.perl.org/get.html">Download Perl</a>
	</div>
	<div id="explore_link" class="download">
	  <a id="explore_anchor" href="#">Explore</a>
	</div>
      </div>
      
      <div id="body">
        <div id="left_column">
          <div class="side_group">
            
	    <div class="side_panel doc_panel">
              <p>Manual</p>
              <ul>
                <li><a href="index-overview.html">Overview</a>
                <li><a href="index-tutorials.html">Tutorials</a>
                <li><a href="index-faq.html">FAQs</a>
                <li><a href="index-history.html">History / Changes</a>
                <li><a href="index-licence.html">License</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Reference</p>
              <ul>
                <li><a href="index-language.html">Language</a>
                <li><a href="index-functions.html">Functions</a>
                <li><a href="perlop.html">Operators</a>
                <li><a href="perlvar.html">Special Variables</a>
                <li><a href="index-pragmas.html">Pragmas</a>
                <li><a href="index-utilities.html">Utilities</a>
                <li><a href="index-internals.html">Internals</a>
                <li><a href="index-platforms.html">Platform Specific</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Modules</p>
              <ul>
		<li>
		
                
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		
                  
		
		
                    <a href="index-modules-A.html">A</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-B.html">B</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-C.html">C</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-D.html">D</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-E.html">E</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-F.html">F</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-G.html">G</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-H.html">H</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-I.html">I</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-L.html">L</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-M.html">M</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-N.html">N</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-O.html">O</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-P.html">P</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-S.html">S</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-T.html">T</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-U.html">U</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-X.html">X</a>
                    
                
              </ul>
            </div>
            
	      <div class="side_panel doc_panel">
		<p>Tools</p>
		<ul>
		  <li><a href="preferences.html">Preferences</a>
		</ul>
	      </div>
            
          </div>
        </div>
        <div id="centre_column">
          <div id="content_header">
            <div id="title_bar">
              <div id="page_name">
                <h1>perlxs</h1>
              </div>
              <div id="perl_version">
                Perl 5 version 22.0 documentation
              </div>
              <div class="page_links" id="page_links_top">
                <a href="#" onClick="toolbar.goToTop();return false;">Go to top</a>
		
              </div>
	      <div class="page_links" id="page_links_bottom">
		
                  <a href="#" id="page_index_toggle">Show page index</a> &bull;
		
                <a href="#" id="recent_pages_toggle">Show recent pages</a>		
	      </div>
	      <div id="search_form">
		<form action="search.html" method="GET" id="search">
		  <input type="text" name="q" id="search_box" alt="Search">
		</form>
	      </div>
            </div>
            <div id="breadcrumbs">
                
    <a href="index.html">Home</a> &gt;
    
      
        <a href="index-internals.html">Internals and C language interface</a> &gt;
      
    
    perlxs
  

            </div>
          </div>
          <div id="content_body">
	    <!--[if lt IE 7]>
 <div class="noscript">
   <p>
     <strong>It looks like you're using Internet Explorer 6. This is a very old
     browser which does not offer full support for modern websites.</strong>
   </p>
   <p>
     Unfortunately this means that this website will not work on
     your computer.
   </p>
   <p>
     Don't miss out though! To view the site (and get a better experience from
     many other websites), simply upgrade to
     <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet
Explorer 8</a>
     or download an alternative browser such as
     <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>,
     <a href="http://www.apple.com/safari/download/">Safari</a>, or
     <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
   </p>
   <p>
     All of these browsers are free. If you're using a PC at work, you may
     need to contact your IT administrator.
   </p>
 </div>
<![endif]-->
	    <noscript>
	      <div class="noscript">
	      <p>
                <strong>Please note: Many features of this site require JavaScript. You appear to have JavaScript disabled,
	        or are running a non-JavaScript capable web browser.</strong>
	      </p>
	      <p>
		To get the best experience, please enable JavaScript or download a modern web browser such as <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet Explorer 8</a>, <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>, <a href="http://www.apple.com/safari/download/">Safari</a>, or <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
              </p>
	      </div>
	    </noscript>

	    <div id="recent_pages" class="hud_container">
	      <div id="recent_pages_header" class="hud_header">
		<div id="recent_pages_close" class="hud_close"><a href="#" onClick="recentPages.hide();return false;"></a></div>
		<div id="recent_pages_title" class="hud_title"><span class="hud_span_top">Recently read</span></div>
		<div id="recent_pages_topright" class="hud_topright"></div>
	      </div>
	      <div id="recent_pages_content" class="hud_content">
	      </div>
	      <div id="recent_pages_footer" class="hud_footer">
		<div id="recent_pages_bottomleft" class="hud_bottomleft"></div>
		<div id="recent_pages_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
		<div id="recent_pages_resize" class="hud_resize"></div>
	      </div>
	    </div>
  
	    <div id="from_search"></div>
            <h1>perlxs</h1>


  <!--    -->
<ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION</a><ul><li><a href="#Introduction">Introduction</a><li><a href="#On-The-Road">On The Road</a><li><a href="#The-Anatomy-of-an-XSUB">The Anatomy of an XSUB</a><li><a href="#The-Argument-Stack">The Argument Stack</a><li><a href="#The-RETVAL-Variable">The RETVAL Variable</a><li><a href="#Returning-SVs%2c-AVs-and-HVs-through-RETVAL">Returning SVs, AVs and HVs through RETVAL</a><li><a href="#The-MODULE-Keyword">The MODULE Keyword</a><li><a href="#The-PACKAGE-Keyword">The PACKAGE Keyword</a><li><a href="#The-PREFIX-Keyword">The PREFIX Keyword</a><li><a href="#The-OUTPUT%3a-Keyword">The OUTPUT: Keyword</a><li><a href="#The-NO_OUTPUT-Keyword">The NO_OUTPUT Keyword</a><li><a href="#The-CODE%3a-Keyword">The CODE: Keyword</a><li><a href="#The-INIT%3a-Keyword">The INIT: Keyword</a><li><a href="#The-NO_INIT-Keyword">The NO_INIT Keyword</a><li><a href="#The-TYPEMAP%3a-Keyword">The TYPEMAP: Keyword</a><li><a href="#Initializing-Function-Parameters">Initializing Function Parameters</a><li><a href="#Default-Parameter-Values">Default Parameter Values</a><li><a href="#The-PREINIT%3a-Keyword">The PREINIT: Keyword</a><li><a href="#The-SCOPE%3a-Keyword">The SCOPE: Keyword</a><li><a href="#The-INPUT%3a-Keyword">The INPUT: Keyword</a><li><a href="#The-IN%2fOUTLIST%2fIN_OUTLIST%2fOUT%2fIN_OUT-Keywords">The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</a><li><a href="#The-length(NAME)-Keyword">The length(NAME) Keyword</a><li><a href="#Variable-length-Parameter-Lists">Variable-length Parameter Lists</a><li><a href="#The-C_ARGS%3a-Keyword">The C_ARGS: Keyword</a><li><a href="#The-PPCODE%3a-Keyword">The PPCODE: Keyword</a><li><a href="#Returning-Undef-And-Empty-Lists">Returning Undef And Empty Lists</a><li><a href="#The-REQUIRE%3a-Keyword">The REQUIRE: Keyword</a><li><a href="#The-CLEANUP%3a-Keyword">The CLEANUP: Keyword</a><li><a href="#The-POSTCALL%3a-Keyword">The POSTCALL: Keyword</a><li><a href="#The-BOOT%3a-Keyword">The BOOT: Keyword</a><li><a href="#The-VERSIONCHECK%3a-Keyword">The VERSIONCHECK: Keyword</a><li><a href="#The-PROTOTYPES%3a-Keyword">The PROTOTYPES: Keyword</a><li><a href="#The-PROTOTYPE%3a-Keyword">The PROTOTYPE: Keyword</a><li><a href="#The-ALIAS%3a-Keyword">The ALIAS: Keyword</a><li><a href="#The-OVERLOAD%3a-Keyword">The OVERLOAD: Keyword</a><li><a href="#The-FALLBACK%3a-Keyword">The FALLBACK: Keyword</a><li><a href="#The-INTERFACE%3a-Keyword">The INTERFACE: Keyword</a><li><a href="#The-INTERFACE_MACRO%3a-Keyword">The INTERFACE_MACRO: Keyword</a><li><a href="#The-INCLUDE%3a-Keyword">The INCLUDE: Keyword</a><li><a href="#The-INCLUDE_COMMAND%3a-Keyword">The INCLUDE_COMMAND: Keyword</a><li><a href="#The-CASE%3a-Keyword">The CASE: Keyword</a><li><a href="#The-EXPORT_XSUB_SYMBOLS%3a-Keyword">The EXPORT_XSUB_SYMBOLS: Keyword</a><li><a href="#The-%26-Unary-Operator">The & Unary Operator</a><li><a href="#Inserting-POD%2c-Comments-and-C-Preprocessor-Directives">Inserting POD, Comments and C Preprocessor Directives</a><li><a href="#Using-XS-With-C%2b%2b">Using XS With C++</a><li><a href="#Interface-Strategy">Interface Strategy</a><li><a href="#Perl-Objects-And-C-Structures">Perl Objects And C Structures</a><li><a href="#Safely-Storing-Static-Data-in-XS">Safely Storing Static Data in XS</a><li><a href="#Thread-aware-system-interfaces">Thread-aware system interfaces</a></ul><li><a href="#EXAMPLES">EXAMPLES</a><li><a href="#CAVEATS">CAVEATS</a><li><a href="#XS-VERSION">XS VERSION</a><li><a href="#AUTHOR">AUTHOR</a></ul><a name="NAME"></a><h1>NAME</h1>
<p>perlxs - XS language reference manual</p>
<a name="DESCRIPTION"></a><h1>DESCRIPTION</h1>
<a name="Introduction"></a><h2>Introduction</h2>
<p>XS is an interface description file format used to create an extension
interface between Perl and C code (or a C library) which one wishes
to use with Perl.  The XS interface is combined with the library to
create a new library which can then be either dynamically loaded
or statically linked into perl.  The XS interface description is
written in the XS language and is the core component of the Perl
extension interface.</p>
<p>Before writing XS, read the <a href="#CAVEATS">CAVEATS</a> section below.</p>
<p>An <b>XSUB</b> forms the basic unit of the XS interface.  After compilation
by the <b>xsubpp</b> compiler, each XSUB amounts to a C function definition
which will provide the glue between Perl calling conventions and C
calling conventions.</p>
<p>The glue code pulls the arguments from the Perl stack, converts these
Perl values to the formats expected by a C function, call this C function,
transfers the return values of the C function back to Perl.
Return values here may be a conventional C return value or any C
function arguments that may serve as output parameters.  These return
values may be passed back to Perl either by putting them on the
Perl stack, or by modifying the arguments supplied from the Perl side.</p>
<p>The above is a somewhat simplified view of what really happens.  Since
Perl allows more flexible calling conventions than C, XSUBs may do much
more in practice, such as checking input parameters for validity,
throwing exceptions (or returning undef/empty list) if the return value
from the C function indicates failure, calling different C functions
based on numbers and types of the arguments, providing an object-oriented
interface, etc.</p>
<p>Of course, one could write such glue code directly in C.  However, this
would be a tedious task, especially if one needs to write glue for
multiple C functions, and/or one is not familiar enough with the Perl
stack discipline and other such arcana.  XS comes to the rescue here:
instead of writing this glue C code in long-hand, one can write
a more concise short-hand <i>description</i> of what should be done by
the glue, and let the XS compiler <b>xsubpp</b> handle the rest.</p>
<p>The XS language allows one to describe the mapping between how the C
routine is used, and how the corresponding Perl routine is used.  It
also allows creation of Perl routines which are directly translated to
C code and which are not related to a pre-existing C function.  In cases
when the C interface coincides with the Perl interface, the XSUB
declaration is almost identical to a declaration of a C function (in K&amp;R
style).  In such circumstances, there is another tool called <code class="inline"><span class="w">h2xs</span></code>

that is able to translate an entire C header file into a corresponding
XS file that will provide glue to the functions/macros described in
the header file.</p>
<p>The XS compiler is called <b>xsubpp</b>.  This compiler creates
the constructs necessary to let an XSUB manipulate Perl values, and
creates the glue necessary to let Perl call the XSUB.  The compiler
uses <b>typemaps</b> to determine how to map C function parameters
and output values to Perl values and back.  The default typemap
(which comes with Perl) handles many common C types.  A supplementary
typemap may also be needed to handle any special structures and types
for the library being linked. For more information on typemaps,
see <a href="perlxstypemap.html">perlxstypemap</a>.</p>
<p>A file in XS format starts with a C language section which goes until the
first <code class="inline"><span class="w">MODULE</span> =</code>
 directive.  Other XS directives and XSUB definitions
may follow this line.  The "language" used in this part of the file
is usually referred to as the XS language.  <b>xsubpp</b> recognizes and
skips POD (see <a href="perlpod.html">perlpod</a>) in both the C and XS language sections, which
allows the XS file to contain embedded documentation.</p>
<p>See <a href="perlxstut.html">perlxstut</a> for a tutorial on the whole extension creation process.</p>
<p>Note: For some extensions, Dave Beazley's SWIG system may provide a
significantly more convenient mechanism for creating the extension
glue code.  See <a href="http://www.swig.org/">http://www.swig.org/</a> for more information.</p>
<a name="On-The-Road"></a><h2>On The Road</h2>
<p>Many of the examples which follow will concentrate on creating an interface
between Perl and the ONC+ RPC bind library functions.  The rpcb_gettime()
function is used to demonstrate many features of the XS language.  This
function has two parameters; the first is an input parameter and the second
is an output parameter.  The function also returns a status value.</p>
<pre class="verbatim"><ol><li>	<span class="w">bool_t</span> <span class="i">rpcb_gettime</span><span class="s">(</span><span class="w">const</span> <span class="w">char</span> *<span class="w">host</span><span class="cm">,</span> <span class="w">time_t</span> *<span class="w">timep</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>From C this function will be called with the following
statements.</p>
<pre class="verbatim"><ol><li>     <span class="c">#include &lt;rpc/rpc.h&gt;</span></li><li>     <span class="w">bool_t</span> <span class="w">status</span><span class="sc">;</span></li><li>     <span class="w">time_t</span> <span class="w">timep</span><span class="sc">;</span></li><li>     <span class="w">status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="q">&quot;localhost&quot;</span><span class="cm">,</span> <span class="i">&amp;timep</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>If an XSUB is created to offer a direct translation between this function
and Perl, then this XSUB will be used from Perl with the following code.
The $status and $timep variables will contain the output of the function.</p>
<pre class="verbatim"><ol><li>     <a class="l_k" href="functions/use.html">use</a> <span class="w">RPC</span><span class="sc">;</span></li><li>     <span class="i">$status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="q">&quot;localhost&quot;</span><span class="cm">,</span> <span class="i">$timep</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The following XS file shows an XS subroutine, or XSUB, which
demonstrates one possible interface to the rpcb_gettime()
function.  This XSUB represents a direct translation between
C and Perl and so preserves the interface even from Perl.
This XSUB will be invoked from Perl with the usage shown
above.  Note that the first three #include statements, for
<code class="inline"><span class="w">EXTERN</span>.<span class="w">h</span></code>
, <code class="inline"><span class="w">perl</span>.<span class="w">h</span></code>
, and <code class="inline"><span class="w">XSUB</span>.<span class="w">h</span></code>
, will always be present at the
beginning of an XS file.  This approach and others will be
expanded later in this document.  A #define for <code class="inline"><span class="w">PERL_NO_GET_CONTEXT</span></code>

should be present to fetch the interpreter context more efficiently,
see <a href="perlguts.html#How-multiple-interpreters-and-concurrency-are-supported">perlguts</a> for details.</p>
<pre class="verbatim"><ol><li>     <span class="c">#define PERL_NO_GET_CONTEXT</span></li><li>     <span class="c">#include &quot;EXTERN.h&quot;</span></li><li>     <span class="c">#include &quot;perl.h&quot;</span></li><li>     <span class="c">#include &quot;XSUB.h&quot;</span></li><li>     <span class="c">#include &lt;rpc/rpc.h&gt;</span></li><li></li><li>     <span class="w">MODULE</span> = <span class="w">RPC</span>  <span class="w">PACKAGE</span> = <span class="w">RPC</span></li><li></li><li>     <span class="w">bool_t</span></li><li>     <span class="i">rpcb_gettime</span><span class="s">(</span><span class="w">host</span><span class="cm">,</span><span class="w">timep</span><span class="s">)</span></li><li>          <span class="w">char</span> *<span class="w">host</span></li><li>          <span class="w">time_t</span> <span class="i">&amp;timep</span></li><li>        <span class="w">OUTPUT</span><span class="co">:</span></li><li>          <span class="w">timep</span></li></ol></pre><p>Any extension to Perl, including those containing XSUBs,
should have a Perl module to serve as the bootstrap which
pulls the extension into Perl.  This module will export the
extension's functions and variables to the Perl program and
will cause the extension's XSUBs to be linked into Perl.
The following module will be used for most of the examples
in this document and should be used from Perl with the <code class="inline"><a class="l_k" href="functions/use.html">use</a></code>
command as shown earlier.  Perl modules are explained in
more detail later in this document.</p>
<pre class="verbatim"><ol><li><a name="package-RPC"></a>     package <span class="i">RPC</span><span class="sc">;</span></li><li></li><li>     <a class="l_k" href="functions/require.html">require</a> <span class="w">Exporter</span><span class="sc">;</span></li><li>     <a class="l_k" href="functions/require.html">require</a> <span class="w">DynaLoader</span><span class="sc">;</span></li><li>     <span class="i">@ISA</span> = <span class="q">qw(Exporter DynaLoader)</span><span class="sc">;</span></li><li>     <span class="i">@EXPORT</span> = <span class="q">qw( rpcb_gettime )</span><span class="sc">;</span></li><li></li><li>     <span class="w">bootstrap</span> <span class="w">RPC</span><span class="sc">;</span></li><li>     <span class="n">1</span><span class="sc">;</span></li></ol></pre><p>Throughout this document a variety of interfaces to the rpcb_gettime()
XSUB will be explored.  The XSUBs will take their parameters in different
orders or will take different numbers of parameters.  In each case the
XSUB is an abstraction between Perl and the real C rpcb_gettime()
function, and the XSUB must always ensure that the real rpcb_gettime()
function is called with the correct parameters.  This abstraction will
allow the programmer to create a more Perl-like interface to the C
function.</p>
<a name="The-Anatomy-of-an-XSUB"></a><h2>The Anatomy of an XSUB</h2>
<p>The simplest XSUBs consist of 3 parts: a description of the return
value, the name of the XSUB routine and the names of its arguments,
and a description of types or formats of the arguments.</p>
<p>The following XSUB allows a Perl program to access a C library function
called sin().  The XSUB will imitate the C function which takes a single
argument and returns a single value.</p>
<pre class="verbatim"><ol><li>     double</li><li>     sin(x)</li><li>       double x</li></ol></pre><p>Optionally, one can merge the description of types and the list of
argument names, rewriting this as</p>
<pre class="verbatim"><ol><li>     <span class="w">double</span></li><li>     <a class="l_k" href="functions/sin.html">sin</a><span class="s">(</span><span class="w">double</span> <span class="w">x</span><span class="s">)</span></li></ol></pre><p>This makes this XSUB look similar to an ANSI C declaration.  An optional
semicolon is allowed after the argument list, as in</p>
<pre class="verbatim"><ol><li>     <span class="w">double</span></li><li>     <a class="l_k" href="functions/sin.html">sin</a><span class="s">(</span><span class="w">double</span> <span class="w">x</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>Parameters with C pointer types can have different semantic: C functions
with similar declarations</p>
<pre class="verbatim"><ol><li>     bool string_looks_as_a_number(char *s);</li><li>     bool make_char_uppercase(char *c);</li></ol></pre><p>are used in absolutely incompatible manner.  Parameters to these functions
could be described <b>xsubpp</b> like this:</p>
<pre class="verbatim"><ol><li>     char *  s</li><li>     char    &amp;c</li></ol></pre><p>Both these XS declarations correspond to the <code class="inline"><span class="w">char</span>*</code>
 C type, but they have
different semantics, see <a href="#The-%26-Unary-Operator">The &amp; Unary Operator</a>.</p>
<p>It is convenient to think that the indirection operator
<code class="inline"><span class="i">*</span></code>
 should be considered as a part of the type and the address operator <code class="inline"><span class="i">&amp;</span></code>

should be considered part of the variable.  See <a href="perlxstypemap.html">perlxstypemap</a>
for more info about handling qualifiers and unary operators in C types.</p>
<p>The function name and the return type must be placed on
separate lines and should be flush left-adjusted.</p>
<pre class="verbatim"><ol><li>  INCORRECT                        CORRECT</li><li></li><li>  double sin(x)                    double</li><li>    double x                       sin(x)</li><li>				     double x</li></ol></pre><p>The rest of the function description may be indented or left-adjusted. The
following example shows a function with its body left-adjusted.  Most
examples in this document will indent the body for better readability.</p>
<pre class="verbatim"><ol><li>  CORRECT</li><li></li><li>  double</li><li>  sin(x)</li><li>  double x</li></ol></pre><p>More complicated XSUBs may contain many other sections.  Each section of
an XSUB starts with the corresponding keyword, such as INIT: or CLEANUP:.
However, the first two lines of an XSUB always contain the same data:
descriptions of the return type and the names of the function and its
parameters.  Whatever immediately follows these is considered to be
an INPUT: section unless explicitly marked with another keyword.
(See <a href="#The-INPUT%3a-Keyword">The INPUT: Keyword</a>.)</p>
<p>An XSUB section continues until another section-start keyword is found.</p>
<a name="The-Argument-Stack"></a><h2>The Argument Stack</h2>
<p>The Perl argument stack is used to store the values which are
sent as parameters to the XSUB and to store the XSUB's
return value(s).  In reality all Perl functions (including non-XSUB
ones) keep their values on this stack all the same time, each limited
to its own range of positions on the stack.  In this document the
first position on that stack which belongs to the active
function will be referred to as position 0 for that function.</p>
<p>XSUBs refer to their stack arguments with the macro <b>ST(x)</b>, where <i>x</i>
refers to a position in this XSUB's part of the stack.  Position 0 for that
function would be known to the XSUB as ST(0).  The XSUB's incoming
parameters and outgoing return values always begin at ST(0).  For many
simple cases the <b>xsubpp</b> compiler will generate the code necessary to
handle the argument stack by embedding code fragments found in the
typemaps.  In more complex cases the programmer must supply the code.</p>
<a name="The-RETVAL-Variable"></a><h2>The RETVAL Variable</h2>
<p>The RETVAL variable is a special C variable that is declared automatically
for you.  The C type of RETVAL matches the return type of the C library
function.  The <b>xsubpp</b> compiler will declare this variable in each XSUB
with non-<code class="inline"><span class="w">void</span></code>
 return type.  By default the generated C function
will use RETVAL to hold the return value of the C library function being
called.  In simple cases the value of RETVAL will be placed in ST(0) of
the argument stack where it can be received by Perl as the return value
of the XSUB.</p>
<p>If the XSUB has a return type of <code class="inline"><span class="w">void</span></code>
 then the compiler will
not declare a RETVAL variable for that function.  When using
a PPCODE: section no manipulation of the RETVAL variable is required, the
section may use direct stack manipulation to place output values on the stack.</p>
<p>If PPCODE: directive is not used, <code class="inline"><span class="w">void</span></code>
 return value should be used
only for subroutines which do not return a value, <i>even if</i> CODE:
directive is used which sets ST(0) explicitly.</p>
<p>Older versions of this document recommended to use <code class="inline"><span class="w">void</span></code>
 return
value in such cases. It was discovered that this could lead to
segfaults in cases when XSUB was <i>truly</i> <code class="inline"><span class="w">void</span></code>
. This practice is
now deprecated, and may be not supported at some future version. Use
the return value <code class="inline"><span class="w">SV</span> *</code>
 in such cases. (Currently <code class="inline"><span class="w">xsubpp</span></code>
 contains
some heuristic code which tries to disambiguate between "truly-void"
and "old-practice-declared-as-void" functions. Hence your code is at
mercy of this heuristics unless you use <code class="inline"><span class="w">SV</span> *</code>
 as return value.)</p>
<a name="Returning-SVs%2c-AVs-and-HVs-through-RETVAL"></a><h2>Returning SVs, AVs and HVs through RETVAL</h2>
<p>When you're using RETVAL to return an <code class="inline"><span class="w">SV</span> *</code>
, there's some magic
going on behind the scenes that should be mentioned. When you're
manipulating the argument stack using the ST(x) macro, for example,
you usually have to pay special attention to reference counts. (For
more about reference counts, see <a href="perlguts.html">perlguts</a>.) To make your life
easier, the typemap file automatically makes <code class="inline"><span class="w">RETVAL</span></code>
 mortal when
you're returning an <code class="inline"><span class="w">SV</span> *</code>
. Thus, the following two XSUBs are more
or less equivalent:</p>
<pre class="verbatim"><ol><li>  void</li><li>  alpha()</li><li>      PPCODE:</li><li>          ST(0) = newSVpv("Hello World",0);</li><li>          sv_2mortal(ST(0));</li><li>          XSRETURN(1);</li><li></li><li>  SV *</li><li>  beta()</li><li>      CODE:</li><li>          RETVAL = newSVpv("Hello World",0);</li><li>      OUTPUT:</li><li>          RETVAL</li></ol></pre><p>This is quite useful as it usually improves readability. While
this works fine for an <code class="inline"><span class="w">SV</span> *</code>
, it's unfortunately not as easy
to have <code class="inline"><span class="w">AV</span> *</code>
 or <code class="inline"><span class="w">HV</span> *</code>
 as a return value. You <i>should</i> be
able to write:</p>
<pre class="verbatim"><ol><li>  AV *</li><li>  array()</li><li>      CODE:</li><li>          RETVAL = newAV();</li><li>          /* do something with RETVAL */</li><li>      OUTPUT:</li><li>          RETVAL</li></ol></pre><p>But due to an unfixable bug (fixing it would break lots of existing
CPAN modules) in the typemap file, the reference count of the <code class="inline"><span class="w">AV</span> *</code>

is not properly decremented. Thus, the above XSUB would leak memory
whenever it is being called. The same problem exists for <code class="inline"><span class="w">HV</span> *</code>
,
<code class="inline"><span class="w">CV</span> *</code>
, and <code class="inline"><span class="w">SVREF</span></code>
 (which indicates a scalar reference, not
a general <code class="inline"><span class="w">SV</span> *</code>
).
In XS code on perls starting with perl 5.16, you can override the
typemaps for any of these types with a version that has proper
handling of refcounts. In your <code class="inline"><span class="w">TYPEMAP</span></code>
 section, do</p>
<pre class="verbatim"><ol><li>  <span class="w">AV</span>*	<span class="w">T_AVREF_REFCOUNT_FIXED</span></li></ol></pre><p>to get the repaired variant. For backward compatibility with older
versions of perl, you can instead decrement the reference count
manually when you're returning one of the aforementioned
types using <code class="inline"><span class="w">sv_2mortal</span></code>
:</p>
<pre class="verbatim"><ol><li>  AV *</li><li>  array()</li><li>      CODE:</li><li>          RETVAL = newAV();</li><li>          sv_2mortal((SV*)RETVAL);</li><li>          /* do something with RETVAL */</li><li>      OUTPUT:</li><li>          RETVAL</li></ol></pre><p>Remember that you don't have to do this for an <code class="inline"><span class="w">SV</span> *</code>
. The reference
documentation for all core typemaps can be found in <a href="perlxstypemap.html">perlxstypemap</a>.</p>
<a name="The-MODULE-Keyword"></a><h2>The MODULE Keyword</h2>
<p>The MODULE keyword is used to start the XS code and to specify the package
of the functions which are being defined.  All text preceding the first
MODULE keyword is considered C code and is passed through to the output with
POD stripped, but otherwise untouched.  Every XS module will have a
bootstrap function which is used to hook the XSUBs into Perl.  The package
name of this bootstrap function will match the value of the last MODULE
statement in the XS source files.  The value of MODULE should always remain
constant within the same XS file, though this is not required.</p>
<p>The following example will start the XS code and will place
all functions in a package named RPC.</p>
<pre class="verbatim"><ol><li>     <span class="w">MODULE</span> = <span class="w">RPC</span></li></ol></pre><a name="The-PACKAGE-Keyword"></a><h2>The PACKAGE Keyword</h2>
<p>When functions within an XS source file must be separated into packages
the PACKAGE keyword should be used.  This keyword is used with the MODULE
keyword and must follow immediately after it when used.</p>
<pre class="verbatim"><ol><li>     MODULE = RPC  PACKAGE = RPC</li><li></li><li>     [ XS code in package RPC ]</li><li></li><li>     MODULE = RPC  PACKAGE = RPCB</li><li></li><li>     [ XS code in package RPCB ]</li><li></li><li>     MODULE = RPC  PACKAGE = RPC</li><li></li><li>     [ XS code in package RPC ]</li></ol></pre><p>The same package name can be used more than once, allowing for
non-contiguous code. This is useful if you have a stronger ordering
principle than package names.</p>
<p>Although this keyword is optional and in some cases provides redundant
information it should always be used.  This keyword will ensure that the
XSUBs appear in the desired package.</p>
<a name="The-PREFIX-Keyword"></a><h2>The PREFIX Keyword</h2>
<p>The PREFIX keyword designates prefixes which should be
removed from the Perl function names.  If the C function is
<code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span></code>
 and the PREFIX value is <code class="inline"><span class="w">rpcb_</span></code>
 then Perl will
see this function as <code class="inline"><span class="i">gettime</span><span class="s">(</span><span class="s">)</span></code>
.</p>
<p>This keyword should follow the PACKAGE keyword when used.
If PACKAGE is not used then PREFIX should follow the MODULE
keyword.</p>
<pre class="verbatim"><ol><li>     <span class="w">MODULE</span> = <span class="w">RPC</span>  <span class="w">PREFIX</span> = <span class="w">rpc_</span></li><li></li><li>     <span class="w">MODULE</span> = <span class="w">RPC</span>  <span class="w">PACKAGE</span> = <span class="w">RPCB</span>  <span class="w">PREFIX</span> = <span class="w">rpcb_</span></li></ol></pre><a name="The-OUTPUT%3a-Keyword"></a><h2>The OUTPUT: Keyword</h2>
<p>The OUTPUT: keyword indicates that certain function parameters should be
updated (new values made visible to Perl) when the XSUB terminates or that
certain values should be returned to the calling Perl function.  For
simple functions which have no CODE: or PPCODE: section,
such as the sin() function above, the RETVAL variable is
automatically designated as an output value.  For more complex functions
the <b>xsubpp</b> compiler will need help to determine which variables are output
variables.</p>
<p>This keyword will normally be used to complement the CODE:  keyword.
The RETVAL variable is not recognized as an output variable when the
CODE: keyword is present.  The OUTPUT:  keyword is used in this
situation to tell the compiler that RETVAL really is an output
variable.</p>
<p>The OUTPUT: keyword can also be used to indicate that function parameters
are output variables.  This may be necessary when a parameter has been
modified within the function and the programmer would like the update to
be seen by Perl.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t &amp;timep</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><p>The OUTPUT: keyword will also allow an output parameter to
be mapped to a matching piece of code rather than to a
typemap.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t &amp;timep</li><li>        OUTPUT:</li><li>          timep sv_setnv(ST(1), (double)timep);</li></ol></pre><p><b>xsubpp</b> emits an automatic <code class="inline"><span class="i">SvSETMAGIC</span><span class="s">(</span><span class="s">)</span></code>
 for all parameters in the
OUTPUT section of the XSUB, except RETVAL.  This is the usually desired
behavior, as it takes care of properly invoking 'set' magic on output
parameters (needed for hash or array element parameters that must be
created if they didn't exist).  If for some reason, this behavior is
not desired, the OUTPUT section may contain a <code class="inline"><span class="j">SETMAGIC:</span> <span class="w">DISABLE</span></code>
 line
to disable it for the remainder of the parameters in the OUTPUT section.
Likewise,  <code class="inline"><span class="j">SETMAGIC:</span> <span class="w">ENABLE</span></code>
 can be used to reenable it for the
remainder of the OUTPUT section.  See <a href="perlguts.html">perlguts</a> for more details
about 'set' magic.</p>
<a name="The-NO_OUTPUT-Keyword"></a><h2>The NO_OUTPUT Keyword</h2>
<p>The NO_OUTPUT can be placed as the first token of the XSUB.  This keyword
indicates that while the C subroutine we provide an interface to has
a non-<code class="inline"><span class="w">void</span></code>
 return type, the return value of this C subroutine should not
be returned from the generated Perl subroutine.</p>
<p>With this keyword present <a href="#The-RETVAL-Variable">The RETVAL Variable</a> is created, and in the
generated call to the subroutine this variable is assigned to, but the value
of this variable is not going to be used in the auto-generated code.</p>
<p>This keyword makes sense only if <code class="inline"><span class="w">RETVAL</span></code>
 is going to be accessed by the
user-supplied code.  It is especially useful to make a function interface
more Perl-like, especially when the C return value is just an error condition
indicator.  For example,</p>
<pre class="verbatim"><ol><li>  NO_OUTPUT int</li><li>  delete_file(char *name)</li><li>    POSTCALL:</li><li>      if (RETVAL != 0)</li><li>	  croak("Error %d while deleting file '%s'", RETVAL, name);</li></ol></pre><p>Here the generated XS function returns nothing on success, and will die()
with a meaningful error message on error.</p>
<a name="The-CODE%3a-Keyword"></a><h2>The CODE: Keyword</h2>
<p>This keyword is used in more complicated XSUBs which require
special handling for the C function.  The RETVAL variable is
still declared, but it will not be returned unless it is specified
in the OUTPUT: section.</p>
<p>The following XSUB is for a C function which requires special handling of
its parameters.  The Perl usage is given first.</p>
<pre class="verbatim"><ol><li>     <span class="i">$status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="q">&quot;localhost&quot;</span><span class="cm">,</span> <span class="i">$timep</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The XSUB follows.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t timep</li><li>        CODE:</li><li>               RETVAL = rpcb_gettime( host, &amp;timep );</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><a name="The-INIT%3a-Keyword"></a><h2>The INIT: Keyword</h2>
<p>The INIT: keyword allows initialization to be inserted into the XSUB before
the compiler generates the call to the C function.  Unlike the CODE: keyword
above, this keyword does not affect the way the compiler handles RETVAL.</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t &amp;timep</li><li>	INIT:</li><li>	  printf("# Host is %s\n", host );</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><p>Another use for the INIT: section is to check for preconditions before
making a call to the C function:</p>
<pre class="verbatim"><ol><li>    long long</li><li>    lldiv(a,b)</li><li>	long long a</li><li>	long long b</li><li>      INIT:</li><li>	if (a == 0 &amp;&amp; b == 0)</li><li>	    XSRETURN_UNDEF;</li><li>	if (b == 0)</li><li>	    croak("lldiv: cannot divide by 0");</li></ol></pre><a name="The-NO_INIT-Keyword"></a><h2>The NO_INIT Keyword</h2>
<p>The NO_INIT keyword is used to indicate that a function
parameter is being used only as an output value.  The <b>xsubpp</b>
compiler will normally generate code to read the values of
all function parameters from the argument stack and assign
them to C variables upon entry to the function.  NO_INIT
will tell the compiler that some parameters will be used for
output rather than for input and that they will be handled
before the function terminates.</p>
<p>The following example shows a variation of the rpcb_gettime() function.
This function uses the timep variable only as an output variable and does
not care about its initial contents.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t &amp;timep = NO_INIT</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><a name="The-TYPEMAP%3a-Keyword"></a><h2>The TYPEMAP: Keyword</h2>
<p>Starting with Perl 5.16, you can embed typemaps into your XS code
instead of or in addition to typemaps in a separate file.  Multiple
such embedded typemaps will be processed in order of appearance in
the XS code and like local typemap files take precedence over the
default typemap, the embedded typemaps may overwrite previous
definitions of TYPEMAP, INPUT, and OUTPUT stanzas.  The syntax for
embedded typemaps is</p>
<pre class="verbatim"><ol><li>      <span class="j">TYPEMAP:</span> <span class="h">&lt;&lt;HERE</span></li><li><span class="hh">      ... your typemap code here ...</span></li><li><span class="hh">      HERE</span></li></ol></pre><p>where the <code class="inline"><span class="w">TYPEMAP</span></code>
 keyword must appear in the first column of a
new line.</p>
<p>Refer to <a href="perlxstypemap.html">perlxstypemap</a> for details on writing typemaps.</p>
<a name="Initializing-Function-Parameters"></a><h2>Initializing Function Parameters</h2>
<p>C function parameters are normally initialized with their values from
the argument stack (which in turn contains the parameters that were
passed to the XSUB from Perl).  The typemaps contain the
code segments which are used to translate the Perl values to
the C parameters.  The programmer, however, is allowed to
override the typemaps and supply alternate (or additional)
initialization code.  Initialization code starts with the first
<code class="inline">=</code>
, <code class="inline"><span class="sc">;</span></code>
 or <code class="inline">+</code>
 on a line in the INPUT: section.  The only
exception happens if this <code class="inline"><span class="sc">;</span></code>
 terminates the line, then this <code class="inline"><span class="sc">;</span></code>

is quietly ignored.</p>
<p>The following code demonstrates how to supply initialization code for
function parameters.  The initialization code is eval'ed within double
quotes by the compiler before it is added to the output so anything
which should be interpreted literally [mainly <code class="inline"><span class="i">$</span></code>
, <code class="inline"><span class="i">@</span></code>
, or <code class="inline">\\</code>
]
must be protected with backslashes.  The variables <code class="inline"><span class="i">$var</span></code>
, <code class="inline"><span class="i">$arg</span></code>
,
and <code class="inline"><span class="i">$type</span></code>
 can be used as in typemaps.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(host,timep)</li><li>          char *host = (char *)SvPV_nolen($arg);</li><li>          time_t &amp;timep = 0;</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><p>This should not be used to supply default values for parameters.  One
would normally use this when a function parameter must be processed by
another library function before it can be used.  Default parameters are
covered in the next section.</p>
<p>If the initialization begins with <code class="inline">=</code>
, then it is output in
the declaration for the input variable, replacing the initialization
supplied by the typemap.  If the initialization
begins with <code class="inline"><span class="sc">;</span></code>
 or <code class="inline">+</code>
, then it is performed after
all of the input variables have been declared.  In the <code class="inline"><span class="sc">;</span></code>

case the initialization normally supplied by the typemap is not performed.
For the <code class="inline">+</code>
 case, the declaration for the variable will include the
initialization from the typemap.  A global
variable, <code class="inline"><span class="i">%v</span></code>
, is available for the truly rare case where
information from one initialization is needed in another
initialization.</p>
<p>Here's a truly obscure example:</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(host,timep)</li><li>          time_t &amp;timep; /* \$v{timep}=@{[$v{timep}=$arg]} */</li><li>          char *host + SvOK($v{timep}) ? SvPV_nolen($arg) : NULL;</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><p>The construct <code class="inline">\<span class="i">$v</span>{<span class="w">timep</span>}=<span class="i">@</span>{<span class="s">[</span><span class="i">$v</span>{<span class="w">timep</span>}=<span class="i">$arg</span><span class="s">]</span>}</code>
 used in the above
example has a two-fold purpose: first, when this line is processed by
<b>xsubpp</b>, the Perl snippet <code class="inline"><span class="i">$v</span>{<span class="w">timep</span>}=<span class="i">$arg</span></code>
 is evaluated.  Second,
the text of the evaluated snippet is output into the generated C file
(inside a C comment)!  During the processing of <code class="inline"><span class="w">char</span> *<span class="w">host</span></code>
 line,
<code class="inline"><span class="i">$arg</span></code>
 will evaluate to <code class="inline"><span class="i">ST</span><span class="s">(</span><span class="n">0</span><span class="s">)</span></code>
, and <code class="inline"><span class="i">$v</span>{<span class="w">timep</span>}</code>
 will evaluate to
<code class="inline"><span class="i">ST</span><span class="s">(</span><span class="n">1</span><span class="s">)</span></code>
.</p>
<a name="Default-Parameter-Values"></a><h2>Default Parameter Values</h2>
<p>Default values for XSUB arguments can be specified by placing an
assignment statement in the parameter list.  The default value may
be a number, a string or the special string <code class="inline"><span class="w">NO_INIT</span></code>
.  Defaults should
always be used on the right-most parameters only.</p>
<p>To allow the XSUB for rpcb_gettime() to have a default host
value the parameters to the XSUB could be rearranged.  The
XSUB will then call the real rpcb_gettime() function with
the parameters in the correct order.  This XSUB can be called
from Perl with either of the following statements:</p>
<pre class="verbatim"><ol><li>     <span class="i">$status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="i">$timep</span><span class="cm">,</span> <span class="i">$host</span> <span class="s">)</span><span class="sc">;</span></li><li></li><li>     <span class="i">$status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="i">$timep</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The XSUB will look like the code  which  follows.   A  CODE:
block  is used to call the real rpcb_gettime() function with
the parameters in the correct order for that function.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(timep,host="localhost")</li><li>          char *host</li><li>          time_t timep = NO_INIT</li><li>        CODE:</li><li>               RETVAL = rpcb_gettime( host, &amp;timep );</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><a name="The-PREINIT%3a-Keyword"></a><h2>The PREINIT: Keyword</h2>
<p>The PREINIT: keyword allows extra variables to be declared immediately
before or after the declarations of the parameters from the INPUT: section
are emitted.</p>
<p>If a variable is declared inside a CODE: section it will follow any typemap
code that is emitted for the input parameters.  This may result in the
declaration ending up after C code, which is C syntax error.  Similar
errors may happen with an explicit <code class="inline"><span class="sc">;</span></code>
-type or <code class="inline">+</code>
-type initialization of
parameters is used (see <a href="#Initializing-Function-Parameters">Initializing Function Parameters</a>).  Declaring
these variables in an INIT: section will not help.</p>
<p>In such cases, to force an additional variable to be declared together
with declarations of other variables, place the declaration into a
PREINIT: section.  The PREINIT: keyword may be used one or more times
within an XSUB.</p>
<p>The following examples are equivalent, but if the code is using complex
typemaps then the first example is safer.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(timep)</li><li>          time_t timep = NO_INIT</li><li>	PREINIT:</li><li>          char *host = "localhost";</li><li>        CODE:</li><li>	  RETVAL = rpcb_gettime( host, &amp;timep );</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><p>For this particular case an INIT: keyword would generate the
same C code as the PREINIT: keyword.  Another correct, but error-prone example:</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(timep)</li><li>          time_t timep = NO_INIT</li><li>	CODE:</li><li>          char *host = "localhost";</li><li>	  RETVAL = rpcb_gettime( host, &amp;timep );</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><p>Another way to declare <code class="inline"><span class="w">host</span></code>
 is to use a C block in the CODE: section:</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(timep)</li><li>          time_t timep = NO_INIT</li><li>	CODE:</li><li>	  {</li><li>            char *host = "localhost";</li><li>	    RETVAL = rpcb_gettime( host, &amp;timep );</li><li>	  }</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><p>The ability to put additional declarations before the typemap entries are
processed is very handy in the cases when typemap conversions manipulate
some global state:</p>
<pre class="verbatim"><ol><li>    MyObject</li><li>    mutate(o)</li><li>	PREINIT:</li><li>	    MyState st = global_state;</li><li>	INPUT:</li><li>	    MyObject o;</li><li>	CLEANUP:</li><li>	    reset_to(global_state, st);</li></ol></pre><p>Here we suppose that conversion to <code class="inline"><span class="w">MyObject</span></code>
 in the INPUT: section and from
MyObject when processing RETVAL will modify a global variable <code class="inline"><span class="w">global_state</span></code>
.
After these conversions are performed, we restore the old value of
<code class="inline"><span class="w">global_state</span></code>
 (to avoid memory leaks, for example).</p>
<p>There is another way to trade clarity for compactness: INPUT sections allow
declaration of C variables which do not appear in the parameter list of
a subroutine.  Thus the above code for mutate() can be rewritten as</p>
<pre class="verbatim"><ol><li>    MyObject</li><li>    mutate(o)</li><li>	  MyState st = global_state;</li><li>	  MyObject o;</li><li>	CLEANUP:</li><li>	  reset_to(global_state, st);</li></ol></pre><p>and the code for rpcb_gettime() can be rewritten as</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(timep)</li><li>	  time_t timep = NO_INIT</li><li>	  char *host = "localhost";</li><li>	C_ARGS:</li><li>	  host, &amp;timep</li><li>	OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><a name="The-SCOPE%3a-Keyword"></a><h2>The SCOPE: Keyword</h2>
<p>The SCOPE: keyword allows scoping to be enabled for a particular XSUB. If
enabled, the XSUB will invoke ENTER and LEAVE automatically.</p>
<p>To support potentially complex type mappings, if a typemap entry used
by an XSUB contains a comment like <code class="inline"><span class="q">/*scope*/</span></code>
 then scoping will
be automatically enabled for that XSUB.</p>
<p>To enable scoping:</p>
<pre class="verbatim"><ol><li>    <span class="j">SCOPE:</span> <span class="w">ENABLE</span></li></ol></pre><p>To disable scoping:</p>
<pre class="verbatim"><ol><li>    <span class="j">SCOPE:</span> <span class="w">DISABLE</span></li></ol></pre><a name="The-INPUT%3a-Keyword"></a><h2>The INPUT: Keyword</h2>
<p>The XSUB's parameters are usually evaluated immediately after entering the
XSUB.  The INPUT: keyword can be used to force those parameters to be
evaluated a little later.  The INPUT: keyword can be used multiple times
within an XSUB and can be used to list one or more input variables.  This
keyword is used with the PREINIT: keyword.</p>
<p>The following example shows how the input parameter <code class="inline"><span class="w">timep</span></code>
 can be
evaluated late, after a PREINIT.</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>          char *host</li><li>	PREINIT:</li><li>	  time_t tt;</li><li>	INPUT:</li><li>          time_t timep</li><li>        CODE:</li><li>               RETVAL = rpcb_gettime( host, &amp;tt );</li><li>	       timep = tt;</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><p>The next example shows each input parameter evaluated late.</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>	PREINIT:</li><li>	  time_t tt;</li><li>	INPUT:</li><li>          char *host</li><li>	PREINIT:</li><li>	  char *h;</li><li>	INPUT:</li><li>          time_t timep</li><li>        CODE:</li><li>	       h = host;</li><li>	       RETVAL = rpcb_gettime( h, &amp;tt );</li><li>	       timep = tt;</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><p>Since INPUT sections allow declaration of C variables which do not appear
in the parameter list of a subroutine, this may be shortened to:</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>	  time_t tt;</li><li>          char *host;</li><li>	  char *h = host;</li><li>          time_t timep;</li><li>        CODE:</li><li>	  RETVAL = rpcb_gettime( h, &amp;tt );</li><li>	  timep = tt;</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><p>(We used our knowledge that input conversion for <code class="inline"><span class="w">char</span> *</code>
 is a "simple" one,
thus <code class="inline"><span class="w">host</span></code>
 is initialized on the declaration line, and our assignment
<code class="inline"><span class="w">h</span> = <span class="w">host</span></code>
 is not performed too early.  Otherwise one would need to have the
assignment <code class="inline"><span class="w">h</span> = <span class="w">host</span></code>
 in a CODE: or INIT: section.)</p>
<a name="The-IN%2fOUTLIST%2fIN_OUTLIST%2fOUT%2fIN_OUT-Keywords"></a><h2>The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</h2>
<p>In the list of parameters for an XSUB, one can precede parameter names
by the <code class="inline"><span class="w">IN</span></code>
/<code class="inline"><span class="w">OUTLIST</span></code>
/<code class="inline"><span class="w">IN_OUTLIST</span></code>
/<code class="inline"><span class="w">OUT</span></code>
/<code class="inline"><span class="w">IN_OUT</span></code>
 keywords.
<code class="inline"><span class="w">IN</span></code>
 keyword is the default, the other keywords indicate how the Perl
interface should differ from the C interface.</p>
<p>Parameters preceded by <code class="inline"><span class="w">OUTLIST</span></code>
/<code class="inline"><span class="w">IN_OUTLIST</span></code>
/<code class="inline"><span class="w">OUT</span></code>
/<code class="inline"><span class="w">IN_OUT</span></code>

keywords are considered to be used by the C subroutine <i>via
pointers</i>.  <code class="inline"><span class="w">OUTLIST</span></code>
/<code class="inline"><span class="w">OUT</span></code>
 keywords indicate that the C subroutine
does not inspect the memory pointed by this parameter, but will write
through this pointer to provide additional return values.</p>
<p>Parameters preceded by <code class="inline"><span class="w">OUTLIST</span></code>
 keyword do not appear in the usage
signature of the generated Perl function.</p>
<p>Parameters preceded by <code class="inline"><span class="w">IN_OUTLIST</span></code>
/<code class="inline"><span class="w">IN_OUT</span></code>
/<code class="inline"><span class="w">OUT</span></code>
 <i>do</i> appear as
parameters to the Perl function.  With the exception of
<code class="inline"><span class="w">OUT</span></code>
-parameters, these parameters are converted to the corresponding
C type, then pointers to these data are given as arguments to the C
function.  It is expected that the C function will write through these
pointers.</p>
<p>The return list of the generated Perl function consists of the C return value
from the function (unless the XSUB is of <code class="inline"><span class="w">void</span></code>
 return type or
<code class="inline"><span class="w">The</span> <span class="w">NO_OUTPUT</span> <span class="w">Keyword</span></code>
 was used) followed by all the <code class="inline"><span class="w">OUTLIST</span></code>

and <code class="inline"><span class="w">IN_OUTLIST</span></code>
 parameters (in the order of appearance).  On the
return from the XSUB the <code class="inline"><span class="w">IN_OUT</span></code>
/<code class="inline"><span class="w">OUT</span></code>
 Perl parameter will be
modified to have the values written by the C function.</p>
<p>For example, an XSUB</p>
<pre class="verbatim"><ol><li>  <span class="w">void</span></li><li>  <span class="i">day_month</span><span class="s">(</span><span class="w">OUTLIST</span> <span class="w">day</span><span class="cm">,</span> <span class="w">IN</span> <span class="w">unix_time</span><span class="cm">,</span> <span class="w">OUTLIST</span> <span class="w">month</span><span class="s">)</span></li><li>    <a class="l_k" href="functions/int.html">int</a> <span class="w">day</span></li><li>    <a class="l_k" href="functions/int.html">int</a> <span class="w">unix_time</span></li><li>    <a class="l_k" href="functions/int.html">int</a> <span class="w">month</span></li></ol></pre><p>should be used from Perl as</p>
<pre class="verbatim"><ol><li>  <a class="l_k" href="functions/my.html">my</a> <span class="s">(</span><span class="i">$day</span><span class="cm">,</span> <span class="i">$month</span><span class="s">)</span> = <span class="i">day_month</span><span class="s">(</span><a class="l_k" href="functions/time.html">time</a><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The C signature of the corresponding function should be</p>
<pre class="verbatim"><ol><li>  <span class="w">void</span> <span class="i">day_month</span><span class="s">(</span><a class="l_k" href="functions/int.html">int</a> <span class="i">*day</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">unix_time</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="i">*month</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The <code class="inline"><span class="w">IN</span></code>
/<code class="inline"><span class="w">OUTLIST</span></code>
/<code class="inline"><span class="w">IN_OUTLIST</span></code>
/<code class="inline"><span class="w">IN_OUT</span></code>
/<code class="inline"><span class="w">OUT</span></code>
 keywords can be
mixed with ANSI-style declarations, as in</p>
<pre class="verbatim"><ol><li>  <span class="w">void</span></li><li>  <span class="i">day_month</span><span class="s">(</span><span class="w">OUTLIST</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">day</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">unix_time</span><span class="cm">,</span> <span class="w">OUTLIST</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">month</span><span class="s">)</span></li></ol></pre><p>(here the optional <code class="inline"><span class="w">IN</span></code>
 keyword is omitted).</p>
<p>The <code class="inline"><span class="w">IN_OUT</span></code>
 parameters are identical with parameters introduced with
<a href="#The-%26-Unary-Operator">The &amp; Unary Operator</a> and put into the <code class="inline"><span class="j">OUTPUT:</span></code>
 section (see
<a href="#The-OUTPUT%3a-Keyword">The OUTPUT: Keyword</a>).  The <code class="inline"><span class="w">IN_OUTLIST</span></code>
 parameters are very similar,
the only difference being that the value C function writes through the
pointer would not modify the Perl parameter, but is put in the output
list.</p>
<p>The <code class="inline"><span class="w">OUTLIST</span></code>
/<code class="inline"><span class="w">OUT</span></code>
 parameter differ from <code class="inline"><span class="w">IN_OUTLIST</span></code>
/<code class="inline"><span class="w">IN_OUT</span></code>

parameters only by the initial value of the Perl parameter not
being read (and not being given to the C function - which gets some
garbage instead).  For example, the same C function as above can be
interfaced with as</p>
<pre class="verbatim"><ol><li>  <span class="w">void</span> <span class="i">day_month</span><span class="s">(</span><span class="w">OUT</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">day</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">unix_time</span><span class="cm">,</span> <span class="w">OUT</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">month</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>or</p>
<pre class="verbatim"><ol><li>  void</li><li>  day_month(day, unix_time, month)</li><li>      int &amp;day = NO_INIT</li><li>      int  unix_time</li><li>      int &amp;month = NO_INIT</li><li>    OUTPUT:</li><li>      day</li><li>      month</li></ol></pre><p>However, the generated Perl function is called in very C-ish style:</p>
<pre class="verbatim"><ol><li>  <a class="l_k" href="functions/my.html">my</a> <span class="s">(</span><span class="i">$day</span><span class="cm">,</span> <span class="i">$month</span><span class="s">)</span><span class="sc">;</span></li><li>  <span class="i">day_month</span><span class="s">(</span><span class="i">$day</span><span class="cm">,</span> <a class="l_k" href="functions/time.html">time</a><span class="cm">,</span> <span class="i">$month</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><a name="The-length(NAME)-Keyword"></a><h2>The <code class="inline"><a class="l_k" href="functions/length.html">length(NAME)</a></code> Keyword</h2>
<p>If one of the input arguments to the C function is the length of a string
argument <code class="inline"><span class="w">NAME</span></code>
, one can substitute the name of the length-argument by
<code class="inline"><a class="l_k" href="functions/length.html">length(NAME)</a></code> in the XSUB declaration.  This argument must be omitted when
the generated Perl function is called.  E.g.,</p>
<pre class="verbatim"><ol><li>  void</li><li>  dump_chars(char *s, short l)</li><li>  {</li><li>    short n = 0;</li><li>    while (n &lt; l) {</li><li>        printf("s[%d] = \"\\%#03o\"\n", n, (int)s[n]);</li><li>        n++;</li><li>    }</li><li>  }</li><li></li><li>  MODULE = x		PACKAGE = x</li><li></li><li>  void dump_chars(char *s, short length(s))</li></ol></pre><p>should be called as <code class="inline"><span class="i">dump_chars</span><span class="s">(</span><span class="i">$string</span><span class="s">)</span></code>
.</p>
<p>This directive is supported with ANSI-type function declarations only.</p>
<a name="Variable-length-Parameter-Lists"></a><h2>Variable-length Parameter Lists</h2>
<p>XSUBs can have variable-length parameter lists by specifying an ellipsis
<code class="inline"><span class="s">(</span>...<span class="s">)</span></code>
 in the parameter list.  This use of the ellipsis is similar to that
found in ANSI C.  The programmer is able to determine the number of
arguments passed to the XSUB by examining the <code class="inline"><span class="w">items</span></code>
 variable which the
<b>xsubpp</b> compiler supplies for all XSUBs.  By using this mechanism one can
create an XSUB which accepts a list of parameters of unknown length.</p>
<p>The <i>host</i> parameter for the rpcb_gettime() XSUB can be
optional so the ellipsis can be used to indicate that the
XSUB will take a variable number of parameters.  Perl should
be able to call this XSUB with either of the following statements.</p>
<pre class="verbatim"><ol><li>     <span class="i">$status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="i">$timep</span><span class="cm">,</span> <span class="i">$host</span> <span class="s">)</span><span class="sc">;</span></li><li></li><li>     <span class="i">$status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="i">$timep</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The XS code, with ellipsis, follows.</p>
<pre class="verbatim"><ol><li>     bool_t</li><li>     rpcb_gettime(timep, ...)</li><li>          time_t timep = NO_INIT</li><li>	PREINIT:</li><li>          char *host = "localhost";</li><li>        CODE:</li><li>	  if( items &gt; 1 )</li><li>	       host = (char *)SvPV_nolen(ST(1));</li><li>	  RETVAL = rpcb_gettime( host, &amp;timep );</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><a name="The-C_ARGS%3a-Keyword"></a><h2>The C_ARGS: Keyword</h2>
<p>The C_ARGS: keyword allows creating of XSUBS which have different
calling sequence from Perl than from C, without a need to write
CODE: or PPCODE: section.  The contents of the C_ARGS: paragraph is
put as the argument to the called C function without any change.</p>
<p>For example, suppose that a C function is declared as</p>
<pre class="verbatim"><ol><li>    <span class="w">symbolic</span> <span class="i">nth_derivative</span><span class="s">(</span><a class="l_k" href="functions/int.html">int</a> <span class="w">n</span><span class="cm">,</span> <span class="w">symbolic</span> <span class="w">function</span><span class="cm">,</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">flags</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>and that the default flags are kept in a global C variable
<code class="inline"><span class="w">default_flags</span></code>
.  Suppose that you want to create an interface which
is called as</p>
<pre class="verbatim"><ol><li>    <span class="i">$second_deriv</span> = <span class="i">$function</span><span class="i">-&gt;nth_derivative</span><span class="s">(</span><span class="n">2</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>To do this, declare the XSUB as</p>
<pre class="verbatim"><ol><li>    symbolic</li><li>    nth_derivative(function, n)</li><li>	symbolic	function</li><li>	int		n</li><li>      C_ARGS:</li><li>	n, function, default_flags</li></ol></pre><a name="The-PPCODE%3a-Keyword"></a><h2>The PPCODE: Keyword</h2>
<p>The PPCODE: keyword is an alternate form of the CODE: keyword and is used
to tell the <b>xsubpp</b> compiler that the programmer is supplying the code to
control the argument stack for the XSUBs return values.  Occasionally one
will want an XSUB to return a list of values rather than a single value.
In these cases one must use PPCODE: and then explicitly push the list of
values on the stack.  The PPCODE: and CODE:  keywords should not be used
together within the same XSUB.</p>
<p>The actual difference between PPCODE: and CODE: sections is in the
initialization of <code class="inline"><span class="w">SP</span></code>
 macro (which stands for the <i>current</i> Perl
stack pointer), and in the handling of data on the stack when returning
from an XSUB.  In CODE: sections SP preserves the value which was on
entry to the XSUB: SP is on the function pointer (which follows the
last parameter).  In PPCODE: sections SP is moved backward to the
beginning of the parameter list, which allows <code class="inline"><span class="w">PUSH</span>*<span class="s">(</span><span class="s">)</span></code>
 macros
to place output values in the place Perl expects them to be when
the XSUB returns back to Perl.</p>
<p>The generated trailer for a CODE: section ensures that the number of return
values Perl will see is either 0 or 1 (depending on the <code class="inline"><span class="w">void</span></code>
ness of the
return value of the C function, and heuristics mentioned in
<a href="#The-RETVAL-Variable">The RETVAL Variable</a>).  The trailer generated for a PPCODE: section
is based on the number of return values and on the number of times
<code class="inline"><span class="w">SP</span></code>
 was updated by <code class="inline"><span class="s">[</span><span class="w">X</span><span class="s">]</span><span class="w">PUSH</span>*<span class="s">(</span><span class="s">)</span></code>
 macros.</p>
<p>Note that macros <code class="inline"><span class="i">ST</span><span class="s">(</span><span class="w">i</span><span class="s">)</span></code>
, <code class="inline"><span class="w">XST_m</span>*<span class="s">(</span><span class="s">)</span></code>
 and <code class="inline"><span class="w">XSRETURN</span>*<span class="s">(</span><span class="s">)</span></code>
 work equally
well in CODE: sections and PPCODE: sections.</p>
<p>The following XSUB will call the C rpcb_gettime() function
and will return its two output values, timep and status, to
Perl as a single list.</p>
<pre class="verbatim"><ol><li>     void</li><li>     rpcb_gettime(host)</li><li>          char *host</li><li>	PREINIT:</li><li>          time_t  timep;</li><li>          bool_t  status;</li><li>        PPCODE:</li><li>          status = rpcb_gettime( host, &amp;timep );</li><li>          EXTEND(SP, 2);</li><li>          PUSHs(sv_2mortal(newSViv(status)));</li><li>          PUSHs(sv_2mortal(newSViv(timep)));</li></ol></pre><p>Notice that the programmer must supply the C code necessary
to have the real rpcb_gettime() function called and to have
the return values properly placed on the argument stack.</p>
<p>The <code class="inline"><span class="w">void</span></code>
 return type for this function tells the <b>xsubpp</b> compiler that
the RETVAL variable is not needed or used and that it should not be created.
In most scenarios the void return type should be used with the PPCODE:
directive.</p>
<p>The EXTEND() macro is used to make room on the argument
stack for 2 return values.  The PPCODE: directive causes the
<b>xsubpp</b> compiler to create a stack pointer available as <code class="inline"><span class="w">SP</span></code>
, and it
is this pointer which is being used in the EXTEND() macro.
The values are then pushed onto the stack with the PUSHs()
macro.</p>
<p>Now the rpcb_gettime() function can be used from Perl with
the following statement.</p>
<pre class="verbatim"><ol><li>     <span class="s">(</span><span class="i">$status</span><span class="cm">,</span> <span class="i">$timep</span><span class="s">)</span> = <span class="i">rpcb_gettime</span><span class="s">(</span><span class="q">&quot;localhost&quot;</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>When handling output parameters with a PPCODE section, be sure to handle
'set' magic properly.  See <a href="perlguts.html">perlguts</a> for details about 'set' magic.</p>
<a name="Returning-Undef-And-Empty-Lists"></a><h2>Returning Undef And Empty Lists</h2>
<p>Occasionally the programmer will want to return simply
<code class="inline"><a class="l_k" href="functions/undef.html">undef</a></code> or an empty list if a function fails rather than a
separate status value.  The rpcb_gettime() function offers
just this situation.  If the function succeeds we would like
to have it return the time and if it fails we would like to
have undef returned.  In the following Perl code the value
of $timep will either be undef or it will be a valid time.</p>
<pre class="verbatim"><ol><li>     <span class="i">$timep</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="q">&quot;localhost&quot;</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The following XSUB uses the <code class="inline"><span class="w">SV</span> *</code>
 return type as a mnemonic only,
and uses a CODE: block to indicate to the compiler
that the programmer has supplied all the necessary code.  The
sv_newmortal() call will initialize the return value to undef, making that
the default return value.</p>
<pre class="verbatim"><ol><li>     SV *</li><li>     rpcb_gettime(host)</li><li>          char *  host</li><li>	PREINIT:</li><li>          time_t  timep;</li><li>          bool_t x;</li><li>        CODE:</li><li>          ST(0) = sv_newmortal();</li><li>          if( rpcb_gettime( host, &amp;timep ) )</li><li>               sv_setnv( ST(0), (double)timep);</li></ol></pre><p>The next example demonstrates how one would place an explicit undef in the
return value, should the need arise.</p>
<pre class="verbatim"><ol><li>     SV *</li><li>     rpcb_gettime(host)</li><li>          char *  host</li><li>	PREINIT:</li><li>          time_t  timep;</li><li>          bool_t x;</li><li>        CODE:</li><li>          if( rpcb_gettime( host, &amp;timep ) ){</li><li>               ST(0) = sv_newmortal();</li><li>               sv_setnv( ST(0), (double)timep);</li><li>          }</li><li>          else{</li><li>               ST(0) = &amp;PL_sv_undef;</li><li>          }</li></ol></pre><p>To return an empty list one must use a PPCODE: block and
then not push return values on the stack.</p>
<pre class="verbatim"><ol><li>     void</li><li>     rpcb_gettime(host)</li><li>          char *host</li><li>	PREINIT:</li><li>          time_t  timep;</li><li>        PPCODE:</li><li>          if( rpcb_gettime( host, &amp;timep ) )</li><li>               PUSHs(sv_2mortal(newSViv(timep)));</li><li>          else{</li><li>	      /* Nothing pushed on stack, so an empty</li><li>	       * list is implicitly returned. */</li><li>          }</li></ol></pre><p>Some people may be inclined to include an explicit <code class="inline"><a class="l_k" href="functions/return.html">return</a></code> in the above
XSUB, rather than letting control fall through to the end.  In those
situations <code class="inline"><span class="w">XSRETURN_EMPTY</span></code>
 should be used, instead.  This will ensure that
the XSUB stack is properly adjusted.  Consult <a href="perlapi.html">perlapi</a> for other
<code class="inline"><span class="w">XSRETURN</span></code>
 macros.</p>
<p>Since <code class="inline"><span class="w">XSRETURN_</span>*</code>
 macros can be used with CODE blocks as well, one can
rewrite this example as:</p>
<pre class="verbatim"><ol><li>     int</li><li>     rpcb_gettime(host)</li><li>          char *host</li><li>	PREINIT:</li><li>          time_t  timep;</li><li>        CODE:</li><li>          RETVAL = rpcb_gettime( host, &amp;timep );</li><li>	  if (RETVAL == 0)</li><li>		XSRETURN_UNDEF;</li><li>	OUTPUT:</li><li>	  RETVAL</li></ol></pre><p>In fact, one can put this check into a POSTCALL: section as well.  Together
with PREINIT: simplifications, this leads to:</p>
<pre class="verbatim"><ol><li>     int</li><li>     rpcb_gettime(host)</li><li>          char *host</li><li>          time_t  timep;</li><li>	POSTCALL:</li><li>	  if (RETVAL == 0)</li><li>		XSRETURN_UNDEF;</li></ol></pre><a name="The-REQUIRE%3a-Keyword"></a><h2>The REQUIRE: Keyword</h2>
<p>The REQUIRE: keyword is used to indicate the minimum version of the
<b>xsubpp</b> compiler needed to compile the XS module.  An XS module which
contains the following statement will compile with only <b>xsubpp</b> version
1.922 or greater:</p>
<pre class="verbatim"><ol><li>	<span class="j">REQUIRE:</span> <span class="n">1.922</span></li></ol></pre><a name="The-CLEANUP%3a-Keyword"></a><h2>The CLEANUP: Keyword</h2>
<p>This keyword can be used when an XSUB requires special cleanup procedures
before it terminates.  When the CLEANUP:  keyword is used it must follow
any CODE:, or OUTPUT: blocks which are present in the XSUB.  The code
specified for the cleanup block will be added as the last statements in
the XSUB.</p>
<a name="The-POSTCALL%3a-Keyword"></a><h2>The POSTCALL: Keyword</h2>
<p>This keyword can be used when an XSUB requires special procedures
executed after the C subroutine call is performed.  When the POSTCALL:
keyword is used it must precede OUTPUT: and CLEANUP: blocks which are
present in the XSUB.</p>
<p>See examples in <a href="#The-NO_OUTPUT-Keyword">The NO_OUTPUT Keyword</a> and <a href="#Returning-Undef-And-Empty-Lists">Returning Undef And Empty Lists</a>.</p>
<p>The POSTCALL: block does not make a lot of sense when the C subroutine
call is supplied by user by providing either CODE: or PPCODE: section.</p>
<a name="The-BOOT%3a-Keyword"></a><h2>The BOOT: Keyword</h2>
<p>The BOOT: keyword is used to add code to the extension's bootstrap
function.  The bootstrap function is generated by the <b>xsubpp</b> compiler and
normally holds the statements necessary to register any XSUBs with Perl.
With the BOOT: keyword the programmer can tell the compiler to add extra
statements to the bootstrap function.</p>
<p>This keyword may be used any time after the first MODULE keyword and should
appear on a line by itself.  The first blank line after the keyword will
terminate the code block.</p>
<pre class="verbatim"><ol><li>     <span class="j">BOOT:</span></li><li>     <span class="c"># The following message will be printed when the</span></li><li>     <span class="c"># bootstrap function executes.</span></li><li>     <a class="l_k" href="functions/printf.html">printf</a><span class="s">(</span><span class="q">&quot;Hello from the bootstrap!\n&quot;</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><a name="The-VERSIONCHECK%3a-Keyword"></a><h2>The VERSIONCHECK: Keyword</h2>
<p>The VERSIONCHECK: keyword corresponds to <b>xsubpp</b>'s <code class="inline">-<span class="w">versioncheck</span></code>
 and
<code class="inline">-<span class="w">noversioncheck</span></code>
 options.  This keyword overrides the command line
options.  Version checking is enabled by default.  When version checking is
enabled the XS module will attempt to verify that its version matches the
version of the PM module.</p>
<p>To enable version checking:</p>
<pre class="verbatim"><ol><li>    <span class="j">VERSIONCHECK:</span> <span class="w">ENABLE</span></li></ol></pre><p>To disable version checking:</p>
<pre class="verbatim"><ol><li>    <span class="j">VERSIONCHECK:</span> <span class="w">DISABLE</span></li></ol></pre><p>Note that if the version of the PM module is an NV (a floating point
number), it will be stringified with a possible loss of precision
(currently chopping to nine decimal places) so that it may not match
the version of the XS module anymore. Quoting the $VERSION declaration
to make it a string is recommended if long version numbers are used.</p>
<a name="The-PROTOTYPES%3a-Keyword"></a><h2>The PROTOTYPES: Keyword</h2>
<p>The PROTOTYPES: keyword corresponds to <b>xsubpp</b>'s <code class="inline">-<span class="w">prototypes</span></code>
 and
<code class="inline">-<span class="w">noprototypes</span></code>
 options.  This keyword overrides the command line options.
Prototypes are enabled by default.  When prototypes are enabled XSUBs will
be given Perl prototypes.  This keyword may be used multiple times in an XS
module to enable and disable prototypes for different parts of the module.</p>
<p>To enable prototypes:</p>
<pre class="verbatim"><ol><li>    <span class="j">PROTOTYPES:</span> <span class="w">ENABLE</span></li></ol></pre><p>To disable prototypes:</p>
<pre class="verbatim"><ol><li>    <span class="j">PROTOTYPES:</span> <span class="w">DISABLE</span></li></ol></pre><a name="The-PROTOTYPE%3a-Keyword"></a><h2>The PROTOTYPE: Keyword</h2>
<p>This keyword is similar to the PROTOTYPES: keyword above but can be used to
force <b>xsubpp</b> to use a specific prototype for the XSUB.  This keyword
overrides all other prototype options and keywords but affects only the
current XSUB.  Consult <a href="perlsub.html#Prototypes">Prototypes in perlsub</a> for information about Perl
prototypes.</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(timep, ...)</li><li>          time_t timep = NO_INIT</li><li>	PROTOTYPE: $;$</li><li>	PREINIT:</li><li>          char *host = "localhost";</li><li>        CODE:</li><li>		  if( items &gt; 1 )</li><li>		       host = (char *)SvPV_nolen(ST(1));</li><li>		  RETVAL = rpcb_gettime( host, &amp;timep );</li><li>        OUTPUT:</li><li>          timep</li><li>          RETVAL</li></ol></pre><p>If the prototypes are enabled, you can disable it locally for a given
XSUB as in the following example:</p>
<pre class="verbatim"><ol><li>    void</li><li>    rpcb_gettime_noproto()</li><li>        PROTOTYPE: DISABLE</li><li>    ...</li></ol></pre><a name="The-ALIAS%3a-Keyword"></a><h2>The ALIAS: Keyword</h2>
<p>The ALIAS: keyword allows an XSUB to have two or more unique Perl names
and to know which of those names was used when it was invoked.  The Perl
names may be fully-qualified with package names.  Each alias is given an
index.  The compiler will setup a variable called <code class="inline"><span class="w">ix</span></code>
 which contain the
index of the alias which was used.  When the XSUB is called with its
declared name <code class="inline"><span class="w">ix</span></code>
 will be 0.</p>
<p>The following example will create aliases <code class="inline"><span class="i">FOO::gettime</span><span class="s">(</span><span class="s">)</span></code>
 and
<code class="inline"><span class="i">BAR::getit</span><span class="s">(</span><span class="s">)</span></code>
 for this function.</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t &amp;timep</li><li>	ALIAS:</li><li>	    FOO::gettime = 1</li><li>	    BAR::getit = 2</li><li>	INIT:</li><li>	  printf("# ix = %d\n", ix );</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><a name="The-OVERLOAD%3a-Keyword"></a><h2>The OVERLOAD: Keyword</h2>
<p>Instead of writing an overloaded interface using pure Perl, you
can also use the OVERLOAD keyword to define additional Perl names
for your functions (like the ALIAS: keyword above).  However, the
overloaded functions must be defined with three parameters (except
for the nomethod() function which needs four parameters).  If any
function has the OVERLOAD: keyword, several additional lines
will be defined in the c file generated by xsubpp in order to
register with the overload magic.</p>
<p>Since blessed objects are actually stored as RV's, it is useful
to use the typemap features to preprocess parameters and extract
the actual SV stored within the blessed RV.  See the sample for
T_PTROBJ_SPECIAL below.</p>
<p>To use the OVERLOAD: keyword, create an XS function which takes
three input parameters ( or use the c style '...' definition) like
this:</p>
<pre class="verbatim"><ol><li>    SV *</li><li>    cmp (lobj, robj, swap)</li><li>    My_Module_obj    lobj</li><li>    My_Module_obj    robj</li><li>    IV               swap</li><li>    OVERLOAD: cmp &lt;=&gt;</li><li>    { /* function defined here */}</li></ol></pre><p>In this case, the function will overload both of the three way
comparison operators.  For all overload operations using non-alpha
characters, you must type the parameter without quoting, separating
multiple overloads with whitespace.  Note that "" (the stringify
overload) should be entered as \"\" (i.e. escaped).</p>
<a name="The-FALLBACK%3a-Keyword"></a><h2>The FALLBACK: Keyword</h2>
<p>In addition to the OVERLOAD keyword, if you need to control how
Perl autogenerates missing overloaded operators, you can set the
FALLBACK keyword in the module header section, like this:</p>
<pre class="verbatim"><ol><li>    MODULE = RPC  PACKAGE = RPC</li><li></li><li>    FALLBACK: TRUE</li><li>    ...</li></ol></pre><p>where FALLBACK can take any of the three values TRUE, FALSE, or
UNDEF.  If you do not set any FALLBACK value when using OVERLOAD,
it defaults to UNDEF.  FALLBACK is not used except when one or
more functions using OVERLOAD have been defined.  Please see
<a href="overload.html#fallback">fallback in overload</a> for more details.</p>
<a name="The-INTERFACE%3a-Keyword"></a><h2>The INTERFACE: Keyword</h2>
<p>This keyword declares the current XSUB as a keeper of the given
calling signature.  If some text follows this keyword, it is
considered as a list of functions which have this signature, and
should be attached to the current XSUB.</p>
<p>For example, if you have 4 C functions multiply(), divide(), add(),
subtract() all having the signature:</p>
<pre class="verbatim"><ol><li>    <span class="w">symbolic</span> <span class="i">f</span><span class="s">(</span><span class="w">symbolic</span><span class="cm">,</span> <span class="w">symbolic</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>you can make them all to use the same XSUB using this:</p>
<pre class="verbatim"><ol><li>    <span class="w">symbolic</span></li><li>    <span class="i">interface_s_ss</span><span class="s">(</span><span class="w">arg1</span><span class="cm">,</span> <span class="w">arg2</span><span class="s">)</span></li><li>	<span class="w">symbolic</span>	<span class="w">arg1</span></li><li>	<span class="w">symbolic</span>	<span class="w">arg2</span></li><li>    <span class="w">INTERFACE</span><span class="co">:</span></li><li>	<span class="w">multiply</span> <span class="w">divide</span></li><li>	<span class="w">add</span> <span class="w">subtract</span></li></ol></pre><p>(This is the complete XSUB code for 4 Perl functions!)  Four generated
Perl function share names with corresponding C functions.</p>
<p>The advantage of this approach comparing to ALIAS: keyword is that there
is no need to code a switch statement, each Perl function (which shares
the same XSUB) knows which C function it should call.  Additionally, one
can attach an extra function remainder() at runtime by using</p>
<pre class="verbatim"><ol><li>    <span class="w">CV</span> *<span class="w">mycv</span> = <span class="i">newXSproto</span><span class="s">(</span><span class="q">&quot;Symbolic::remainder&quot;</span><span class="cm">,</span></li><li>			  <span class="w">XS_Symbolic_interface_s_ss</span><span class="cm">,</span> <span class="w">__FILE__</span><span class="cm">,</span> <span class="q">&quot;$$&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>    <span class="i">XSINTERFACE_FUNC_SET</span><span class="s">(</span><span class="w">mycv</span><span class="cm">,</span> <span class="w">remainder</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>say, from another XSUB.  (This example supposes that there was no
INTERFACE_MACRO: section, otherwise one needs to use something else instead of
<code class="inline"><span class="w">XSINTERFACE_FUNC_SET</span></code>
, see the next section.)</p>
<a name="The-INTERFACE_MACRO%3a-Keyword"></a><h2>The INTERFACE_MACRO: Keyword</h2>
<p>This keyword allows one to define an INTERFACE using a different way
to extract a function pointer from an XSUB.  The text which follows
this keyword should give the name of macros which would extract/set a
function pointer.  The extractor macro is given return type, <code class="inline"><span class="w">CV</span>*</code>
,
and <code class="inline"><span class="w">XSANY</span>.<span class="w">any_dptr</span></code>
 for this <code class="inline"><span class="w">CV</span>*</code>
.  The setter macro is given cv,
and the function pointer.</p>
<p>The default value is <code class="inline"><span class="w">XSINTERFACE_FUNC</span></code>
 and <code class="inline"><span class="w">XSINTERFACE_FUNC_SET</span></code>
.
An INTERFACE keyword with an empty list of functions can be omitted if
INTERFACE_MACRO keyword is used.</p>
<p>Suppose that in the previous example functions pointers for
multiply(), divide(), add(), subtract() are kept in a global C array
<code class="inline"><span class="w">fp</span><span class="s">[</span><span class="s">]</span></code>
 with offsets being <code class="inline"><span class="w">multiply_off</span></code>
, <code class="inline"><span class="w">divide_off</span></code>
, <code class="inline"><span class="w">add_off</span></code>
,
<code class="inline"><span class="w">subtract_off</span></code>
.  Then one can use</p>
<pre class="verbatim"><ol><li>    #define XSINTERFACE_FUNC_BYOFFSET(ret,cv,f) \</li><li>	((XSINTERFACE_CVT_ANON(ret))fp[CvXSUBANY(cv).any_i32])</li><li>    #define XSINTERFACE_FUNC_BYOFFSET_set(cv,f) \</li><li>	CvXSUBANY(cv).any_i32 = CAT2( f, _off )</li></ol></pre><p>in C section,</p>
<pre class="verbatim"><ol><li>    <span class="w">symbolic</span></li><li>    <span class="i">interface_s_ss</span><span class="s">(</span><span class="w">arg1</span><span class="cm">,</span> <span class="w">arg2</span><span class="s">)</span></li><li>	<span class="w">symbolic</span>	<span class="w">arg1</span></li><li>	<span class="w">symbolic</span>	<span class="w">arg2</span></li><li>      <span class="w">INTERFACE_MACRO</span><span class="co">:</span></li><li>	<span class="w">XSINTERFACE_FUNC_BYOFFSET</span></li><li>	<span class="w">XSINTERFACE_FUNC_BYOFFSET_set</span></li><li>      <span class="w">INTERFACE</span><span class="co">:</span></li><li>	<span class="w">multiply</span> <span class="w">divide</span></li><li>	<span class="w">add</span> <span class="w">subtract</span></li></ol></pre><p>in XSUB section.</p>
<a name="The-INCLUDE%3a-Keyword"></a><h2>The INCLUDE: Keyword</h2>
<p>This keyword can be used to pull other files into the XS module.  The other
files may have XS code.  INCLUDE: can also be used to run a command to
generate the XS code to be pulled into the module.</p>
<p>The file <i>Rpcb1.xsh</i> contains our <code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span></code>
 function:</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t &amp;timep</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><p>The XS module can use INCLUDE: to pull that file into it.</p>
<pre class="verbatim"><ol><li>    <span class="j">INCLUDE:</span> <span class="w">Rpcb1</span>.<span class="w">xsh</span></li></ol></pre><p>If the parameters to the INCLUDE: keyword are followed by a pipe (<code class="inline">|</code>) then
the compiler will interpret the parameters as a command. This feature is
mildly deprecated in favour of the <code class="inline"><span class="j">INCLUDE_COMMAND:</span></code>
 directive, as documented
below.</p>
<pre class="verbatim"><ol><li>    <span class="j">INCLUDE:</span> <span class="w">cat</span> <span class="w">Rpcb1</span>.<span class="w">xsh</span> |</li></ol></pre><p>Do not use this to run perl: <code class="inline"><span class="j">INCLUDE:</span> <span class="w">perl</span> |</code>
 will run the perl that
happens to be the first in your path and not necessarily the same perl that is
used to run <code class="inline"><span class="w">xsubpp</span></code>
. See <a href="#The-INCLUDE_COMMAND%3a-Keyword">The INCLUDE_COMMAND: Keyword</a>.</p>
<a name="The-INCLUDE_COMMAND%3a-Keyword"></a><h2>The INCLUDE_COMMAND: Keyword</h2>
<p>Runs the supplied command and includes its output into the current XS
document. <code class="inline"><span class="w">INCLUDE_COMMAND</span></code>
 assigns special meaning to the <code class="inline"><span class="i">$^X</span></code>
 token
in that it runs the same perl interpreter that is running <code class="inline"><span class="w">xsubpp</span></code>
:</p>
<pre class="verbatim"><ol><li>    <span class="j">INCLUDE_COMMAND:</span> <span class="w">cat</span> <span class="w">Rpcb1</span>.<span class="w">xsh</span></li><li></li><li>    <span class="w">INCLUDE_COMMAND</span><span class="co">:</span> <span class="i">$^X</span> -<span class="w">e</span> ...</li></ol></pre><a name="The-CASE%3a-Keyword"></a><h2>The CASE: Keyword</h2>
<p>The CASE: keyword allows an XSUB to have multiple distinct parts with each
part acting as a virtual XSUB.  CASE: is greedy and if it is used then all
other XS keywords must be contained within a CASE:.  This means nothing may
precede the first CASE: in the XSUB and anything following the last CASE: is
included in that case.</p>
<p>A CASE: might switch via a parameter of the XSUB, via the <code class="inline"><span class="w">ix</span></code>
 ALIAS:
variable (see <a href="#The-ALIAS%3a-Keyword">The ALIAS: Keyword</a>), or maybe via the <code class="inline"><span class="w">items</span></code>
 variable
(see <a href="#Variable-length-Parameter-Lists">Variable-length Parameter Lists</a>).  The last CASE: becomes the
<b>default</b> case if it is not associated with a conditional.  The following
example shows CASE switched via <code class="inline"><span class="w">ix</span></code>
 with a function <code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span></code>

having an alias <code class="inline"><span class="i">x_gettime</span><span class="s">(</span><span class="s">)</span></code>
.  When the function is called as
<code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span></code>
 its parameters are the usual <code class="inline"><span class="s">(</span><span class="w">char</span> *<span class="w">host</span><span class="cm">,</span> <span class="w">time_t</span> *<span class="w">timep</span><span class="s">)</span></code>
,
but when the function is called as <code class="inline"><span class="i">x_gettime</span><span class="s">(</span><span class="s">)</span></code>
 its parameters are
reversed, <code class="inline"><span class="s">(</span><span class="w">time_t</span> *<span class="w">timep</span><span class="cm">,</span> <span class="w">char</span> *<span class="w">host</span><span class="s">)</span></code>
.</p>
<pre class="verbatim"><ol><li>    long</li><li>    rpcb_gettime(a,b)</li><li>      CASE: ix == 1</li><li>	ALIAS:</li><li>	  x_gettime = 1</li><li>	INPUT:</li><li>	  # 'a' is timep, 'b' is host</li><li>          char *b</li><li>          time_t a = NO_INIT</li><li>        CODE:</li><li>               RETVAL = rpcb_gettime( b, &amp;a );</li><li>        OUTPUT:</li><li>          a</li><li>          RETVAL</li><li>      CASE:</li><li>	  # 'a' is host, 'b' is timep</li><li>          char *a</li><li>          time_t &amp;b = NO_INIT</li><li>        OUTPUT:</li><li>          b</li><li>          RETVAL</li></ol></pre><p>That function can be called with either of the following statements.  Note
the different argument lists.</p>
<pre class="verbatim"><ol><li>	<span class="i">$status</span> = <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="i">$host</span><span class="cm">,</span> <span class="i">$timep</span> <span class="s">)</span><span class="sc">;</span></li><li></li><li>	<span class="i">$status</span> = <span class="i">x_gettime</span><span class="s">(</span> <span class="i">$timep</span><span class="cm">,</span> <span class="i">$host</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><a name="The-EXPORT_XSUB_SYMBOLS%3a-Keyword"></a><h2>The EXPORT_XSUB_SYMBOLS: Keyword</h2>
<p>The EXPORT_XSUB_SYMBOLS: keyword is likely something you will never need.
In perl versions earlier than 5.16.0, this keyword does nothing. Starting
with 5.16, XSUB symbols are no longer exported by default. That is, they
are <code class="inline"><span class="w">static</span></code>
 functions. If you include</p>
<pre class="verbatim"><ol><li>  <span class="j">EXPORT_XSUB_SYMBOLS:</span> <span class="w">ENABLE</span></li></ol></pre><p>in your XS code, the XSUBs following this line will not be declared <code class="inline"><span class="w">static</span></code>
.
You can later disable this with</p>
<pre class="verbatim"><ol><li>  <span class="j">EXPORT_XSUB_SYMBOLS:</span> <span class="w">DISABLE</span></li></ol></pre><p>which, again, is the default that you should probably never change.
You cannot use this keyword on versions of perl before 5.16 to make
XSUBs <code class="inline"><span class="w">static</span></code>
.</p>
<a name="The-%26-Unary-Operator"></a><h2>The &amp; Unary Operator</h2>
<p>The <code class="inline"><span class="i">&amp;</span></code>
 unary operator in the INPUT: section is used to tell <b>xsubpp</b>
that it should convert a Perl value to/from C using the C type to the left
of <code class="inline"><span class="i">&amp;</span></code>
, but provide a pointer to this value when the C function is called.</p>
<p>This is useful to avoid a CODE: block for a C function which takes a parameter
by reference.  Typically, the parameter should be not a pointer type (an
<code class="inline"><a class="l_k" href="functions/int.html">int</a></code> or <code class="inline"><span class="w">long</span></code>
 but not an <code class="inline"><a class="l_k" href="functions/int.html">int*</a></code> or <code class="inline"><span class="w">long</span>*</code>
).</p>
<p>The following XSUB will generate incorrect C code.  The <b>xsubpp</b> compiler will
turn this into code which calls <code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span></code>
 with parameters <code class="inline"><span class="s">(</span><span class="w">char</span>
*<span class="w">host</span><span class="cm">,</span> <span class="w">time_t</span> <span class="w">timep</span><span class="s">)</span></code>
, but the real <code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span></code>
 wants the <code class="inline"><span class="w">timep</span></code>

parameter to be of type <code class="inline"><span class="w">time_t</span>*</code>
 rather than <code class="inline"><span class="w">time_t</span></code>
.</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t timep</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><p>That problem is corrected by using the <code class="inline"><span class="i">&amp;</span></code>
 operator.  The <b>xsubpp</b> compiler
will now turn this into code which calls <code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span></code>
 correctly with
parameters <code class="inline"><span class="s">(</span><span class="w">char</span> *<span class="w">host</span><span class="cm">,</span> <span class="w">time_t</span> *<span class="w">timep</span><span class="s">)</span></code>
.  It does this by carrying the
<code class="inline"><span class="i">&amp;</span></code>
 through, so the function call looks like <code class="inline"><span class="i">rpcb_gettime</span><span class="s">(</span><span class="w">host</span><span class="cm">,</span> <span class="i">&amp;timep</span><span class="s">)</span></code>
.</p>
<pre class="verbatim"><ol><li>    bool_t</li><li>    rpcb_gettime(host,timep)</li><li>          char *host</li><li>          time_t &amp;timep</li><li>        OUTPUT:</li><li>          timep</li></ol></pre><a name="Inserting-POD%2c-Comments-and-C-Preprocessor-Directives"></a><h2>Inserting POD, Comments and C Preprocessor Directives</h2>
<p>C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:,
PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions.
Comments are allowed anywhere after the MODULE keyword.  The compiler will
pass the preprocessor directives through untouched and will remove the
commented lines. POD documentation is allowed at any point, both in the
C and XS language sections. POD must be terminated with a <code class="inline"><span class="pd">=cut</span></code>
 command;
<code class="inline"><span class="w">xsubpp</span></code>
 will exit with an error if it does not. It is very unlikely that
human generated C code will be mistaken for POD, as most indenting styles
result in whitespace in front of any line starting with <code class="inline">=</code>
. Machine
generated XS files may fall into this trap unless care is taken to
ensure that a space breaks the sequence "\n=".</p>
<p>Comments can be added to XSUBs by placing a <code class="inline"><span class="c">#</span></code>
 as the first
non-whitespace of a line.  Care should be taken to avoid making the
comment look like a C preprocessor directive, lest it be interpreted as
such.  The simplest way to prevent this is to put whitespace in front of
the <code class="inline"><span class="c">#</span></code>
.</p>
<p>If you use preprocessor directives to choose one of two
versions of a function, use</p>
<pre class="verbatim"><ol><li>    <span class="c">#if ... version1</span></li><li>    <span class="c">#else /* ... version2  */</span></li><li>    <span class="c">#endif</span></li></ol></pre><p>and not</p>
<pre class="verbatim"><ol><li>    <span class="c">#if ... version1</span></li><li>    <span class="c">#endif</span></li><li>    <span class="c">#if ... version2</span></li><li>    <span class="c">#endif</span></li></ol></pre><p>because otherwise <b>xsubpp</b> will believe that you made a duplicate
definition of the function.  Also, put a blank line before the
#else/#endif so it will not be seen as part of the function body.</p>
<a name="Using-XS-With-C%2b%2b"></a><h2>Using XS With C++</h2>
<p>If an XSUB name contains <code class="inline"><span class="w">::</span></code>
, it is considered to be a C++ method.
The generated Perl function will assume that
its first argument is an object pointer.  The object pointer
will be stored in a variable called THIS.  The object should
have been created by C++ with the new() function and should
be blessed by Perl with the sv_setref_pv() macro.  The
blessing of the object by Perl can be handled by a typemap.  An example
typemap is shown at the end of this section.</p>
<p>If the return type of the XSUB includes <code class="inline"><span class="w">static</span></code>
, the method is considered
to be a static method.  It will call the C++
function using the class::method() syntax.  If the method is not static
the function will be called using the THIS-&gt;method() syntax.</p>
<p>The next examples will use the following C++ class.</p>
<pre class="verbatim"><ol><li>     <span class="w">class</span> <span class="i">color</span> <span class="s">{</span></li><li>          <span class="j">public:</span></li><li>          <span class="i">color</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li>          ~<span class="i">color</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li>          <a class="l_k" href="functions/int.html">int</a> <span class="i">blue</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li>          <span class="w">void</span> <span class="i">set_blue</span><span class="s">(</span> <a class="l_k" href="functions/int.html">int</a> <span class="s">)</span><span class="sc">;</span></li><li></li><li>          <span class="j">private:</span></li><li>          <a class="l_k" href="functions/int.html">int</a> <span class="w">c_blue</span><span class="sc">;</span></li><li>     <span class="s">}</span><span class="sc">;</span></li></ol></pre><p>The XSUBs for the blue() and set_blue() methods are defined with the class
name but the parameter for the object (THIS, or "self") is implicit and is
not listed.</p>
<pre class="verbatim"><ol><li>     int</li><li>     color::blue()</li><li></li><li>     void</li><li>     color::set_blue( val )</li><li>          int val</li></ol></pre><p>Both Perl functions will expect an object as the first parameter.  In the
generated C++ code the object is called <code class="inline"><span class="w">THIS</span></code>
, and the method call will
be performed on this object.  So in the C++ code the blue() and set_blue()
methods will be called as this:</p>
<pre class="verbatim"><ol><li>     <span class="w">RETVAL</span> = <span class="w">THIS</span><span class="w">-&gt;blue</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li></li><li>     <span class="w">THIS</span><span class="w">-&gt;set_blue</span><span class="s">(</span> <span class="w">val</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>You could also write a single get/set method using an optional argument:</p>
<pre class="verbatim"><ol><li>     int</li><li>     color::blue( val = NO_INIT )</li><li>         int val</li><li>         PROTOTYPE $;$</li><li>         CODE:</li><li>             if (items &gt; 1)</li><li>                 THIS-&gt;set_blue( val );</li><li>             RETVAL = THIS-&gt;blue();</li><li>         OUTPUT:</li><li>             RETVAL</li></ol></pre><p>If the function's name is <b>DESTROY</b> then the C++ <code class="inline"><a class="l_k" href="functions/delete.html">delete</a></code> function will be
called and <code class="inline"><span class="w">THIS</span></code>
 will be given as its parameter.  The generated C++ code for</p>
<pre class="verbatim"><ol><li>     <span class="w">void</span></li><li>     <span class="i">color::DESTROY</span><span class="s">(</span><span class="s">)</span></li></ol></pre><p>will look like this:</p>
<pre class="verbatim"><ol><li>     <span class="w">color</span> *<span class="w">THIS</span> = ...<span class="sc">;</span>  <span class="q">//</span> <span class="w">Initialized</span> <span class="w">as</span> <span class="w">in</span> <span class="w">typemap</span></li><li></li><li>     <a class="l_k" href="functions/delete.html">delete</a> <span class="w">THIS</span><span class="sc">;</span></li></ol></pre><p>If the function's name is <b>new</b> then the C++ <code class="inline"><span class="w">new</span></code>
 function will be called
to create a dynamic C++ object.  The XSUB will expect the class name, which
will be kept in a variable called <code class="inline"><span class="w">CLASS</span></code>
, to be given as the first
argument.</p>
<pre class="verbatim"><ol><li>     <span class="w">color</span> *</li><li>     <span class="i">color::new</span><span class="s">(</span><span class="s">)</span></li></ol></pre><p>The generated C++ code will call <code class="inline"><span class="w">new</span></code>
.</p>
<pre class="verbatim"><ol><li>     <span class="w">RETVAL</span> = <span class="w">new</span> <span class="i">color</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>The following is an example of a typemap that could be used for this C++
example.</p>
<pre class="verbatim"><ol><li>    <span class="w">TYPEMAP</span></li><li>    <span class="w">color</span> *  <span class="w">O_OBJECT</span></li><li></li><li>    <span class="w">OUTPUT</span></li><li>    <span class="c"># The Perl object is blessed into &#39;CLASS&#39;, which should be a</span></li><li>    <span class="c"># char* having the name of the package for the blessing.</span></li><li>    <span class="w">O_OBJECT</span></li><li>        <span class="i">sv_setref_pv</span><span class="s">(</span> <span class="i">$arg</span><span class="cm">,</span> <span class="w">CLASS</span><span class="cm">,</span> <span class="s">(</span><span class="w">void</span>*<span class="s">)</span><span class="i">$var</span> <span class="s">)</span><span class="sc">;</span></li><li></li><li>    <span class="w">INPUT</span></li><li>    <span class="w">O_OBJECT</span></li><li>        <a class="l_k" href="functions/if.html">if</a><span class="s">(</span> <span class="i">sv_isobject</span><span class="s">(</span><span class="i">$arg</span><span class="s">)</span> &amp;&amp; <span class="s">(</span><span class="i">SvTYPE</span><span class="s">(</span><span class="i">SvRV</span><span class="s">(</span><span class="i">$arg</span><span class="s">)</span><span class="s">)</span> == <span class="w">SVt_PVMG</span><span class="s">)</span> <span class="s">)</span></li><li>            <span class="i">$var</span> = <span class="s">(</span><span class="i">$type</span><span class="s">)</span><span class="i">SvIV</span><span class="s">(</span><span class="s">(</span><span class="w">SV</span>*<span class="s">)</span><span class="i">SvRV</span><span class="s">(</span> <span class="i">$arg</span> <span class="s">)</span><span class="s">)</span><span class="sc">;</span></li><li>        <a class="l_k" href="functions/else.html">else</a><span class="s">{</span></li><li>            <a class="l_k" href="functions/warn.html">warn</a><span class="s">(</span><span class="q">&quot;${Package}::$func_name() -- &quot;</span> .</li><li>                <span class="q">&quot;$var is not a blessed SV reference&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>            <span class="w">XSRETURN_UNDEF</span><span class="sc">;</span></li><li>        <span class="s">}</span></li></ol></pre><a name="Interface-Strategy"></a><h2>Interface Strategy</h2>
<p>When designing an interface between Perl and a C library a straight
translation from C to XS (such as created by <code class="inline"><span class="w">h2xs</span> -x</code>
) is often sufficient.
However, sometimes the interface will look
very C-like and occasionally nonintuitive, especially when the C function
modifies one of its parameters, or returns failure inband (as in "negative
return values mean failure").  In cases where the programmer wishes to
create a more Perl-like interface the following strategy may help to
identify the more critical parts of the interface.</p>
<p>Identify the C functions with input/output or output parameters.  The XSUBs for
these functions may be able to return lists to Perl.</p>
<p>Identify the C functions which use some inband info as an indication
of failure.  They may be
candidates to return undef or an empty list in case of failure.  If the
failure may be detected without a call to the C function, you may want to use
an INIT: section to report the failure.  For failures detectable after the C
function returns one may want to use a POSTCALL: section to process the
failure.  In more complicated cases use CODE: or PPCODE: sections.</p>
<p>If many functions use the same failure indication based on the return value,
you may want to create a special typedef to handle this situation.  Put</p>
<pre class="verbatim"><ol><li>  <span class="w">typedef</span> <a class="l_k" href="functions/int.html">int</a> <span class="w">negative_is_failure</span><span class="sc">;</span></li></ol></pre><p>near the beginning of XS file, and create an OUTPUT typemap entry
for <code class="inline"><span class="w">negative_is_failure</span></code>
 which converts negative values to <code class="inline"><a class="l_k" href="functions/undef.html">undef</a></code>, or
maybe croak()s.  After this the return value of type <code class="inline"><span class="w">negative_is_failure</span></code>

will create more Perl-like interface.</p>
<p>Identify which values are used by only the C and XSUB functions
themselves, say, when a parameter to a function should be a contents of a
global variable.  If Perl does not need to access the contents of the value
then it may not be necessary to provide a translation for that value
from C to Perl.</p>
<p>Identify the pointers in the C function parameter lists and return
values.  Some pointers may be used to implement input/output or
output parameters, they can be handled in XS with the <code class="inline"><span class="i">&amp;</span></code>
 unary operator,
and, possibly, using the NO_INIT keyword.
Some others will require handling of types like <code class="inline"><a class="l_k" href="functions/int.html">int</a> <span class="i">*</span></code>
, and one needs
to decide what a useful Perl translation will do in such a case.  When
the semantic is clear, it is advisable to put the translation into a typemap
file.</p>
<p>Identify the structures used by the C functions.  In many
cases it may be helpful to use the T_PTROBJ typemap for
these structures so they can be manipulated by Perl as
blessed objects.  (This is handled automatically by <code class="inline"><span class="w">h2xs</span> -x</code>
.)</p>
<p>If the same C type is used in several different contexts which require
different translations, <code class="inline"><span class="w">typedef</span></code>
 several new types mapped to this C type,
and create separate <i>typemap</i> entries for these new types.  Use these
types in declarations of return type and parameters to XSUBs.</p>
<a name="Perl-Objects-And-C-Structures"></a><h2>Perl Objects And C Structures</h2>
<p>When dealing with C structures one should select either
<b>T_PTROBJ</b> or <b>T_PTRREF</b> for the XS type.  Both types are
designed to handle pointers to complex objects.  The
T_PTRREF type will allow the Perl object to be unblessed
while the T_PTROBJ type requires that the object be blessed.
By using T_PTROBJ one can achieve a form of type-checking
because the XSUB will attempt to verify that the Perl object
is of the expected type.</p>
<p>The following XS code shows the getnetconfigent() function which is used
with ONC+ TIRPC.  The getnetconfigent() function will return a pointer to a
C structure and has the C prototype shown below.  The example will
demonstrate how the C pointer will become a Perl reference.  Perl will
consider this reference to be a pointer to a blessed object and will
attempt to call a destructor for the object.  A destructor will be
provided in the XS source to free the memory used by getnetconfigent().
Destructors in XS can be created by specifying an XSUB function whose name
ends with the word <b>DESTROY</b>.  XS destructors can be used to free memory
which may have been malloc'd by another XSUB.</p>
<pre class="verbatim"><ol><li>     <span class="w">struct</span> <span class="w">netconfig</span> *<span class="i">getnetconfigent</span><span class="s">(</span><span class="w">const</span> <span class="w">char</span> *<span class="w">netid</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>A <code class="inline"><span class="w">typedef</span></code>
 will be created for <code class="inline"><span class="w">struct</span> <span class="w">netconfig</span></code>
.  The Perl
object will be blessed in a class matching the name of the C
type, with the tag <code class="inline"><span class="w">Ptr</span></code>
 appended, and the name should not
have embedded spaces if it will be a Perl package name.  The
destructor will be placed in a class corresponding to the
class of the object and the PREFIX keyword will be used to
trim the name to the word DESTROY as Perl will expect.</p>
<pre class="verbatim"><ol><li>     typedef struct netconfig Netconfig;</li><li></li><li>     MODULE = RPC  PACKAGE = RPC</li><li></li><li>     Netconfig *</li><li>     getnetconfigent(netid)</li><li>          char *netid</li><li></li><li>     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_</li><li></li><li>     void</li><li>     rpcb_DESTROY(netconf)</li><li>          Netconfig *netconf</li><li>        CODE:</li><li>          printf("Now in NetconfigPtr::DESTROY\n");</li><li>          free( netconf );</li></ol></pre><p>This example requires the following typemap entry.  Consult
<a href="perlxstypemap.html">perlxstypemap</a> for more information about adding new typemaps
for an extension.</p>
<pre class="verbatim"><ol><li>     <span class="w">TYPEMAP</span></li><li>     <span class="w">Netconfig</span> *  <span class="w">T_PTROBJ</span></li></ol></pre><p>This example will be used with the following Perl statements.</p>
<pre class="verbatim"><ol><li>     <a class="l_k" href="functions/use.html">use</a> <span class="w">RPC</span><span class="sc">;</span></li><li>     <span class="i">$netconf</span> = <span class="i">getnetconfigent</span><span class="s">(</span><span class="q">&quot;udp&quot;</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>When Perl destroys the object referenced by $netconf it will send the
object to the supplied XSUB DESTROY function.  Perl cannot determine, and
does not care, that this object is a C struct and not a Perl object.  In
this sense, there is no difference between the object created by the
getnetconfigent() XSUB and an object created by a normal Perl subroutine.</p>
<a name="Safely-Storing-Static-Data-in-XS"></a><h2>Safely Storing Static Data in XS</h2>
<p>Starting with Perl 5.8, a macro framework has been defined to allow
static data to be safely stored in XS modules that will be accessed from
a multi-threaded Perl.</p>
<p>Although primarily designed for use with multi-threaded Perl, the macros
have been designed so that they will work with non-threaded Perl as well.</p>
<p>It is therefore strongly recommended that these macros be used by all
XS modules that make use of static data.</p>
<p>The easiest way to get a template set of macros to use is by specifying
the <code class="inline">-g</code>
 (<code class="inline">--<span class="w">global</span></code>
) option with h2xs (see <a href="h2xs.html">h2xs</a>).</p>
<p>Below is an example module that makes use of the macros.</p>
<pre class="verbatim"><ol><li>    <span class="c">#define PERL_NO_GET_CONTEXT</span></li><li>    <span class="c">#include &quot;EXTERN.h&quot;</span></li><li>    <span class="c">#include &quot;perl.h&quot;</span></li><li>    <span class="c">#include &quot;XSUB.h&quot;</span></li><li></li><li>    <span class="q">/* Global Data */</span></li><li></li><li>    <span class="c">#define MY_CXT_KEY &quot;BlindMice::_guts&quot; XS_VERSION</span></li><li></li><li>    <span class="w">typedef</span> <span class="i">struct</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/int.html">int</a> <span class="w">count</span><span class="sc">;</span></li><li>        <span class="w">char</span> <span class="w">name</span><span class="s">[</span><span class="n">3</span><span class="s">]</span><span class="s">[</span><span class="n">100</span><span class="s">]</span><span class="sc">;</span></li><li>    <span class="s">}</span> <span class="w">my_cxt_t</span><span class="sc">;</span></li><li></li><li>    <span class="w">START_MY_CXT</span></li><li></li><li>    <span class="w">MODULE</span> = <span class="w">BlindMice</span>           <span class="w">PACKAGE</span> = <span class="w">BlindMice</span></li><li></li><li>    <span class="w">BOOT</span><span class="co">:</span></li><li>    <span class="s">{</span></li><li>        <span class="w">MY_CXT_INIT</span><span class="sc">;</span></li><li>        <span class="w">MY_CXT</span>.<span class="w">count</span> = <span class="n">0</span><span class="sc">;</span></li><li>        <span class="i">strcpy</span><span class="s">(</span><span class="w">MY_CXT</span>.<span class="w">name</span><span class="s">[</span><span class="n">0</span><span class="s">]</span><span class="cm">,</span> <span class="q">&quot;None&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>        <span class="i">strcpy</span><span class="s">(</span><span class="w">MY_CXT</span>.<span class="w">name</span><span class="s">[</span><span class="n">1</span><span class="s">]</span><span class="cm">,</span> <span class="q">&quot;None&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>        <span class="i">strcpy</span><span class="s">(</span><span class="w">MY_CXT</span>.<span class="w">name</span><span class="s">[</span><span class="n">2</span><span class="s">]</span><span class="cm">,</span> <span class="q">&quot;None&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>    <span class="s">}</span></li><li></li><li>    <a class="l_k" href="functions/int.html">int</a></li><li>    <span class="i">newMouse</span><span class="s">(</span><span class="w">char</span> * <span class="w">name</span><span class="s">)</span></li><li>        <span class="w">PREINIT</span><span class="co">:</span></li><li>          <span class="w">dMY_CXT</span><span class="sc">;</span></li><li>        <span class="j">CODE:</span></li><li>          <a class="l_k" href="functions/if.html">if</a> <span class="s">(</span><span class="w">MY_CXT</span>.<span class="w">count</span> &gt;= <span class="n">3</span><span class="s">)</span> <span class="s">{</span></li><li>              <a class="l_k" href="functions/warn.html">warn</a><span class="s">(</span><span class="q">&quot;Already have 3 blind mice&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>              <span class="w">RETVAL</span> = <span class="n">0</span><span class="sc">;</span></li><li>          <span class="s">}</span></li><li>          <a class="l_k" href="functions/else.html">else</a> <span class="s">{</span></li><li>              <span class="w">RETVAL</span> = ++ <span class="w">MY_CXT</span>.<span class="w">count</span><span class="sc">;</span></li><li>              <span class="i">strcpy</span><span class="s">(</span><span class="w">MY_CXT</span>.<span class="w">name</span><span class="s">[</span><span class="w">MY_CXT</span>.<span class="w">count</span> - <span class="n">1</span><span class="s">]</span><span class="cm">,</span> <span class="w">name</span><span class="s">)</span><span class="sc">;</span></li><li>          <span class="s">}</span></li><li>        <span class="j">OUTPUT:</span></li><li>          <span class="w">RETVAL</span></li><li></li><li>    <span class="w">char</span> *</li><li>    <span class="i">get_mouse_name</span><span class="s">(</span><a class="l_k" href="functions/index.html">index</a><span class="s">)</span></li><li>          <a class="l_k" href="functions/int.html">int</a> <a class="l_k" href="functions/index.html">index</a></li><li>        <span class="w">PREINIT</span><span class="co">:</span></li><li>          <span class="w">dMY_CXT</span><span class="sc">;</span></li><li>        <span class="j">CODE:</span></li><li>          <a class="l_k" href="functions/if.html">if</a> <span class="s">(</span><a class="l_k" href="functions/index.html">index</a> &gt; <span class="w">MY_CXT</span>.<span class="w">count</span><span class="s">)</span></li><li>            <span class="i">croak</span><span class="s">(</span><span class="q">&quot;There are only 3 blind mice.&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>          <a class="l_k" href="functions/else.html">else</a></li><li>            <span class="w">RETVAL</span> = <span class="w">MY_CXT</span>.<span class="w">name</span><span class="s">[</span><a class="l_k" href="functions/index.html">index</a> - <span class="n">1</span><span class="s">]</span><span class="sc">;</span></li><li>        <span class="j">OUTPUT:</span></li><li>          <span class="w">RETVAL</span></li><li></li><li>    <span class="w">void</span></li><li>    <span class="i">CLONE</span><span class="s">(</span>...<span class="s">)</span></li><li>	<span class="w">CODE</span><span class="co">:</span></li><li>	  <span class="w">MY_CXT_CLONE</span><span class="sc">;</span></li></ol></pre><a name="MY_CXT-REFERENCE"></a><h3>MY_CXT REFERENCE</h3>
<ul>
<li><a name="MY_CXT_KEY"></a><b>MY_CXT_KEY</b>
<p>This macro is used to define a unique key to refer to the static data
for an XS module. The suggested naming scheme, as used by h2xs, is to
use a string that consists of the module name, the string "::_guts"
and the module version number.</p>
<pre class="verbatim"><ol><li>    <span class="c">#define MY_CXT_KEY &quot;MyModule::_guts&quot; XS_VERSION</span></li></ol></pre></li>
<li><a name="typedef-my_cxt_t"></a><b>typedef my_cxt_t</b>
<p>This struct typedef <i>must</i> always be called <code class="inline"><span class="w">my_cxt_t</span></code>
. The other
<code class="inline"><span class="w">CXT</span>*</code>
 macros assume the existence of the <code class="inline"><span class="w">my_cxt_t</span></code>
 typedef name.</p>
<p>Declare a typedef named <code class="inline"><span class="w">my_cxt_t</span></code>
 that is a structure that contains
all the data that needs to be interpreter-local.</p>
<pre class="verbatim"><ol><li>    <span class="w">typedef</span> <span class="i">struct</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/int.html">int</a> <span class="w">some_value</span><span class="sc">;</span></li><li>    <span class="s">}</span> <span class="w">my_cxt_t</span><span class="sc">;</span></li></ol></pre></li>
<li><a name="START_MY_CXT"></a><b>START_MY_CXT</b>
<p>Always place the START_MY_CXT macro directly after the declaration
of <code class="inline"><span class="w">my_cxt_t</span></code>
.</p>
</li>
<li><a name="MY_CXT_INIT"></a><b>MY_CXT_INIT</b>
<p>The MY_CXT_INIT macro initializes storage for the <code class="inline"><span class="w">my_cxt_t</span></code>
 struct.</p>
<p>It <i>must</i> be called exactly once, typically in a BOOT: section. If you
are maintaining multiple interpreters, it should be called once in each
interpreter instance, except for interpreters cloned from existing ones.
(But see <a href="#MY_CXT_CLONE">MY_CXT_CLONE</a> below.)</p>
</li>
<li><a name="dMY_CXT"></a><b>dMY_CXT</b>
<p>Use the dMY_CXT macro (a declaration) in all the functions that access
MY_CXT.</p>
</li>
<li><a name="MY_CXT"></a><b>MY_CXT</b>
<p>Use the MY_CXT macro to access members of the <code class="inline"><span class="w">my_cxt_t</span></code>
 struct. For
example, if <code class="inline"><span class="w">my_cxt_t</span></code>
 is</p>
<pre class="verbatim"><ol><li>    <span class="w">typedef</span> <span class="i">struct</span> <span class="s">{</span></li><li>        <a class="l_k" href="functions/int.html">int</a> <a class="l_k" href="functions/index.html">index</a><span class="sc">;</span></li><li>    <span class="s">}</span> <span class="w">my_cxt_t</span><span class="sc">;</span></li></ol></pre><p>then use this to access the <code class="inline"><a class="l_k" href="functions/index.html">index</a></code> member</p>
<pre class="verbatim"><ol><li>    <span class="w">dMY_CXT</span><span class="sc">;</span></li><li>    <span class="w">MY_CXT</span>.<a class="l_k" href="functions/index.html">index</a> = <span class="n">2</span><span class="sc">;</span></li></ol></pre></li>
<li><a name="aMY_CXT%2fpMY_CXT"></a><b>aMY_CXT/pMY_CXT</b>
<p><code class="inline"><span class="w">dMY_CXT</span></code>
 may be quite expensive to calculate, and to avoid the overhead
of invoking it in each function it is possible to pass the declaration
onto other functions using the <code class="inline"><span class="w">aMY_CXT</span></code>
/<code class="inline"><span class="w">pMY_CXT</span></code>
 macros, eg</p>
<pre class="verbatim"><ol><li>    void sub1() {</li><li>	dMY_CXT;</li><li>	MY_CXT.index = 1;</li><li>	sub2(aMY_CXT);</li><li>    }</li><li></li><li>    void sub2(pMY_CXT) {</li><li>	MY_CXT.index = 2;</li><li>    }</li></ol></pre><p>Analogously to <code class="inline"><span class="w">pTHX</span></code>
, there are equivalent forms for when the macro is the
first or last in multiple arguments, where an underscore represents a
comma, i.e.  <code class="inline"><span class="w">_aMY_CXT</span></code>
, <code class="inline"><span class="w">aMY_CXT_</span></code>
, <code class="inline"><span class="w">_pMY_CXT</span></code>
 and <code class="inline"><span class="w">pMY_CXT_</span></code>
.</p>
</li>
<li><a name="MY_CXT_CLONE"></a><b>MY_CXT_CLONE</b>
<p>By default, when a new interpreter is created as a copy of an existing one
(eg via <code class="inline"><span class="w">threads</span><span class="w">-&gt;create</span><span class="s">(</span><span class="s">)</span></code>
), both interpreters share the same physical
my_cxt_t structure. Calling <code class="inline"><span class="w">MY_CXT_CLONE</span></code>
 (typically via the package's
<code class="inline"><span class="i">CLONE</span><span class="s">(</span><span class="s">)</span></code>
 function), causes a byte-for-byte copy of the structure to be
taken, and any future dMY_CXT will cause the copy to be accessed instead.</p>
</li>
<li><a name="MY_CXT_INIT_INTERP(my_perl)"></a><b>MY_CXT_INIT_INTERP(my_perl)</b>
</li>
<li><a name="dMY_CXT_INTERP(my_perl)"></a><b>dMY_CXT_INTERP(my_perl)</b>
<p>These are versions of the macros which take an explicit interpreter as an
argument.</p>
</li>
</ul>
<p>Note that these macros will only work together within the <i>same</i> source
file; that is, a dMY_CTX in one source file will access a different structure
than a dMY_CTX in another source file.</p>
<a name="Thread-aware-system-interfaces"></a><h2>Thread-aware system interfaces</h2>
<p>Starting from Perl 5.8, in C/C++ level Perl knows how to wrap
system/library interfaces that have thread-aware versions
(e.g. getpwent_r()) into frontend macros (e.g. getpwent()) that
correctly handle the multithreaded interaction with the Perl
interpreter.  This will happen transparently, the only thing
you need to do is to instantiate a Perl interpreter.</p>
<p>This wrapping happens always when compiling Perl core source
(PERL_CORE is defined) or the Perl core extensions (PERL_EXT is
defined).  When compiling XS code outside of Perl core the wrapping
does not take place.  Note, however, that intermixing the _r-forms
(as Perl compiled for multithreaded operation will do) and the _r-less
forms is neither well-defined (inconsistent results, data corruption,
or even crashes become more likely), nor is it very portable.</p>
<a name="EXAMPLES"></a><h1>EXAMPLES</h1>
<p>File <code class="inline"><span class="w">RPC</span>.<span class="w">xs</span></code>
: Interface to some ONC+ RPC bind library functions.</p>
<pre class="verbatim"><ol><li>     <span class="c">#define PERL_NO_GET_CONTEXT</span></li><li>     <span class="c">#include &quot;EXTERN.h&quot;</span></li><li>     <span class="c">#include &quot;perl.h&quot;</span></li><li>     <span class="c">#include &quot;XSUB.h&quot;</span></li><li></li><li>     <span class="c">#include &lt;rpc/rpc.h&gt;</span></li><li></li><li>     <span class="w">typedef</span> <span class="w">struct</span> <span class="w">netconfig</span> <span class="w">Netconfig</span><span class="sc">;</span></li><li></li><li>     <span class="w">MODULE</span> = <span class="w">RPC</span>  <span class="w">PACKAGE</span> = <span class="w">RPC</span></li><li></li><li>     <span class="w">SV</span> *</li><li>     <span class="i">rpcb_gettime</span><span class="s">(</span><span class="w">host</span>=<span class="q">&quot;localhost&quot;</span><span class="s">)</span></li><li>          <span class="w">char</span> *<span class="w">host</span></li><li>	<span class="w">PREINIT</span><span class="co">:</span></li><li>          <span class="w">time_t</span>  <span class="w">timep</span><span class="sc">;</span></li><li>        <span class="j">CODE:</span></li><li>          <span class="i">ST</span><span class="s">(</span><span class="n">0</span><span class="s">)</span> = <span class="i">sv_newmortal</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li>          <a class="l_k" href="functions/if.html">if</a><span class="s">(</span> <span class="i">rpcb_gettime</span><span class="s">(</span> <span class="w">host</span><span class="cm">,</span> <span class="i">&amp;timep</span> <span class="s">)</span> <span class="s">)</span></li><li>               <span class="i">sv_setnv</span><span class="s">(</span> <span class="i">ST</span><span class="s">(</span><span class="n">0</span><span class="s">)</span><span class="cm">,</span> <span class="s">(</span><span class="w">double</span><span class="s">)</span><span class="w">timep</span> <span class="s">)</span><span class="sc">;</span></li><li></li><li>     <span class="w">Netconfig</span> *</li><li>     <span class="i">getnetconfigent</span><span class="s">(</span><span class="w">netid</span>=<span class="q">&quot;udp&quot;</span><span class="s">)</span></li><li>          <span class="w">char</span> *<span class="w">netid</span></li><li></li><li>     <span class="w">MODULE</span> = <span class="w">RPC</span>  <span class="w">PACKAGE</span> = <span class="w">NetconfigPtr</span>  <span class="w">PREFIX</span> = <span class="w">rpcb_</span></li><li></li><li>     <span class="w">void</span></li><li>     <span class="i">rpcb_DESTROY</span><span class="s">(</span><span class="w">netconf</span><span class="s">)</span></li><li>          <span class="w">Netconfig</span> *<span class="w">netconf</span></li><li>        <span class="w">CODE</span><span class="co">:</span></li><li>          <a class="l_k" href="functions/printf.html">printf</a><span class="s">(</span><span class="q">&quot;NetconfigPtr::DESTROY\n&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>          <span class="i">free</span><span class="s">(</span> <span class="w">netconf</span> <span class="s">)</span><span class="sc">;</span></li></ol></pre><p>File <code class="inline"><span class="w">typemap</span></code>
: Custom typemap for RPC.xs. (cf. <a href="perlxstypemap.html">perlxstypemap</a>)</p>
<pre class="verbatim"><ol><li>     <span class="w">TYPEMAP</span></li><li>     <span class="w">Netconfig</span> *  <span class="w">T_PTROBJ</span></li></ol></pre><p>File <code class="inline"><span class="w">RPC</span>.<span class="w">pm</span></code>
: Perl module for the RPC extension.</p>
<pre class="verbatim"><ol><li><a name="package-RPC"></a>     package <span class="i">RPC</span><span class="sc">;</span></li><li></li><li>     <a class="l_k" href="functions/require.html">require</a> <span class="w">Exporter</span><span class="sc">;</span></li><li>     <a class="l_k" href="functions/require.html">require</a> <span class="w">DynaLoader</span><span class="sc">;</span></li><li>     <span class="i">@ISA</span> = <span class="q">qw(Exporter DynaLoader)</span><span class="sc">;</span></li><li>     <span class="i">@EXPORT</span> = <span class="q">qw(rpcb_gettime getnetconfigent)</span><span class="sc">;</span></li><li></li><li>     <span class="w">bootstrap</span> <span class="w">RPC</span><span class="sc">;</span></li><li>     <span class="n">1</span><span class="sc">;</span></li></ol></pre><p>File <code class="inline"><span class="w">rpctest</span>.<span class="w">pl</span></code>
: Perl test program for the RPC extension.</p>
<pre class="verbatim"><ol><li>     <a class="l_k" href="functions/use.html">use</a> <span class="w">RPC</span><span class="sc">;</span></li><li></li><li>     <span class="i">$netconf</span> = <span class="i">getnetconfigent</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li>     <span class="i">$a</span> = <span class="i">rpcb_gettime</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span></li><li>     <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;time = $a\n&quot;</span><span class="sc">;</span></li><li>     <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;netconf = $netconf\n&quot;</span><span class="sc">;</span></li><li></li><li>     <span class="i">$netconf</span> = <span class="i">getnetconfigent</span><span class="s">(</span><span class="q">&quot;tcp&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>     <span class="i">$a</span> = <span class="i">rpcb_gettime</span><span class="s">(</span><span class="q">&quot;poplar&quot;</span><span class="s">)</span><span class="sc">;</span></li><li>     <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;time = $a\n&quot;</span><span class="sc">;</span></li><li>     <a class="l_k" href="functions/print.html">print</a> <span class="q">&quot;netconf = $netconf\n&quot;</span><span class="sc">;</span></li></ol></pre><a name="CAVEATS"></a><h1>CAVEATS</h1>
<p>XS code has full access to system calls including C library functions.
It thus has the capability of interfering with things that the Perl core
or other modules have set up, such as signal handlers or file handles.
It could mess with the memory, or any number of harmful things.  Don't.</p>
<p>Some modules have an event loop, waiting for user-input.  It is highly
unlikely that two such modules would work adequately together in a
single Perl application.</p>
<p>In general, the perl interpreter views itself as the center of the
universe as far as the Perl program goes.  XS code is viewed as a
help-mate, to accomplish things that perl doesn't do, or doesn't do fast
enough, but always subservient to perl.  The closer XS code adheres to
this model, the less likely conflicts will occur.</p>
<p>One area where there has been conflict is in regards to C locales.  (See
<a href="perllocale.html">perllocale</a>.)  perl, with one exception and unless told otherwise,
sets up the underlying locale the program is running in to the locale
passed
into it from the environment.  This is an important difference from a
generic C language program, where the underlying locale is the "C"
locale unless the program changes it.  As of v5.20, this underlying
locale is completely hidden from pure perl code outside the lexical
scope of <code class="inline"><a class="l_k" href="functions/use.html">use</a> <span class="w">locale</span></code>
 except for a couple of function calls in the
POSIX module which of necessity use it.  But the underlying locale, with
that
one exception is exposed to XS code, affecting all C library routines
whose behavior is locale-dependent.  Your XS code better not assume that
the underlying locale is "C".  The exception is the
<a href="perllocale.html#Category-LC_NUMERIC%3a-Numeric-Formatting">LC_NUMERIC </a>
locale category, and the reason it is an exception is that experience
has shown that it can be problematic for XS code, whereas we have not
had reports of problems with the
<a href="perllocale.html#WHAT-IS-A-LOCALE">other locale categories</a>.  And the reason
for this one category being problematic is that the character used as a
decimal point can vary.  Many European languages use a comma, whereas
English, and hence Perl are expecting a dot (U+002E: FULL STOP).  Many
modules can handle only the radix character being a dot, and so perl
attempts to make it so.  Up through Perl v5.20, the attempt was merely
to set <code class="inline"><span class="w">LC_NUMERIC</span></code>
 upon startup to the <code class="inline"><span class="q">&quot;C&quot;</span></code>
 locale.  Any
<a href="perllocale.html#The-setlocale-function">setlocale()</a> otherwise would change
it; this caused some failures.  Therefore, starting in v5.22, perl tries
to keep <code class="inline"><span class="w">LC_NUMERIC</span></code>
 always set to <code class="inline"><span class="q">&quot;C&quot;</span></code>
 for XS code.</p>
<p>To summarize, here's what to expect and how to handle locales in XS code:</p>
<ul>
<li><a name="Non-locale-aware-XS-code"></a><b>Non-locale-aware XS code</b>
<p>Keep in mind that even if you think your code is not locale-aware, it
may call a C library function that is.  Hopefully the man page for such
a function will indicate that dependency, but the documentation is
imperfect.</p>
<p>The current locale is exposed to XS code except possibly <code class="inline"><span class="w">LC_NUMERIC</span></code>

(explained in the next paragraph).
There have not been reports of problems with the other categories.
Perl initializes things on start-up so that the current locale is the
one which is indicated by the user's environment in effect at that time.
See <a href="perllocale.html#ENVIRONMENT">ENVIRONMENT in perllocale</a>.</p>
<p>However, up through v5.20, Perl initialized things on start-up so that
<code class="inline"><span class="w">LC_NUMERIC</span></code>
 was set to the "C" locale.  But if any code anywhere
changed it, it would stay changed.  This means that your module can't
count on <code class="inline"><span class="w">LC_NUMERIC</span></code>
 being something in particular, and you can't
expect floating point numbers (including version strings) to have dots
in them.  If you don't allow for a non-dot, your code could break if
anyone anywhere changed the locale.  For this reason, v5.22 changed
the behavior so that Perl tries to keep <code class="inline"><span class="w">LC_NUMERIC</span></code>
 in the "C" locale
except around the operations internally where it should be something
else.  Misbehaving XS code will always be able to change the locale
anyway, but the most common instance of this is checked for and
handled.</p>
</li>
<li><a name="Locale-aware-XS-code"></a><b>Locale-aware XS code</b>
<p>If the locale from the user's environment is desired, there should be no
need for XS code to set the locale except for <code class="inline"><span class="w">LC_NUMERIC</span></code>
, as perl has
already set it up.  XS code should avoid changing the locale, as it can
adversely affect other, unrelated, code and may not be thread safe.
However, some alien libraries that may be called do set it, such as
<code class="inline"><span class="w">Gtk</span></code>
.  This can cause problems for the perl core and other modules.
Starting in v5.20.1, calling the function
<a href="perlapi.html#sync_locale">sync_locale()</a> from XS should be sufficient to
avoid most of these problems.  Prior to this, you need a pure Perl
statement that does this:</p>
<pre class="verbatim"><ol><li> <span class="i">POSIX::setlocale</span><span class="s">(</span><span class="w">LC_ALL</span><span class="cm">,</span> <span class="i">POSIX::setlocale</span><span class="s">(</span><span class="w">LC_ALL</span><span class="s">)</span><span class="s">)</span><span class="sc">;</span></li></ol></pre><p>In the event that your XS code may need the underlying <code class="inline"><span class="w">LC_NUMERIC</span></code>

locale, there are macros available to access this; see
<a href="perlapi.html#Locale-related-functions-and-macros">Locale-related functions and macros in perlapi</a>.</p>
</li>
</ul>
<a name="XS-VERSION"></a><h1>XS VERSION</h1>
<p>This document covers features supported by <code class="inline"><span class="w">ExtUtils::ParseXS</span></code>

(also known as <code class="inline"><span class="w">xsubpp</span></code>
) 3.13_01.</p>
<a name="AUTHOR"></a><h1>AUTHOR</h1>
<p>Originally written by Dean Roehrich &lt;<i>roehrich@cray.com</i>&gt;.</p>
<p>Maintained since 1996 by The Perl Porters &lt;<i>perlbug@perl.org</i>&gt;.</p>




  <div id="page_index" class="hud_container">
    <div id="page_index_header" class="hud_header">
      <div id="page_index_close" class="hud_close"><a href="#" onClick="pageIndex.hide();return false;"></a></div>
      <div id="page_index_title" class="hud_title"><span class="hud_span_top">Page index</span></div>
      <div id="page_index_topright" class="hud_topright"></div>
    </div>
    <div id="page_index_content" class="hud_content">
      <ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION</a><ul><li><a href="#Introduction">Introduction</a><li><a href="#On-The-Road">On The Road</a><li><a href="#The-Anatomy-of-an-XSUB">The Anatomy of an XSUB</a><li><a href="#The-Argument-Stack">The Argument Stack</a><li><a href="#The-RETVAL-Variable">The RETVAL Variable</a><li><a href="#Returning-SVs%2c-AVs-and-HVs-through-RETVAL">Returning SVs, AVs and HVs through RETVAL</a><li><a href="#The-MODULE-Keyword">The MODULE Keyword</a><li><a href="#The-PACKAGE-Keyword">The PACKAGE Keyword</a><li><a href="#The-PREFIX-Keyword">The PREFIX Keyword</a><li><a href="#The-OUTPUT%3a-Keyword">The OUTPUT: Keyword</a><li><a href="#The-NO_OUTPUT-Keyword">The NO_OUTPUT Keyword</a><li><a href="#The-CODE%3a-Keyword">The CODE: Keyword</a><li><a href="#The-INIT%3a-Keyword">The INIT: Keyword</a><li><a href="#The-NO_INIT-Keyword">The NO_INIT Keyword</a><li><a href="#The-TYPEMAP%3a-Keyword">The TYPEMAP: Keyword</a><li><a href="#Initializing-Function-Parameters">Initializing Function Parameters</a><li><a href="#Default-Parameter-Values">Default Parameter Values</a><li><a href="#The-PREINIT%3a-Keyword">The PREINIT: Keyword</a><li><a href="#The-SCOPE%3a-Keyword">The SCOPE: Keyword</a><li><a href="#The-INPUT%3a-Keyword">The INPUT: Keyword</a><li><a href="#The-IN%2fOUTLIST%2fIN_OUTLIST%2fOUT%2fIN_OUT-Keywords">The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</a><li><a href="#The-length(NAME)-Keyword">The length(NAME) Keyword</a><li><a href="#Variable-length-Parameter-Lists">Variable-length Parameter Lists</a><li><a href="#The-C_ARGS%3a-Keyword">The C_ARGS: Keyword</a><li><a href="#The-PPCODE%3a-Keyword">The PPCODE: Keyword</a><li><a href="#Returning-Undef-And-Empty-Lists">Returning Undef And Empty Lists</a><li><a href="#The-REQUIRE%3a-Keyword">The REQUIRE: Keyword</a><li><a href="#The-CLEANUP%3a-Keyword">The CLEANUP: Keyword</a><li><a href="#The-POSTCALL%3a-Keyword">The POSTCALL: Keyword</a><li><a href="#The-BOOT%3a-Keyword">The BOOT: Keyword</a><li><a href="#The-VERSIONCHECK%3a-Keyword">The VERSIONCHECK: Keyword</a><li><a href="#The-PROTOTYPES%3a-Keyword">The PROTOTYPES: Keyword</a><li><a href="#The-PROTOTYPE%3a-Keyword">The PROTOTYPE: Keyword</a><li><a href="#The-ALIAS%3a-Keyword">The ALIAS: Keyword</a><li><a href="#The-OVERLOAD%3a-Keyword">The OVERLOAD: Keyword</a><li><a href="#The-FALLBACK%3a-Keyword">The FALLBACK: Keyword</a><li><a href="#The-INTERFACE%3a-Keyword">The INTERFACE: Keyword</a><li><a href="#The-INTERFACE_MACRO%3a-Keyword">The INTERFACE_MACRO: Keyword</a><li><a href="#The-INCLUDE%3a-Keyword">The INCLUDE: Keyword</a><li><a href="#The-INCLUDE_COMMAND%3a-Keyword">The INCLUDE_COMMAND: Keyword</a><li><a href="#The-CASE%3a-Keyword">The CASE: Keyword</a><li><a href="#The-EXPORT_XSUB_SYMBOLS%3a-Keyword">The EXPORT_XSUB_SYMBOLS: Keyword</a><li><a href="#The-%26-Unary-Operator">The & Unary Operator</a><li><a href="#Inserting-POD%2c-Comments-and-C-Preprocessor-Directives">Inserting POD, Comments and C Preprocessor Directives</a><li><a href="#Using-XS-With-C%2b%2b">Using XS With C++</a><li><a href="#Interface-Strategy">Interface Strategy</a><li><a href="#Perl-Objects-And-C-Structures">Perl Objects And C Structures</a><li><a href="#Safely-Storing-Static-Data-in-XS">Safely Storing Static Data in XS</a><li><a href="#Thread-aware-system-interfaces">Thread-aware system interfaces</a></ul><li><a href="#EXAMPLES">EXAMPLES</a><li><a href="#CAVEATS">CAVEATS</a><li><a href="#XS-VERSION">XS VERSION</a><li><a href="#AUTHOR">AUTHOR</a></ul>
    </div>
    <div id="page_index_footer" class="hud_footer">
      <div id="page_index_bottomleft" class="hud_bottomleft"></div>
      <div id="page_index_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
      <div id="page_index_resize" class="hud_resize"></div>
    </div>
  </div>


	    &nbsp;
          </div>
          <div id="content_footer">
          </div>
        </div>
        <div class="clear"></div>
      </div>
      
    <div id="footer">
      <div id="footer_content">
        <div id="footer_strapline">
          perldoc.perl.org - Official documentation for the Perl programming language
        </div>
        <div id="footer_links">
          <div id="address">
            <p class="name">Contact details</p>
            <p class="address">
	      Site maintained by <a href="mailto:jj@jonallen.info">Jon Allen (JJ)</a><br>
	    </p>
            <p class="contact">
              Documentation maintained by the <a href="http://lists.cpan.org/showlist.cgi?name=perl5-porters">Perl 5 Porters</a>
            </p>
          </div>
          <ul class="f1">
            <li>Manual
              <ul class="f2">
                <li><a href="index-overview.html">Overview</a>
                <li><a href="index-tutorials.html">Tutorials</a>
                <li><a href="index-faq.html">FAQs</a>
                <li><a href="index-history.html">Changes</a>
              </ul>
            <li>Reference
              <ul class="f2">
                <li><a href="index-language.html">Language</a>
                <li><a href="index-functions.html">Functions</a>
                <li><a href="perlop.html">Operators</a>
                <li><a href="perlvar.html">Variables</a>
              </ul>
            <li>Modules
              <ul class="f2">
                <li><a href="index-modules-A.html">Modules</a>
                <li><a href="index-pragmas.html">Pragmas</a>
                <li><a href="index-utilities.html">Utilities</a>
              </ul>
            <li>Misc
              <ul class="f2">
                <li><a href="index-licence.html">License</a>
                <li><a href="index-internals.html">Internals</a>
                <li><a href="index-platforms.html">Platforms</a>
              </ul>          </ul>
          <div class="clear"></div>
        </div>
      </div>
      <div id="footer_end">
      </div>
    </div>
      
    </div>
      <script language="JavaScript" type="text/javascript" src="static/exploreperl.js"></script>
      <script language="JavaScript" src="static/combined-20100403.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
  perldoc.setPath(0);
  perldoc.pageName    = 'perlxs';
  perldoc.pageAddress = 'perlxs.html';
  perldoc.contentPage = 1;
  explorePerl.render();
  explorePerl.addEvents('explore_anchor');
</script>
    
  </body>
</html>
