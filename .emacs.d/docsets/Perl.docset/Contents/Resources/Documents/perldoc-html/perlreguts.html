<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>perlreguts</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta http-equiv="Content-Language" content="en-gb">
  <link rel="search" type="application/opensearchdescription+xml" title="Search perldoc.perl.org" href="/static/search.xml"/>
  <link href="static/css-20100830.css" rel="stylesheet" rev="stylesheet" type="text/css" media="screen">
  <link href="static/exploreperl.css" rel="stylesheet" rev="stylesheet" type="text/css">
</head>

<body onLoad="perldoc.startup();" onPageShow="if (event.persisted) perldoc.startup();">
    <div id="page">
      
      <div id="header">
	<div id="homepage_link">
	  <a href="index.html"></a>
	</div>
	<div id="strapline">
	  Perl Programming Documentation
	</div>
	<div id="download_link" class="download">
	  <a href="http://www.perl.org/get.html">Download Perl</a>
	</div>
	<div id="explore_link" class="download">
	  <a id="explore_anchor" href="#">Explore</a>
	</div>
      </div>
      
      <div id="body">
        <div id="left_column">
          <div class="side_group">
            
	    <div class="side_panel doc_panel">
              <p>Manual</p>
              <ul>
                <li><a href="index-overview.html">Overview</a>
                <li><a href="index-tutorials.html">Tutorials</a>
                <li><a href="index-faq.html">FAQs</a>
                <li><a href="index-history.html">History / Changes</a>
                <li><a href="index-licence.html">License</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Reference</p>
              <ul>
                <li><a href="index-language.html">Language</a>
                <li><a href="index-functions.html">Functions</a>
                <li><a href="perlop.html">Operators</a>
                <li><a href="perlvar.html">Special Variables</a>
                <li><a href="index-pragmas.html">Pragmas</a>
                <li><a href="index-utilities.html">Utilities</a>
                <li><a href="index-internals.html">Internals</a>
                <li><a href="index-platforms.html">Platform Specific</a>
              </ul>
            </div>
            <div class="side_panel doc_panel">
              <p>Modules</p>
              <ul>
		<li>
		
                
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		    
		  
		
                  
		
                  
		
                  
		    
		  
		
                  
		
                  
		
		
                    <a href="index-modules-A.html">A</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-B.html">B</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-C.html">C</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-D.html">D</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-E.html">E</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-F.html">F</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-G.html">G</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-H.html">H</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-I.html">I</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-L.html">L</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-M.html">M</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-N.html">N</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-O.html">O</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-P.html">P</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-S.html">S</a>
                    
                      
                        <li>
                      
                    
                
                    <a href="index-modules-T.html">T</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-U.html">U</a>
                    
                      
                        &bull;
                      
                    
                
                    <a href="index-modules-X.html">X</a>
                    
                
              </ul>
            </div>
            
	      <div class="side_panel doc_panel">
		<p>Tools</p>
		<ul>
		  <li><a href="preferences.html">Preferences</a>
		</ul>
	      </div>
            
          </div>
        </div>
        <div id="centre_column">
          <div id="content_header">
            <div id="title_bar">
              <div id="page_name">
                <h1>perlreguts</h1>
              </div>
              <div id="perl_version">
                Perl 5 version 22.0 documentation
              </div>
              <div class="page_links" id="page_links_top">
                <a href="#" onClick="toolbar.goToTop();return false;">Go to top</a>
		
              </div>
	      <div class="page_links" id="page_links_bottom">
		
                  <a href="#" id="page_index_toggle">Show page index</a> &bull;
		
                <a href="#" id="recent_pages_toggle">Show recent pages</a>		
	      </div>
	      <div id="search_form">
		<form action="search.html" method="GET" id="search">
		  <input type="text" name="q" id="search_box" alt="Search">
		</form>
	      </div>
            </div>
            <div id="breadcrumbs">
                
    <a href="index.html">Home</a> &gt;
    
      
        <a href="index-internals.html">Internals and C language interface</a> &gt;
      
    
    perlreguts
  

            </div>
          </div>
          <div id="content_body">
	    <!--[if lt IE 7]>
 <div class="noscript">
   <p>
     <strong>It looks like you're using Internet Explorer 6. This is a very old
     browser which does not offer full support for modern websites.</strong>
   </p>
   <p>
     Unfortunately this means that this website will not work on
     your computer.
   </p>
   <p>
     Don't miss out though! To view the site (and get a better experience from
     many other websites), simply upgrade to
     <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet
Explorer 8</a>
     or download an alternative browser such as
     <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>,
     <a href="http://www.apple.com/safari/download/">Safari</a>, or
     <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
   </p>
   <p>
     All of these browsers are free. If you're using a PC at work, you may
     need to contact your IT administrator.
   </p>
 </div>
<![endif]-->
	    <noscript>
	      <div class="noscript">
	      <p>
                <strong>Please note: Many features of this site require JavaScript. You appear to have JavaScript disabled,
	        or are running a non-JavaScript capable web browser.</strong>
	      </p>
	      <p>
		To get the best experience, please enable JavaScript or download a modern web browser such as <a href="http://www.microsoft.com/windows/Internet-explorer/default.aspx">Internet Explorer 8</a>, <a href="http://www.mozilla.com/en-US/firefox/firefox.html">Firefox</a>, <a href="http://www.apple.com/safari/download/">Safari</a>, or <a href="http://www.google.co.uk/chrome">Google Chrome</a>.
              </p>
	      </div>
	    </noscript>

	    <div id="recent_pages" class="hud_container">
	      <div id="recent_pages_header" class="hud_header">
		<div id="recent_pages_close" class="hud_close"><a href="#" onClick="recentPages.hide();return false;"></a></div>
		<div id="recent_pages_title" class="hud_title"><span class="hud_span_top">Recently read</span></div>
		<div id="recent_pages_topright" class="hud_topright"></div>
	      </div>
	      <div id="recent_pages_content" class="hud_content">
	      </div>
	      <div id="recent_pages_footer" class="hud_footer">
		<div id="recent_pages_bottomleft" class="hud_bottomleft"></div>
		<div id="recent_pages_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
		<div id="recent_pages_resize" class="hud_resize"></div>
	      </div>
	    </div>
  
	    <div id="from_search"></div>
            <h1>perlreguts</h1>


  <!--    -->
<ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION</a><li><a href="#OVERVIEW">OVERVIEW</a><ul><li><a href="#A-quick-note-on-terms">A quick note on terms</a><li><a href="#What-is-a-regular-expression-engine%3f">What is a regular expression engine?</a><li><a href="#Structure-of-a-Regexp-Program">Structure of a Regexp Program</a></ul><li><a href="#Process-Overview">Process Overview</a><ul><li><a href="#Compilation">Compilation</a><li><a href="#Execution">Execution</a></ul><li><a href="#MISCELLANEOUS">MISCELLANEOUS</a><ul><li><a href="#Unicode-and-Localisation-Support">Unicode and Localisation Support</a><li><a href="#Base-Structures">Base Structures</a></ul><li><a href="#SEE-ALSO">SEE ALSO</a><li><a href="#AUTHOR">AUTHOR</a><li><a href="#LICENCE">LICENCE</a><li><a href="#REFERENCES">REFERENCES</a></ul><a name="NAME"></a><h1>NAME</h1>
<p>perlreguts - Description of the Perl regular expression engine.</p>
<a name="DESCRIPTION"></a><h1>DESCRIPTION</h1>
<p>This document is an attempt to shine some light on the guts of the regex
engine and how it works. The regex engine represents a significant chunk
of the perl codebase, but is relatively poorly understood. This document
is a meagre attempt at addressing this situation. It is derived from the
author's experience, comments in the source code, other papers on the
regex engine, feedback on the perl5-porters mail list, and no doubt other
places as well.</p>
<p><b>NOTICE!</b> It should be clearly understood that the behavior and
structures discussed in this represents the state of the engine as the
author understood it at the time of writing. It is <b>NOT</b> an API
definition, it is purely an internals guide for those who want to hack
the regex engine, or understand how the regex engine works. Readers of
this document are expected to understand perl's regex syntax and its
usage in detail. If you want to learn about the basics of Perl's
regular expressions, see <a href="perlre.html">perlre</a>. And if you want to replace the
regex engine with your own, see <a href="perlreapi.html">perlreapi</a>.</p>
<a name="OVERVIEW"></a><h1>OVERVIEW</h1>
<a name="A-quick-note-on-terms"></a><h2>A quick note on terms</h2>
<p>There is some debate as to whether to say "regexp" or "regex". In this
document we will use the term "regex" unless there is a special reason
not to, in which case we will explain why.</p>
<p>When speaking about regexes we need to distinguish between their source
code form and their internal form. In this document we will use the term
"pattern" when we speak of their textual, source code form, and the term
"program" when we speak of their internal representation. These
correspond to the terms <i>S-regex</i> and <i>B-regex</i> that Mark Jason
Dominus employs in his paper on "Rx" ([1] in <a href="#REFERENCES">REFERENCES</a>).</p>
<a name="What-is-a-regular-expression-engine%3f"></a><h2>What is a regular expression engine?</h2>
<p>A regular expression engine is a program that takes a set of constraints
specified in a mini-language, and then applies those constraints to a
target string, and determines whether or not the string satisfies the
constraints. See <a href="perlre.html">perlre</a> for a full definition of the language.</p>
<p>In less grandiose terms, the first part of the job is to turn a pattern into
something the computer can efficiently use to find the matching point in
the string, and the second part is performing the search itself.</p>
<p>To do this we need to produce a program by parsing the text. We then
need to execute the program to find the point in the string that
matches. And we need to do the whole thing efficiently.</p>
<a name="Structure-of-a-Regexp-Program"></a><h2>Structure of a Regexp Program</h2>
<a name="High-Level"></a><h3>High Level</h3>
<p>Although it is a bit confusing and some people object to the terminology, it
is worth taking a look at a comment that has
been in <i>regexp.h</i> for years:</p>
<p><i>This is essentially a linear encoding of a nondeterministic
finite-state machine (aka syntax charts or "railroad normal form" in
parsing technology).</i></p>
<p>The term "railroad normal form" is a bit esoteric, with "syntax
diagram/charts", or "railroad diagram/charts" being more common terms.
Nevertheless it provides a useful mental image of a regex program: each
node can be thought of as a unit of track, with a single entry and in
most cases a single exit point (there are pieces of track that fork, but
statistically not many), and the whole forms a layout with a
single entry and single exit point. The matching process can be thought
of as a car that moves along the track, with the particular route through
the system being determined by the character read at each possible
connector point. A car can fall off the track at any point but it may
only proceed as long as it matches the track.</p>
<p>Thus the pattern <code class="inline"><span class="q">/foo(?:\w+|\d+|\s+)bar/</span></code>
 can be thought of as the
following chart:</p>
<pre class="verbatim"><ol><li>                      [start]</li><li>                         |</li><li>                       &lt;foo&gt;</li><li>                         |</li><li>                   +-----+-----+</li><li>                   |     |     |</li><li>                 &lt;\w+&gt; &lt;\d+&gt; &lt;\s+&gt;</li><li>                   |     |     |</li><li>                   +-----+-----+</li><li>                         |</li><li>                       &lt;bar&gt;</li><li>                         |</li><li>                       [end]</li></ol></pre><p>The truth of the matter is that perl's regular expressions these days are
much more complex than this kind of structure, but visualising it this way
can help when trying to get your bearings, and it matches the
current implementation pretty closely.</p>
<p>To be more precise, we will say that a regex program is an encoding
of a graph. Each node in the graph corresponds to part of
the original regex pattern, such as a literal string or a branch,
and has a pointer to the nodes representing the next component
to be matched. Since "node" and "opcode" already have other meanings in the
perl source, we will call the nodes in a regex program "regops".</p>
<p>The program is represented by an array of <code class="inline"><span class="w">regnode</span></code>
 structures, one or
more of which represent a single regop of the program. Struct
<code class="inline"><span class="w">regnode</span></code>
 is the smallest struct needed, and has a field structure which is
shared with all the other larger structures.</p>
<p>The "next" pointers of all regops except <code class="inline"><span class="w">BRANCH</span></code>
 implement concatenation;
a "next" pointer with a <code class="inline"><span class="w">BRANCH</span></code>
 on both ends of it is connecting two
alternatives.  [Here we have one of the subtle syntax dependencies: an
individual <code class="inline"><span class="w">BRANCH</span></code>
 (as opposed to a collection of them) is never
concatenated with anything because of operator precedence.]</p>
<p>The operand of some types of regop is a literal string; for others,
it is a regop leading into a sub-program.  In particular, the operand
of a <code class="inline"><span class="w">BRANCH</span></code>
 node is the first regop of the branch.</p>
<p><b>NOTE</b>: As the railroad metaphor suggests, this is <b>not</b> a tree
structure:  the tail of the branch connects to the thing following the
set of <code class="inline"><span class="w">BRANCH</span></code>
es.  It is a like a single line of railway track that
splits as it goes into a station or railway yard and rejoins as it comes
out the other side.</p>
<a name="Regops"></a><h3>Regops</h3>
<p>The base structure of a regop is defined in <i>regexp.h</i> as follows:</p>
<pre class="verbatim"><ol><li>    struct regnode {</li><li>        U8  flags;    /* Various purposes, sometimes overridden */</li><li>        U8  type;     /* Opcode value as specified by regnodes.h */</li><li>        U16 next_off; /* Offset in size regnode */</li><li>    };</li></ol></pre><p>Other larger <code class="inline"><span class="w">regnode</span></code>
-like structures are defined in <i>regcomp.h</i>. They
are almost like subclasses in that they have the same fields as
<code class="inline"><span class="w">regnode</span></code>
, with possibly additional fields following in
the structure, and in some cases the specific meaning (and name)
of some of base fields are overridden. The following is a more
complete description.</p>
<ul>
<li><a name="regnode_1"></a><b><code class="inline"><span class="w">regnode_1</span></code>
</b>
</li>
<li><a name="regnode_2"></a><b><code class="inline"><span class="w">regnode_2</span></code>
</b>
<p><code class="inline"><span class="w">regnode_1</span></code>
 structures have the same header, followed by a single
four-byte argument; <code class="inline"><span class="w">regnode_2</span></code>
 structures contain two two-byte
arguments instead:</p>
<pre class="verbatim"><ol><li>    <span class="w">regnode_1</span>                <span class="w">U32</span> <span class="w">arg1</span><span class="sc">;</span></li><li>    <span class="w">regnode_2</span>                <span class="w">U16</span> <span class="w">arg1</span><span class="sc">;</span>  <span class="w">U16</span> <span class="w">arg2</span><span class="sc">;</span></li></ol></pre></li>
<li><a name="regnode_string"></a><b><code class="inline"><span class="w">regnode_string</span></code>
</b>
<p><code class="inline"><span class="w">regnode_string</span></code>
 structures, used for literal strings, follow the header
with a one-byte length and then the string data. Strings are padded on
the end with zero bytes so that the total length of the node is a
multiple of four bytes:</p>
<pre class="verbatim"><ol><li>    <span class="w">regnode_string</span>           <span class="w">char</span> <span class="w">string</span><span class="s">[</span><span class="n">1</span><span class="s">]</span><span class="sc">;</span></li><li>                             <span class="w">U8</span> <span class="w">str_len</span><span class="sc">;</span> <span class="q">/* overrides flags */</span></li></ol></pre></li>
<li><a name="regnode_charclass"></a><b><code class="inline"><span class="w">regnode_charclass</span></code>
</b>
<p>Bracketed character classes are represented by <code class="inline"><span class="w">regnode_charclass</span></code>

structures, which have a four-byte argument and then a 32-byte (256-bit)
bitmap indicating which characters in the Latin1 range are included in
the class.</p>
<pre class="verbatim"><ol><li>    <span class="w">regnode_charclass</span>        <span class="w">U32</span> <span class="w">arg1</span><span class="sc">;</span></li><li>                             <span class="w">char</span> <span class="w">bitmap</span><span class="s">[</span><span class="w">ANYOF_BITMAP_SIZE</span><span class="s">]</span><span class="sc">;</span></li></ol></pre><p>Various flags whose names begin with <code class="inline"><span class="w">ANYOF_</span></code>
 are used for special
situations.  Above Latin1 matches and things not known until run-time
are stored in <a href="#Perl's-pprivate-structure">Perl's pprivate structure</a>.</p>
</li>
<li><a name="regnode_charclass_posixl"></a><b><code class="inline"><span class="w">regnode_charclass_posixl</span></code>
</b>
<p>There is also a larger form of a char class structure used to represent
POSIX char classes under <code class="inline"><span class="q">/l</span></code>
 matching,
called <code class="inline"><span class="w">regnode_charclass_posixl</span></code>
 which has an
additional 32-bit bitmap indicating which POSIX char classes
have been included.</p>
<pre class="verbatim"><ol><li>   <span class="w">regnode_charclass_posixl</span> <span class="w">U32</span> <span class="w">arg1</span><span class="sc">;</span></li><li>                            <span class="w">char</span> <span class="w">bitmap</span><span class="s">[</span><span class="w">ANYOF_BITMAP_SIZE</span><span class="s">]</span><span class="sc">;</span></li><li>                            <span class="w">U32</span> <span class="w">classflags</span><span class="sc">;</span></li></ol></pre></li>
</ul>
<p><i>regnodes.h</i> defines an array called <code class="inline"><span class="w">regarglen</span><span class="s">[</span><span class="s">]</span></code>
 which gives the size
of each opcode in units of <code class="inline"><span class="w">size</span> <span class="w">regnode</span></code>
 (4-byte). A macro is used
to calculate the size of an <code class="inline"><span class="w">EXACT</span></code>
 node based on its <code class="inline"><span class="w">str_len</span></code>
 field.</p>
<p>The regops are defined in <i>regnodes.h</i> which is generated from
<i>regcomp.sym</i> by <i>regcomp.pl</i>. Currently the maximum possible number
of distinct regops is restricted to 256, with about a quarter already
used.</p>
<p>A set of macros makes accessing the fields
easier and more consistent. These include <code class="inline"><span class="i">OP</span><span class="s">(</span><span class="s">)</span></code>
, which is used to determine
the type of a <code class="inline"><span class="w">regnode</span></code>
-like structure; <code class="inline"><span class="i">NEXT_OFF</span><span class="s">(</span><span class="s">)</span></code>
, which is the offset to
the next node (more on this later); <code class="inline"><span class="i">ARG</span><span class="s">(</span><span class="s">)</span></code>
, <code class="inline"><span class="i">ARG1</span><span class="s">(</span><span class="s">)</span></code>
, <code class="inline"><span class="i">ARG2</span><span class="s">(</span><span class="s">)</span></code>
, <code class="inline"><span class="i">ARG_SET</span><span class="s">(</span><span class="s">)</span></code>
,
and equivalents for reading and setting the arguments; and <code class="inline"><span class="i">STR_LEN</span><span class="s">(</span><span class="s">)</span></code>
,
<code class="inline"><span class="i">STRING</span><span class="s">(</span><span class="s">)</span></code>
 and <code class="inline"><span class="i">OPERAND</span><span class="s">(</span><span class="s">)</span></code>
 for manipulating strings and regop bearing
types.</p>
<a name="What-regop-is-next%3f"></a><h3>What regop is next?</h3>
<p>There are three distinct concepts of "next" in the regex engine, and
it is important to keep them clear.</p>
<ul>
<li>
<p>There is the "next regnode" from a given regnode, a value which is
rarely useful except that sometimes it matches up in terms of value
with one of the others, and that sometimes the code assumes this to
always be so.</p>
</li>
<li>
<p>There is the "next regop" from a given regop/regnode. This is the
regop physically located after the current one, as determined by
the size of the current regop. This is often useful, such as when
dumping the structure we use this order to traverse. Sometimes the code
assumes that the "next regnode" is the same as the "next regop", or in
other words assumes that the sizeof a given regop type is always going
to be one regnode large.</p>
</li>
<li>
<p>There is the "regnext" from a given regop. This is the regop which
is reached by jumping forward by the value of <code class="inline"><span class="i">NEXT_OFF</span><span class="s">(</span><span class="s">)</span></code>
,
or in a few cases for longer jumps by the <code class="inline"><span class="w">arg1</span></code>
 field of the <code class="inline"><span class="w">regnode_1</span></code>

structure. The subroutine <code class="inline"><span class="i">regnext</span><span class="s">(</span><span class="s">)</span></code>
 handles this transparently.
This is the logical successor of the node, which in some cases, like
that of the <code class="inline"><span class="w">BRANCH</span></code>
 regop, has special meaning.</p>
</li>
</ul>
<a name="Process-Overview"></a><h1>Process Overview</h1>
<p>Broadly speaking, performing a match of a string against a pattern
involves the following steps:</p>
<ul>
<li><a name="A.-Compilation"></a><b>A. Compilation</b>
<dl>
<dt>1. </dt><dd><a name="1.-Parsing-for-size"></a><b>Parsing for size</b>
</dd>
<dt>2. </dt><dd><a name="2.-Parsing-for-construction"></a><b>Parsing for construction</b>
</dd>
<dt>3. </dt><dd><a name="3.-Peep-hole-optimisation-and-analysis"></a><b>Peep-hole optimisation and analysis</b>
</dd>
</dl>
</li>
<li><a name="B.-Execution"></a><b>B. Execution</b>
<dl>
<dt>4. </dt><dd><a name="4.-Start-position-and-no-match-optimisations"></a><b>Start position and no-match optimisations</b>
</dd>
<dt>5. </dt><dd><a name="5.-Program-execution"></a><b>Program execution</b>
</dd>
</dl>
</li>
</ul>
<p>Where these steps occur in the actual execution of a perl program is
determined by whether the pattern involves interpolating any string
variables. If interpolation occurs, then compilation happens at run time. If it
does not, then compilation is performed at compile time. (The <code class="inline">/o</code> modifier changes this,
as does <code class="inline"><a class="l_k" href="functions/qr.html">qr//</a></code> to a certain extent.) The engine doesn't really care that
much.</p>
<a name="Compilation"></a><h2>Compilation</h2>
<p>This code resides primarily in <i>regcomp.c</i>, along with the header files
<i>regcomp.h</i>, <i>regexp.h</i> and <i>regnodes.h</i>.</p>
<p>Compilation starts with <code class="inline"><span class="i">pregcomp</span><span class="s">(</span><span class="s">)</span></code>
, which is mostly an initialisation
wrapper which farms work out to two other routines for the heavy lifting: the
first is <code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
, which is the start point for parsing; the second,
<code class="inline"><span class="i">study_chunk</span><span class="s">(</span><span class="s">)</span></code>
, is responsible for optimisation.</p>
<p>Initialisation in <code class="inline"><span class="i">pregcomp</span><span class="s">(</span><span class="s">)</span></code>
 mostly involves the creation and data-filling
of a special structure, <code class="inline"><span class="w">RExC_state_t</span></code>
 (defined in <i>regcomp.c</i>).
Almost all internally-used routines in <i>regcomp.h</i> take a pointer to one
of these structures as their first argument, with the name <code class="inline"><span class="w">pRExC_state</span></code>
.
This structure is used to store the compilation state and contains many
fields. Likewise there are many macros which operate on this
variable: anything that looks like <code class="inline"><span class="w">RExC_xxxx</span></code>
 is a macro that operates on
this pointer/structure.</p>
<a name="Parsing-for-size"></a><h3>Parsing for size</h3>
<p>In this pass the input pattern is parsed in order to calculate how much
space is needed for each regop we would need to emit. The size is also
used to determine whether long jumps will be required in the program.</p>
<p>This stage is controlled by the macro <code class="inline"><span class="w">SIZE_ONLY</span></code>
 being set.</p>
<p>The parse proceeds pretty much exactly as it does during the
construction phase, except that most routines are short-circuited to
change the size field <code class="inline"><span class="w">RExC_size</span></code>
 and not do anything else.</p>
<a name="Parsing-for-construction"></a><h3>Parsing for construction</h3>
<p>Once the size of the program has been determined, the pattern is parsed
again, but this time for real. Now <code class="inline"><span class="w">SIZE_ONLY</span></code>
 will be false, and the
actual construction can occur.</p>
<p><code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
 is the start of the parse process. It is responsible for
parsing an arbitrary chunk of pattern up to either the end of the
string, or the first closing parenthesis it encounters in the pattern.
This means it can be used to parse the top-level regex, or any section
inside of a grouping parenthesis. It also handles the "special parens"
that perl's regexes have. For instance when parsing <code class="inline"><span class="q">/x(?:foo)y/</span></code>
 <code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>

will at one point be called to parse from the "?" symbol up to and
including the ")".</p>
<p>Additionally, <code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
 is responsible for parsing the one or more
branches from the pattern, and for "finishing them off" by correctly
setting their next pointers. In order to do the parsing, it repeatedly
calls out to <code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>
, which is responsible for handling up to the
first <code class="inline">|</code> symbol it sees.</p>
<p><code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>
 in turn calls <code class="inline"><span class="i">regpiece</span><span class="s">(</span><span class="s">)</span></code>
 which
handles "things" followed by a quantifier. In order to parse the
"things", <code class="inline"><span class="i">regatom</span><span class="s">(</span><span class="s">)</span></code>
 is called. This is the lowest level routine, which
parses out constant strings, character classes, and the
various special symbols like <code class="inline"><span class="i">$</span></code>
. If <code class="inline"><span class="i">regatom</span><span class="s">(</span><span class="s">)</span></code>
 encounters a "("
character it in turn calls <code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
.</p>
<p>The routine <code class="inline"><span class="i">regtail</span><span class="s">(</span><span class="s">)</span></code>
 is called by both <code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
 and <code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>

in order to "set the tail pointer" correctly. When executing and
we get to the end of a branch, we need to go to the node following the
grouping parens. When parsing, however, we don't know where the end will
be until we get there, so when we do we must go back and update the
offsets as appropriate. <code class="inline"><span class="w">regtail</span></code>
 is used to make this easier.</p>
<p>A subtlety of the parsing process means that a regex like <code class="inline"><span class="q">/foo/</span></code>
 is
originally parsed into an alternation with a single branch. It is only
afterwards that the optimiser converts single branch alternations into the
simpler form.</p>
<a name="Parse-Call-Graph-and-a-Grammar"></a><h3>Parse Call Graph and a Grammar</h3>
<p>The call graph looks like this:</p>
<pre class="verbatim"><ol><li> <span class="i">reg</span><span class="s">(</span><span class="s">)</span>                        <span class="c"># parse a top level regex, or inside of</span></li><li>                              <span class="c"># parens</span></li><li>     <span class="i">regbranch</span><span class="s">(</span><span class="s">)</span>              <span class="c"># parse a single branch of an alternation</span></li><li>         <span class="i">regpiece</span><span class="s">(</span><span class="s">)</span>           <span class="c"># parse a pattern followed by a quantifier</span></li><li>             <span class="i">regatom</span><span class="s">(</span><span class="s">)</span>        <span class="c"># parse a simple pattern</span></li><li>                 <span class="i">regclass</span><span class="s">(</span><span class="s">)</span>   <span class="c">#   used to handle a class</span></li><li>                 <span class="i">reg</span><span class="s">(</span><span class="s">)</span>        <span class="c">#   used to handle a parenthesised</span></li><li>                              <span class="c">#   subpattern</span></li><li>                 ....</li><li>         ...</li><li>         <span class="i">regtail</span><span class="s">(</span><span class="s">)</span>            <span class="c"># finish off the branch</span></li><li>     ...</li><li>     <span class="i">regtail</span><span class="s">(</span><span class="s">)</span>                <span class="c"># finish off the branch sequence. Tie each</span></li><li>                              <span class="c"># branch&#39;s tail to the tail of the</span></li><li>                              <span class="c"># sequence</span></li><li>                              <span class="c"># (NEW) In Debug mode this is</span></li><li>                              <span class="c"># regtail_study().</span></li></ol></pre><p>A grammar form might be something like this:</p>
<pre class="verbatim"><ol><li>    atom  : constant | class</li><li>    quant : '*' | '+' | '?' | '{min,max}'</li><li>    _branch: piece</li><li>           | piece _branch</li><li>           | nothing</li><li>    branch: _branch</li><li>          | _branch '|' branch</li><li>    group : '(' branch ')'</li><li>    _piece: atom | group</li><li>    piece : _piece</li><li>          | _piece quant</li></ol></pre><a name="Parsing-complications"></a><h3>Parsing complications</h3>
<p>The implication of the above description is that a pattern containing nested
parentheses will result in a call graph which cycles through <code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
,
<code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>
, <code class="inline"><span class="i">regpiece</span><span class="s">(</span><span class="s">)</span></code>
, <code class="inline"><span class="i">regatom</span><span class="s">(</span><span class="s">)</span></code>
, <code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
, <code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>
 <i>etc</i>
multiple times, until the deepest level of nesting is reached. All the above
routines return a pointer to a <code class="inline"><span class="w">regnode</span></code>
, which is usually the last regnode
added to the program. However, one complication is that reg() returns NULL
for parsing <code class="inline">(?:)</code> syntax for embedded modifiers, setting the flag
<code class="inline"><span class="w">TRYAGAIN</span></code>
. The <code class="inline"><span class="w">TRYAGAIN</span></code>
 propagates upwards until it is captured, in
some cases by <code class="inline"><span class="i">regatom</span><span class="s">(</span><span class="s">)</span></code>
, but otherwise unconditionally by
<code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>
. Hence it will never be returned by <code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>
 to
<code class="inline"><span class="i">reg</span><span class="s">(</span><span class="s">)</span></code>
. This flag permits patterns such as <code class="inline"><span class="s">(</span><span class="q">?i)+</span></code>
 to be detected as
errors (<i>Quantifier follows nothing in regex; marked by &lt;-- HERE in m/(?i)+
&lt;-- HERE /</i>).</p>
<p>Another complication is that the representation used for the program differs
if it needs to store Unicode, but it's not always possible to know for sure
whether it does until midway through parsing. The Unicode representation for
the program is larger, and cannot be matched as efficiently. (See <a href="#Unicode-and-Localisation-Support">Unicode and Localisation Support</a> below for more details as to why.)  If the pattern
contains literal Unicode, it's obvious that the program needs to store
Unicode. Otherwise, the parser optimistically assumes that the more
efficient representation can be used, and starts sizing on this basis.
However, if it then encounters something in the pattern which must be stored
as Unicode, such as an <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code>
 escape sequence representing a character
literal, then this means that all previously calculated sizes need to be
redone, using values appropriate for the Unicode representation. Currently,
all regular expression constructions which can trigger this are parsed by code
in <code class="inline"><span class="i">regatom</span><span class="s">(</span><span class="s">)</span></code>
.</p>
<p>To avoid wasted work when a restart is needed, the sizing pass is abandoned
- <code class="inline"><span class="i">regatom</span><span class="s">(</span><span class="s">)</span></code>
 immediately returns NULL, setting the flag <code class="inline"><span class="w">RESTART_UTF8</span></code>
.
(This action is encapsulated using the macro <code class="inline"><span class="w">REQUIRE_UTF8</span></code>
.) This restart
request is propagated up the call chain in a similar fashion, until it is
"caught" in <code class="inline"><span class="i">Perl_re_op_compile</span><span class="s">(</span><span class="s">)</span></code>
, which marks the pattern as containing
Unicode, and restarts the sizing pass. It is also possible for constructions
within run-time code blocks to turn out to need Unicode representation.,
which is signalled by <code class="inline"><span class="i">S_compile_runtime_code</span><span class="s">(</span><span class="s">)</span></code>
 returning false to
<code class="inline"><span class="i">Perl_re_op_compile</span><span class="s">(</span><span class="s">)</span></code>
.</p>
<p>The restart was previously implemented using a <code class="inline"><span class="w">longjmp</span></code>
 in <code class="inline"><span class="i">regatom</span><span class="s">(</span><span class="s">)</span></code>

back to a <code class="inline"><span class="w">setjmp</span></code>
 in <code class="inline"><span class="i">Perl_re_op_compile</span><span class="s">(</span><span class="s">)</span></code>
, but this proved to be
problematic as the latter is a large function containing many automatic
variables, which interact badly with the emergent control flow of <code class="inline"><span class="w">setjmp</span></code>
.</p>
<a name="Debug-Output"></a><h3>Debug Output</h3>
<p>In the 5.9.x development version of perl you can <code class="inline"><a class="l_k" href="functions/use.html">use</a> <span class="w">re</span> <span class="w">Debug</span> <span class="cm">=&gt;</span> <span class="q">'PARSE'</span></code>

to see some trace information about the parse process. We will start with some
simple patterns and build up to more complex patterns.</p>
<p>So when we parse <code class="inline"><span class="q">/foo/</span></code>
 we see something like the following table. The
left shows what is being parsed, and the number indicates where the next regop
would go. The stuff on the right is the trace output of the graph. The
names are chosen to be short to make it less dense on the screen. 'tsdy'
is a special form of <code class="inline"><span class="i">regtail</span><span class="s">(</span><span class="s">)</span></code>
 which does some extra analysis.</p>
<pre class="verbatim"><ol><li> &gt;foo&lt;             1    reg</li><li>                          brnc</li><li>                            piec</li><li>                              atom</li><li> &gt;&lt;                4      tsdy~ EXACT &lt;foo&gt; (EXACT) (1)</li><li>                              ~ attach to END (3) offset to 2</li></ol></pre><p>The resulting program then looks like:</p>
<pre class="verbatim"><ol><li>   1: EXACT &lt;foo&gt;(3)</li><li>   3: END(0)</li></ol></pre><p>As you can see, even though we parsed out a branch and a piece, it was ultimately
only an atom. The final program shows us how things work. We have an <code class="inline"><span class="w">EXACT</span></code>
 regop,
followed by an <code class="inline">END</code>
 regop. The number in parens indicates where the <code class="inline"><span class="w">regnext</span></code>
 of
the node goes. The <code class="inline"><span class="w">regnext</span></code>
 of an <code class="inline">END</code>
 regop is unused, as <code class="inline">END</code>
 regops mean
we have successfully matched. The number on the left indicates the position of
the regop in the regnode array.</p>
<p>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern
<code class="inline"><span class="q">/foo+/</span></code>
. We will see that <code class="inline"><span class="i">regbranch</span><span class="s">(</span><span class="s">)</span></code>
 calls <code class="inline"><span class="i">regpiece</span><span class="s">(</span><span class="s">)</span></code>
 twice.</p>
<pre class="verbatim"><ol><li> &gt;foo+&lt;            1    reg</li><li>                          brnc</li><li>                            piec</li><li>                              atom</li><li> &gt;o+&lt;              3        piec</li><li>                              atom</li><li> &gt;&lt;                6        tail~ EXACT &lt;fo&gt; (1)</li><li>                   7      tsdy~ EXACT &lt;fo&gt; (EXACT) (1)</li><li>                              ~ PLUS (END) (3)</li><li>                              ~ attach to END (6) offset to 3</li></ol></pre><p>And we end up with the program:</p>
<pre class="verbatim"><ol><li>   1: EXACT &lt;fo&gt;(3)</li><li>   3: PLUS(6)</li><li>   4:   EXACT &lt;o&gt;(0)</li><li>   6: END(0)</li></ol></pre><p>Now we have a special case. The <code class="inline"><span class="w">EXACT</span></code>
 regop has a <code class="inline"><span class="w">regnext</span></code>
 of 0. This is
because if it matches it should try to match itself again. The <code class="inline"><span class="w">PLUS</span></code>
 regop
handles the actual failure of the <code class="inline"><span class="w">EXACT</span></code>
 regop and acts appropriately (going
to regnode 6 if the <code class="inline"><span class="w">EXACT</span></code>
 matched at least once, or failing if it didn't).</p>
<p>Now for something much more complex: <code class="inline"><span class="q">/x(?:foo*|b[a][rR])(foo|bar)$/</span></code>
</p>
<pre class="verbatim"><ol><li> &gt;<span class="i">x</span><span class="s">(</span><span class="q">?:foo*|b...    1    reg</span></li><li>                          <span class="q">                          brnc</span></li><li>                            <span class="q">                            piec</span></li><li>                              <span class="q">                              atom</span></li><li> <span class="q"> &gt;(?</span><span class="co">:</span><span class="w">foo</span>*|<span class="w">b</span><span class="s">[</span>...    <span class="n">3</span>        <span class="w">piec</span></li><li>                              <span class="w">atom</span></li><li> &gt;<span class="q">?:foo*|b[a...                 reg</span></li><li> <span class="q"> &gt;foo*|b[a][...                   brnc</span></li><li>                                    <span class="q">                                    piec</span></li><li>                                      <span class="q">                                      atom</span></li><li> <span class="q"> &gt;o*|b[a][rR...    5                piec</span></li><li>                                      <span class="q">                                      atom</span></li><li> <span class="q"> &gt;|b[a][rR])...    8                tail~ EXACT &lt;fo&gt; (3)</span></li><li> <span class="q"> &gt;b[a][rR])(...    9              brnc</span></li><li>                  <span class="q">                  10                piec</span></li><li>                                      <span class="q">                                      atom</span></li><li> <span class="q"> &gt;[a][rR])(f...   12                piec</span></li><li>                                      <span class="q">                                      atom</span></li><li> <span class="q"> &gt;a][rR])(fo...                         clas</span></li><li> <span class="q"> &gt;[rR])(foo|...   14                tail~ EXACT &lt;b&gt; (10)</span></li><li>                                    <span class="q">                                    piec</span></li><li>                                      <span class="q">                                      atom</span></li><li> <span class="q"> &gt;rR])(foo|b...                         clas</span></li><li> <span class="q"> &gt;)(foo|bar)...   25                tail~ EXACT &lt;a&gt; (12)</span></li><li>                                  <span class="q">                                  tail~ BRANCH (3)</span></li><li>                  <span class="q">                  26              tsdy~ BRANCH (END) (9)</span></li><li>                                      <span class="q">                                      ~ attach to TAIL (25) offset to 16</span></li><li>                                  <span class="q">                                  tsdy~ EXACT &lt;fo&gt; (EXACT) (4)</span></li><li>                                      <span class="q">                                      ~ STAR (END) (6)</span></li><li>                                      <span class="q">                                      ~ attach to TAIL (25) offset to 19</span></li><li>                                  <span class="q">                                  tsdy~ EXACT &lt;b&gt; (EXACT) (10)</span></li><li>                                      <span class="q">                                      ~ EXACT &lt;a&gt; (EXACT) (12)</span></li><li>                                      <span class="q">                                      ~ ANYOF[Rr] (END) (14)</span></li><li>                                      <span class="q">                                      ~ attach to TAIL (25) offset to 11</span></li><li> <span class="q"> &gt;(foo|bar)$&lt;               tail~ EXACT &lt;x&gt; (1)</span></li><li>                            <span class="q">                            piec</span></li><li>                              <span class="q">                              atom</span></li><li> <span class="q"> &gt;foo|bar)$&lt;                    reg</span></li><li>                  <span class="q">                  28              brnc</span></li><li>                                    <span class="q">                                    piec</span></li><li>                                      <span class="q">                                      atom</span></li><li> <span class="q"> &gt;|bar)$&lt;         31              tail~ OPEN1 (26)</span></li><li> <span class="q"> &gt;bar)$&lt;                          brnc</span></li><li>                  <span class="q">                  32                piec</span></li><li>                                      <span class="q">                                      atom</span></li><li> <span class="q"> &gt;)$&lt;             34              tail~ BRANCH (28)</span></li><li>                  <span class="q">                  36              tsdy~ BRANCH (END) (31)</span></li><li>                                     <span class="q">                                     ~ attach to CLOSE1 (34) offset to 3</span></li><li>                                  <span class="q">                                  tsdy~ EXACT &lt;foo&gt; (EXACT) (29)</span></li><li>                                     <span class="q">                                     ~ attach to CLOSE1 (34) offset to 5</span></li><li>                                  <span class="q">                                  tsdy~ EXACT &lt;bar&gt; (EXACT) (32)</span></li><li>                                     <span class="q">                                     ~ attach to CLOSE1 (34) offset to 2</span></li><li> <span class="q"> &gt;$&lt;                        tail~ BRANCH (3)</span></li><li>                                <span class="q">                                ~ BRANCH (9)</span></li><li>                                <span class="q">                                ~ TAIL (25)</span></li><li>                            <span class="q">                            piec</span></li><li>                              <span class="q">                              atom</span></li><li> <span class="q"> &gt;&lt;               37        tail~ OPEN1 (26)</span></li><li>                                <span class="q">                                ~ BRANCH (28)</span></li><li>                                <span class="q">                                ~ BRANCH (31)</span></li><li>                                <span class="q">                                ~ CLOSE1 (34)</span></li><li>                  <span class="q">                  38      tsdy~ EXACT &lt;x&gt; (EXACT) (1)</span></li><li>                              <span class="q">                              ~ BRANCH (END) (3)</span></li><li>                              <span class="q">                              ~ BRANCH (END) (9)</span></li><li>                              <span class="q">                              ~ TAIL (END) (25)</span></li><li>                              <span class="q">                              ~ OPEN1 (END) (26)</span></li><li>                              <span class="q">                              ~ BRANCH (END) (28)</span></li><li>                              <span class="q">                              ~ BRANCH (END) (31)</span></li><li>                              <span class="q">                              ~ CLOSE1 (END) (34)</span></li><li>                              <span class="q">                              ~ EOL (END) (36)</span></li><li>                              <span class="q">                              ~ attach to END (37) offset to 1</span></li></ol></pre><p>Resulting in the program</p>
<pre class="verbatim"><ol><li>   1: EXACT &lt;x&gt;(3)</li><li>   3: BRANCH(9)</li><li>   4:   EXACT &lt;fo&gt;(6)</li><li>   6:   STAR(26)</li><li>   7:     EXACT &lt;o&gt;(0)</li><li>   9: BRANCH(25)</li><li>  10:   EXACT &lt;ba&gt;(14)</li><li>  12:   OPTIMIZED (2 nodes)</li><li>  14:   ANYOF[Rr](26)</li><li>  25: TAIL(26)</li><li>  26: OPEN1(28)</li><li>  28:   TRIE-EXACT(34)</li><li>        [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3 Stcls:bf]</li><li>          &lt;foo&gt;</li><li>          &lt;bar&gt;</li><li>  30:   OPTIMIZED (4 nodes)</li><li>  34: CLOSE1(36)</li><li>  36: EOL(37)</li><li>  37: END(0)</li></ol></pre><p>Here we can see a much more complex program, with various optimisations in
play. At regnode 10 we see an example where a character class with only
one character in it was turned into an <code class="inline"><span class="w">EXACT</span></code>
 node. We can also see where
an entire alternation was turned into a <code class="inline"><span class="w">TRIE</span>-<span class="w">EXACT</span></code>
 node. As a consequence,
some of the regnodes have been marked as optimised away. We can see that
the <code class="inline"><span class="i">$</span></code>
 symbol has been converted into an <code class="inline"><span class="w">EOL</span></code>
 regop, a special piece of
code that looks for <code class="inline">\<span class="w">n</span></code>
 or the end of the string.</p>
<p>The next pointer for <code class="inline"><span class="w">BRANCH</span></code>
es is interesting in that it points at where
execution should go if the branch fails. When executing, if the engine
tries to traverse from a branch to a <code class="inline"><span class="w">regnext</span></code>
 that isn't a branch then
the engine will know that the entire set of branches has failed.</p>
<a name="Peep-hole-Optimisation-and-Analysis"></a><h3>Peep-hole Optimisation and Analysis</h3>
<p>The regular expression engine can be a weighty tool to wield. On long
strings and complex patterns it can end up having to do a lot of work
to find a match, and even more to decide that no match is possible.
Consider a situation like the following pattern.</p>
<pre class="verbatim"><ol><li>   <span class="q">'ababababababababababab'</span> =~ <span class="q">/(a|b)*z/</span></li></ol></pre><p>The <code class="inline"><span class="s">(</span><span class="w">a</span>|<span class="w">b</span><span class="s">)</span>*</code>
 part can match at every char in the string, and then fail
every time because there is no <code class="inline"><span class="w">z</span></code>
 in the string. So obviously we can
avoid using the regex engine unless there is a <code class="inline"><span class="w">z</span></code>
 in the string.
Likewise in a pattern like:</p>
<pre class="verbatim"><ol><li>   <span class="q">/foo(\w+)bar/</span></li></ol></pre><p>In this case we know that the string must contain a <code class="inline"><span class="w">foo</span></code>
 which must be
followed by <code class="inline"><span class="w">bar</span></code>
. We can use Fast Boyer-Moore matching as implemented
in <code class="inline"><span class="i">fbm_instr</span><span class="s">(</span><span class="s">)</span></code>
 to find the location of these strings. If they don't exist
then we don't need to resort to the much more expensive regex engine.
Even better, if they do exist then we can use their positions to
reduce the search space that the regex engine needs to cover to determine
if the entire pattern matches.</p>
<p>There are various aspects of the pattern that can be used to facilitate
optimisations along these lines:</p>
<ul>
<li><a name="*-anchored-fixed-strings"></a><b>anchored fixed strings</b>
</li>
<li><a name="*-floating-fixed-strings"></a><b>floating fixed strings</b>
</li>
<li><a name="*-minimum-and-maximum-length-requirements"></a><b>minimum and maximum length requirements</b>
</li>
<li><a name="*-start-class"></a><b>start class</b>
</li>
<li><a name="*-Beginning%2fEnd-of-line-positions"></a><b>Beginning/End of line positions</b>
</li>
</ul>
<p>Another form of optimisation that can occur is the post-parse "peep-hole"
optimisation, where inefficient constructs are replaced by more efficient
constructs. The <code class="inline"><span class="w">TAIL</span></code>
 regops which are used during parsing to mark the end
of branches and the end of groups are examples of this. These regops are used
as place-holders during construction and "always match" so they can be
"optimised away" by making the things that point to the <code class="inline"><span class="w">TAIL</span></code>
 point to the
thing that <code class="inline"><span class="w">TAIL</span></code>
 points to, thus "skipping" the node.</p>
<p>Another optimisation that can occur is that of "<code class="inline"><span class="w">EXACT</span></code>
 merging" which is
where two consecutive <code class="inline"><span class="w">EXACT</span></code>
 nodes are merged into a single
regop. An even more aggressive form of this is that a branch
sequence of the form <code class="inline"><span class="w">EXACT</span> <span class="w">BRANCH</span> ... <span class="w">EXACT</span></code>
 can be converted into a
<code class="inline"><span class="w">TRIE</span>-<span class="w">EXACT</span></code>
 regop.</p>
<p>All of this occurs in the routine <code class="inline"><span class="i">study_chunk</span><span class="s">(</span><span class="s">)</span></code>
 which uses a special
structure <code class="inline"><span class="w">scan_data_t</span></code>
 to store the analysis that it has performed, and
does the "peep-hole" optimisations as it goes.</p>
<p>The code involved in <code class="inline"><span class="i">study_chunk</span><span class="s">(</span><span class="s">)</span></code>
 is extremely cryptic. Be careful. :-)</p>
<a name="Execution"></a><h2>Execution</h2>
<p>Execution of a regex generally involves two phases, the first being
finding the start point in the string where we should match from,
and the second being running the regop interpreter.</p>
<p>If we can tell that there is no valid start point then we don't bother running
the interpreter at all. Likewise, if we know from the analysis phase that we
cannot detect a short-cut to the start position, we go straight to the
interpreter.</p>
<p>The two entry points are <code class="inline"><span class="i">re_intuit_start</span><span class="s">(</span><span class="s">)</span></code>
 and <code class="inline"><span class="i">pregexec</span><span class="s">(</span><span class="s">)</span></code>
. These routines
have a somewhat incestuous relationship with overlap between their functions,
and <code class="inline"><span class="i">pregexec</span><span class="s">(</span><span class="s">)</span></code>
 may even call <code class="inline"><span class="i">re_intuit_start</span><span class="s">(</span><span class="s">)</span></code>
 on its own. Nevertheless
other parts of the perl source code may call into either, or both.</p>
<p>Execution of the interpreter itself used to be recursive, but thanks to the
efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an
internal stack is maintained on the heap and the routine is fully
iterative. This can make it tricky as the code is quite conservative
about what state it stores, with the result that two consecutive lines in the
code can actually be running in totally different contexts due to the
simulated recursion.</p>
<a name="Start-position-and-no-match-optimisations"></a><h3>Start position and no-match optimisations</h3>
<p><code class="inline"><span class="i">re_intuit_start</span><span class="s">(</span><span class="s">)</span></code>
 is responsible for handling start points and no-match
optimisations as determined by the results of the analysis done by
<code class="inline"><span class="i">study_chunk</span><span class="s">(</span><span class="s">)</span></code>
 (and described in <a href="#Peep-hole-Optimisation-and-Analysis">Peep-hole Optimisation and Analysis</a>).</p>
<p>The basic structure of this routine is to try to find the start- and/or
end-points of where the pattern could match, and to ensure that the string
is long enough to match the pattern. It tries to use more efficient
methods over less efficient methods and may involve considerable
cross-checking of constraints to find the place in the string that matches.
For instance it may try to determine that a given fixed string must be
not only present but a certain number of chars before the end of the
string, or whatever.</p>
<p>It calls several other routines, such as <code class="inline"><span class="i">fbm_instr</span><span class="s">(</span><span class="s">)</span></code>
 which does
Fast Boyer Moore matching and <code class="inline"><span class="i">find_byclass</span><span class="s">(</span><span class="s">)</span></code>
 which is responsible for
finding the start using the first mandatory regop in the program.</p>
<p>When the optimisation criteria have been satisfied, <code class="inline"><span class="i">reg_try</span><span class="s">(</span><span class="s">)</span></code>
 is called
to perform the match.</p>
<a name="Program-execution"></a><h3>Program execution</h3>
<p><code class="inline"><span class="i">pregexec</span><span class="s">(</span><span class="s">)</span></code>
 is the main entry point for running a regex. It contains
support for initialising the regex interpreter's state, running
<code class="inline"><span class="i">re_intuit_start</span><span class="s">(</span><span class="s">)</span></code>
 if needed, and running the interpreter on the string
from various start positions as needed. When it is necessary to use
the regex interpreter <code class="inline"><span class="i">pregexec</span><span class="s">(</span><span class="s">)</span></code>
 calls <code class="inline"><span class="i">regtry</span><span class="s">(</span><span class="s">)</span></code>
.</p>
<p><code class="inline"><span class="i">regtry</span><span class="s">(</span><span class="s">)</span></code>
 is the entry point into the regex interpreter. It expects
as arguments a pointer to a <code class="inline"><span class="w">regmatch_info</span></code>
 structure and a pointer to
a string.  It returns an integer 1 for success and a 0 for failure.
It is basically a set-up wrapper around <code class="inline"><span class="i">regmatch</span><span class="s">(</span><span class="s">)</span></code>
.</p>
<p><code class="inline"><span class="w">regmatch</span></code>
 is the main "recursive loop" of the interpreter. It is
basically a giant switch statement that implements a state machine, where
the possible states are the regops themselves, plus a number of additional
intermediate and failure states. A few of the states are implemented as
subroutines but the bulk are inline code.</p>
<a name="MISCELLANEOUS"></a><h1>MISCELLANEOUS</h1>
<a name="Unicode-and-Localisation-Support"></a><h2>Unicode and Localisation Support</h2>
<p>When dealing with strings containing characters that cannot be represented
using an eight-bit character set, perl uses an internal representation
that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single
bytes to represent characters from the ASCII character set, and sequences
of two or more bytes for all other characters. (See <a href="perlunitut.html">perlunitut</a>
for more information about the relationship between UTF-8 and perl's
encoding, utf8. The difference isn't important for this discussion.)</p>
<p>No matter how you look at it, Unicode support is going to be a pain in a
regex engine. Tricks that might be fine when you have 256 possible
characters often won't scale to handle the size of the UTF-8 character
set.  Things you can take for granted with ASCII may not be true with
Unicode. For instance, in ASCII, it is safe to assume that
<code class="inline"><span class="i">sizeof</span><span class="s">(</span><span class="w">char1</span><span class="s">)</span> == <span class="i">sizeof</span><span class="s">(</span><span class="w">char2</span><span class="s">)</span></code>
, but in UTF-8 it isn't. Unicode case folding is
vastly more complex than the simple rules of ASCII, and even when not
using Unicode but only localised single byte encodings, things can get
tricky (for example, <b>LATIN SMALL LETTER SHARP S</b> (U+00DF, &#xdf;)
should match 'SS' in localised case-insensitive matching).</p>
<p>Making things worse is that UTF-8 support was a later addition to the
regex engine (as it was to perl) and this necessarily  made things a lot
more complicated. Obviously it is easier to design a regex engine with
Unicode support in mind from the beginning than it is to retrofit it to
one that wasn't.</p>
<p>Nearly all regops that involve looking at the input string have
two cases, one for UTF-8, and one not. In fact, it's often more complex
than that, as the pattern may be UTF-8 as well.</p>
<p>Care must be taken when making changes to make sure that you handle
UTF-8 properly, both at compile time and at execution time, including
when the string and pattern are mismatched.</p>
<a name="Base-Structures"></a><h2>Base Structures</h2>
<p>The <code class="inline"><span class="w">regexp</span></code>
 structure described in <a href="perlreapi.html">perlreapi</a> is common to all
regex engines. Two of its fields are intended for the private use
of the regex engine that compiled the pattern. These are the
<code class="inline"><span class="w">intflags</span></code>
 and pprivate members. The <code class="inline"><span class="w">pprivate</span></code>
 is a void pointer to
an arbitrary structure whose use and management is the responsibility
of the compiling engine. perl will never modify either of these
values. In the case of the stock engine the structure pointed to by
<code class="inline"><span class="w">pprivate</span></code>
 is called <code class="inline"><span class="w">regexp_internal</span></code>
.</p>
<p>Its <code class="inline"><span class="w">pprivate</span></code>
 and <code class="inline"><span class="w">intflags</span></code>
 fields contain data
specific to each engine.</p>
<p>There are two structures used to store a compiled regular expression.
One, the <code class="inline"><span class="w">regexp</span></code>
 structure described in <a href="perlreapi.html">perlreapi</a> is populated by
the engine currently being. used and some of its fields read by perl to
implement things such as the stringification of <code class="inline"><a class="l_k" href="functions/qr.html">qr//</a></code>.</p>
<p>The other structure is pointed to by the <code class="inline"><span class="w">regexp</span></code>
 struct's
<code class="inline"><span class="w">pprivate</span></code>
 and is in addition to <code class="inline"><span class="w">intflags</span></code>
 in the same struct
considered to be the property of the regex engine which compiled the
regular expression;</p>
<p>The regexp structure contains all the data that perl needs to be aware of
to properly work with the regular expression. It includes data about
optimisations that perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts such as is the pattern anchored in
some way, or what flags were used during the compile, or whether the
program contains special constructs that perl needs to be aware of.</p>
<p>In addition it contains two fields that are intended for the private use
of the regex engine that compiled the pattern. These are the <code class="inline"><span class="w">intflags</span></code>

and pprivate members. The <code class="inline"><span class="w">pprivate</span></code>
 is a void pointer to an arbitrary
structure whose use and management is the responsibility of the compiling
engine. perl will never modify either of these values.</p>
<p>As mentioned earlier, in the case of the default engines, the <code class="inline"><span class="w">pprivate</span></code>

will be a pointer to a regexp_internal structure which holds the compiled
program and any additional data that is private to the regex engine
implementation.</p>
<a name="Perl's-pprivate-structure"></a><h3>Perl's <code class="inline"><span class="w">pprivate</span></code>
 structure</h3>
<p>The following structure is used as the <code class="inline"><span class="w">pprivate</span></code>
 struct by perl's
regex engine. Since it is specific to perl it is only of curiosity
value to other engine implementations.</p>
<pre class="verbatim"><ol><li> <span class="w">typedef</span> <span class="w">struct</span> <span class="i">regexp_internal</span> <span class="s">{</span></li><li>         <span class="w">U32</span> *<span class="w">offsets</span><span class="sc">;</span>           <span class="q">/* offset annotations 20001228 MJD</span></li><li>                                  <span class="q">                                  * data about mapping the program to</span></li><li>                                  <span class="q">                                  * the string*/</span></li><li>         <span class="w">regnode</span> *<span class="w">regstclass</span><span class="sc">;</span>    <span class="q">/* Optional startclass as identified or</span></li><li>                                  <span class="q">                                  * constructed by the optimiser */</span></li><li>         <span class="w">struct</span> <span class="w">reg_data</span> *<span class="w">data</span><span class="sc">;</span>  <span class="q">/* Additional miscellaneous data used</span></li><li>                                  <span class="q">                                  * by the program.  Used to make it</span></li><li>                                  <span class="q">                                  * easier to clone and free arbitrary</span></li><li>                                  <span class="q">                                  * data that the regops need. Often the</span></li><li>                                  <span class="q">                                  * ARG field of a regop is an index</span></li><li>                                  <span class="q">                                  * into this structure */</span></li><li>         <span class="w">regnode</span> <span class="w">program</span><span class="s">[</span><span class="n">1</span><span class="s">]</span><span class="sc">;</span>     <span class="q">/* Unwarranted chumminess with</span></li><li>                                  <span class="q">                                  * compiler. */</span></li><li> <span class="s">}</span> <span class="w">regexp_internal</span><span class="sc">;</span></li></ol></pre><ul>
<li><a name="offsets"></a><b><code class="inline"><span class="w">offsets</span></code>
</b>
<p>Offsets holds a mapping of offset in the <code class="inline"><span class="w">program</span></code>

to offset in the <code class="inline"><span class="w">precomp</span></code>
 string. This is only used by ActiveState's
visual regex debugger.</p>
</li>
<li><a name="regstclass"></a><b><code class="inline"><span class="w">regstclass</span></code>
</b>
<p>Special regop that is used by <code class="inline"><span class="i">re_intuit_start</span><span class="s">(</span><span class="s">)</span></code>
 to check if a pattern
can match at a certain position. For instance if the regex engine knows
that the pattern must start with a 'Z' then it can scan the string until
it finds one and then launch the regex engine from there. The routine
that handles this is called <code class="inline"><span class="i">find_by_class</span><span class="s">(</span><span class="s">)</span></code>
. Sometimes this field
points at a regop embedded in the program, and sometimes it points at
an independent synthetic regop that has been constructed by the optimiser.</p>
</li>
<li><a name="data"></a><b><code class="inline"><span class="w">data</span></code>
</b>
<p>This field points at a <code class="inline"><span class="w">reg_data</span></code>
 structure, which is defined as follows</p>
<pre class="verbatim"><ol><li>    <span class="w">struct</span> <span class="i">reg_data</span> <span class="s">{</span></li><li>        <span class="w">U32</span> <span class="w">count</span><span class="sc">;</span></li><li>        <span class="w">U8</span> *<span class="w">what</span><span class="sc">;</span></li><li>        <span class="w">void</span>* <span class="w">data</span><span class="s">[</span><span class="n">1</span><span class="s">]</span><span class="sc">;</span></li><li>    <span class="s">}</span><span class="sc">;</span></li></ol></pre><p>This structure is used for handling data structures that the regex engine
needs to handle specially during a clone or free operation on the compiled
product. Each element in the data array has a corresponding element in the
what array. During compilation regops that need special structures stored
will add an element to each array using the add_data() routine and then store
the index in the regop.</p>
</li>
<li><a name="program"></a><b><code class="inline"><span class="w">program</span></code>
</b>
<p>Compiled program. Inlined into the structure so the entire struct can be
treated as a single blob.</p>
</li>
</ul>
<a name="SEE-ALSO"></a><h1>SEE ALSO</h1>
<p><a href="perlreapi.html">perlreapi</a></p>
<p><a href="perlre.html">perlre</a></p>
<p><a href="perlunitut.html">perlunitut</a></p>
<a name="AUTHOR"></a><h1>AUTHOR</h1>
<p>by Yves Orton, 2006.</p>
<p>With excerpts from Perl, and contributions and suggestions from
Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus,
Stephen McCamant, and David Landgren.</p>
<a name="LICENCE"></a><h1>LICENCE</h1>
<p>Same terms as Perl.</p>
<a name="REFERENCES"></a><h1>REFERENCES</h1>
<p>[1] <a href="http://perl.plover.com/Rx/paper/">http://perl.plover.com/Rx/paper/</a></p>
<p>[2] <a href="http://www.unicode.org">http://www.unicode.org</a></p>




  <div id="page_index" class="hud_container">
    <div id="page_index_header" class="hud_header">
      <div id="page_index_close" class="hud_close"><a href="#" onClick="pageIndex.hide();return false;"></a></div>
      <div id="page_index_title" class="hud_title"><span class="hud_span_top">Page index</span></div>
      <div id="page_index_topright" class="hud_topright"></div>
    </div>
    <div id="page_index_content" class="hud_content">
      <ul><li><a href="#NAME">NAME</a><li><a href="#DESCRIPTION">DESCRIPTION</a><li><a href="#OVERVIEW">OVERVIEW</a><ul><li><a href="#A-quick-note-on-terms">A quick note on terms</a><li><a href="#What-is-a-regular-expression-engine%3f">What is a regular expression engine?</a><li><a href="#Structure-of-a-Regexp-Program">Structure of a Regexp Program</a></ul><li><a href="#Process-Overview">Process Overview</a><ul><li><a href="#Compilation">Compilation</a><li><a href="#Execution">Execution</a></ul><li><a href="#MISCELLANEOUS">MISCELLANEOUS</a><ul><li><a href="#Unicode-and-Localisation-Support">Unicode and Localisation Support</a><li><a href="#Base-Structures">Base Structures</a></ul><li><a href="#SEE-ALSO">SEE ALSO</a><li><a href="#AUTHOR">AUTHOR</a><li><a href="#LICENCE">LICENCE</a><li><a href="#REFERENCES">REFERENCES</a></ul>
    </div>
    <div id="page_index_footer" class="hud_footer">
      <div id="page_index_bottomleft" class="hud_bottomleft"></div>
      <div id="page_index_bottom" class="hud_bottom"><span class="hud_span_bottom"></span></div>
      <div id="page_index_resize" class="hud_resize"></div>
    </div>
  </div>


	    &nbsp;
          </div>
          <div id="content_footer">
          </div>
        </div>
        <div class="clear"></div>
      </div>
      
    <div id="footer">
      <div id="footer_content">
        <div id="footer_strapline">
          perldoc.perl.org - Official documentation for the Perl programming language
        </div>
        <div id="footer_links">
          <div id="address">
            <p class="name">Contact details</p>
            <p class="address">
	      Site maintained by <a href="mailto:jj@jonallen.info">Jon Allen (JJ)</a><br>
	    </p>
            <p class="contact">
              Documentation maintained by the <a href="http://lists.cpan.org/showlist.cgi?name=perl5-porters">Perl 5 Porters</a>
            </p>
          </div>
          <ul class="f1">
            <li>Manual
              <ul class="f2">
                <li><a href="index-overview.html">Overview</a>
                <li><a href="index-tutorials.html">Tutorials</a>
                <li><a href="index-faq.html">FAQs</a>
                <li><a href="index-history.html">Changes</a>
              </ul>
            <li>Reference
              <ul class="f2">
                <li><a href="index-language.html">Language</a>
                <li><a href="index-functions.html">Functions</a>
                <li><a href="perlop.html">Operators</a>
                <li><a href="perlvar.html">Variables</a>
              </ul>
            <li>Modules
              <ul class="f2">
                <li><a href="index-modules-A.html">Modules</a>
                <li><a href="index-pragmas.html">Pragmas</a>
                <li><a href="index-utilities.html">Utilities</a>
              </ul>
            <li>Misc
              <ul class="f2">
                <li><a href="index-licence.html">License</a>
                <li><a href="index-internals.html">Internals</a>
                <li><a href="index-platforms.html">Platforms</a>
              </ul>          </ul>
          <div class="clear"></div>
        </div>
      </div>
      <div id="footer_end">
      </div>
    </div>
      
    </div>
      <script language="JavaScript" type="text/javascript" src="static/exploreperl.js"></script>
      <script language="JavaScript" src="static/combined-20100403.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
  perldoc.setPath(0);
  perldoc.pageName    = 'perlreguts';
  perldoc.pageAddress = 'perlreguts.html';
  perldoc.contentPage = 1;
  explorePerl.render();
  explorePerl.addEvents('explore_anchor');
</script>
    
  </body>
</html>
