<html><head>
    <meta charset="utf-8">
    
    <title>Indexing</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css">
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.10.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="author" title="About these documents" href="../about.html">
    <link rel="top" title="NumPy v1.10 Manual" href="../index.html">
    <link rel="up" title="Array objects" href="arrays.html">
    <link rel="next" title="Iterating Over Arrays" href="arrays.nditer.html">
    <link rel="prev" title="numpy.dtype.__setstate__" href="generated/numpy.dtype.__setstate__.html"> 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        
        <li class="active"><a href="../index.html">NumPy v1.10 Manual</a></li>
        

          <li class="active"><a href="index.html">NumPy Reference</a></li>
          <li class="active"><a href="arrays.html" accesskey="U">Array objects</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index" accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="arrays.nditer.html" title="Iterating Over Arrays" accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="generated/numpy.dtype.__setstate__.html" title="numpy.dtype.__setstate__" accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Indexing</a><ul>
<li><a class="reference internal" href="#basic-slicing-and-indexing">Basic Slicing and Indexing</a></li>
<li><a class="reference internal" href="#advanced-indexing">Advanced Indexing</a><ul>
<li><a class="reference internal" href="#integer-array-indexing">Integer array indexing</a><ul>
<li><a class="reference internal" href="#purely-integer-array-indexing">Purely integer array indexing</a></li>
<li><a class="reference internal" href="#combining-advanced-and-basic-indexing">Combining advanced and basic indexing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-array-indexing">Boolean array indexing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-notes">Detailed notes</a></li>
<li><a class="reference internal" href="#field-access">Field Access</a></li>
<li><a class="reference internal" href="#flat-iterator-indexing">Flat Iterator indexing</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="generated/numpy.dtype.__setstate__.html" title="previous chapter">numpy.dtype.__setstate__</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="arrays.nditer.html" title="next chapter">Iterating Over Arrays</a></p>


        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="indexing">
<span id="arrays-indexing"></span><h1>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h1>
<p id="index-0"><a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarrays</span></tt></a> can be indexed using the standard Python
<tt class="docutils literal"><span class="pre">x[obj]</span></tt> syntax, where <em>x</em> is the array and <em>obj</em> the selection.
There are three kinds of indexing available: field access, basic
slicing, advanced indexing. Which one occurs depends on <em>obj</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Python, <tt class="docutils literal"><span class="pre">x[(exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN)]</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">x[exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN]</span></tt>; the latter is just syntactic sugar
for the former.</p>
</div>
<div class="section" id="basic-slicing-and-indexing">
<h2>Basic Slicing and Indexing<a class="headerlink" href="#basic-slicing-and-indexing" title="Permalink to this headline">¶</a></h2>
<p>Basic slicing extends Python’s basic concept of slicing to N
dimensions. Basic slicing occurs when <em>obj</em> is a <a class="reference external" href="http://docs.python.org/dev/library/functions.html#slice" title="(in Python v3.6)"><tt class="xref py py-class docutils literal"><span class="pre">slice</span></tt></a> object
(constructed by <tt class="docutils literal"><span class="pre">start:stop:step</span></tt> notation inside of brackets), an
integer, or a tuple of slice objects and integers. <tt class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></tt>
and <a class="reference internal" href="#numpy.newaxis" title="numpy.newaxis"><tt class="xref py py-const docutils literal"><span class="pre">newaxis</span></tt></a> objects can be interspersed with these as
well. In order to remain backward compatible with a common usage in
Numeric, basic slicing is also initiated if the selection object is
any non-ndarray sequence (such as a <a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#list" title="(in Python v3.6)"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>) containing <a class="reference external" href="http://docs.python.org/dev/library/functions.html#slice" title="(in Python v3.6)"><tt class="xref py py-class docutils literal"><span class="pre">slice</span></tt></a>
objects, the <tt class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></tt> object, or the <a class="reference internal" href="#numpy.newaxis" title="numpy.newaxis"><tt class="xref py py-const docutils literal"><span class="pre">newaxis</span></tt></a> object,
but not for integer arrays or other embedded sequences.</p>
<p id="index-1">The simplest case of indexing with <em>N</em> integers returns an <a class="reference internal" href="arrays.scalars.html#arrays-scalars"><em>array
scalar</em></a> representing the corresponding item.  As in
Python, all indices are zero-based: for the <em>i</em>-th index <img class="math" src="../_images/math/8002a14dfa8d5544df2a972c6fa862705464d4fc.png" alt="n_i" style="vertical-align: -2px">,
the valid range is <img class="math" src="../_images/math/ce29481448dcc47ec904767e71d98c82619f3d6a.png" alt="0 \le n_i &lt; d_i" style="vertical-align: -2px"> where <img class="math" src="../_images/math/ae410da349d05c4fb338df88cd9a205e562e4701.png" alt="d_i" style="vertical-align: -2px"> is the
<em>i</em>-th element of the shape of the array.  Negative indices are
interpreted as counting from the end of the array (<em>i.e.</em>, if
<img class="math" src="../_images/math/5d7ec70ed2ef7b9456b4b7a73686f2369fbb7071.png" alt="n_i &lt; 0" style="vertical-align: -2px">, it means <img class="math" src="../_images/math/f7d9c302059f023f0dc8854bad19bb6b791b4326.png" alt="n_i + d_i" style="vertical-align: -2px">).</p>
<p>All arrays generated by basic slicing are always <a class="reference internal" href="../glossary.html#term-view"><em class="xref std std-term">views</em></a>
of the original array.</p>
<p>The standard rules of sequence slicing apply to basic slicing on a
per-dimension basis (including using a step index). Some useful
concepts to remember include:</p>
<ul>
<li><p class="first">The basic slice syntax is <tt class="docutils literal"><span class="pre">i:j:k</span></tt> where <em>i</em> is the starting index,
<em>j</em> is the stopping index, and <em>k</em> is the step (<img class="math" src="../_images/math/cbd5bf4758bd9b43dfef3dcbf87587b12f87c9df.png" alt="k\neq0" style="vertical-align: -4px">).
This selects the <em>m</em> elements (in the corresponding dimension) with
index values <em>i</em>, <em>i + k</em>, ..., <em>i + (m - 1) k</em> where
<img class="math" src="../_images/math/bb1f6d132d0ad4542e8b3151bcb56de2246f1291.png" alt="m = q + (r\neq0)" style="vertical-align: -4px"> and <em>q</em> and <em>r</em> are the quotient and remainder
obtained by dividing <em>j - i</em> by <em>k</em>: <em>j - i = q k + r</em>, so that
<em>i + (m - 1) k &lt; j</em>.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([1, 3, 5])</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">Negative <em>i</em> and <em>j</em> are interpreted as <em>n + i</em> and <em>n + j</em> where
<em>n</em> is the number of elements in the corresponding dimension.
Negative <em>k</em> makes stepping go towards smaller indices.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">array([8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([7, 6, 5, 4])</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">Assume <em>n</em> is the number of elements in the dimension being
sliced. Then, if <em>i</em> is not given it defaults to 0 for <em>k &gt; 0</em> and
<em>n - 1</em> for <em>k &lt; 0</em> . If <em>j</em> is not given it defaults to <em>n</em> for <em>k &gt; 0</em>
and -1 for <em>k &lt; 0</em> . If <em>k</em> is not given it defaults to 1. Note that
<tt class="docutils literal"><span class="pre">::</span></tt> is the same as <tt class="docutils literal"><span class="pre">:</span></tt> and means select all indices along this
axis.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
<span class="go">array([5, 6, 7, 8, 9])</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">If the number of objects in the selection tuple is less than
<em>N</em> , then <tt class="docutils literal"><span class="pre">:</span></tt> is assumed for any subsequent dimensions.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([[[4],</span>
<span class="go">        [5],</span>
<span class="go">        [6]]])</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first"><tt class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></tt> expand to the number of <tt class="docutils literal"><span class="pre">:</span></tt> objects needed to
make a selection tuple of the same length as <tt class="docutils literal"><span class="pre">x.ndim</span></tt>. There may
only be a single ellipsis present.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">Each <a class="reference internal" href="#numpy.newaxis" title="numpy.newaxis"><tt class="xref py py-const docutils literal"><span class="pre">newaxis</span></tt></a> object in the selection tuple serves to expand
the dimensions of the resulting selection by one unit-length
dimension.  The added dimension is the position of the <a class="reference internal" href="#numpy.newaxis" title="numpy.newaxis"><tt class="xref py py-const docutils literal"><span class="pre">newaxis</span></tt></a>
object in the selection tuple.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3, 1)</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">An integer, <em>i</em>, returns the same values as <tt class="docutils literal"><span class="pre">i:i+1</span></tt>
<strong>except</strong> the dimensionality of the returned object is reduced by
1. In particular, a selection tuple with the <em>p</em>-th
element an integer (and all other entries <tt class="docutils literal"><span class="pre">:</span></tt>) returns the
corresponding sub-array with dimension <em>N - 1</em>. If <em>N = 1</em>
then the returned object is an array scalar. These objects are
explained in <a class="reference internal" href="arrays.scalars.html#arrays-scalars"><em>Scalars</em></a>.</p>
</li>
<li><p class="first">If the selection tuple has all entries <tt class="docutils literal"><span class="pre">:</span></tt> except the
<em>p</em>-th entry which is a slice object <tt class="docutils literal"><span class="pre">i:j:k</span></tt>,
then the returned array has dimension <em>N</em> formed by
concatenating the sub-arrays returned by integer indexing of
elements <em>i</em>, <em>i+k</em>, ..., <em>i + (m - 1) k &lt; j</em>,</p>
</li>
<li><p class="first">Basic slicing with more than one non-<tt class="docutils literal"><span class="pre">:</span></tt> entry in the slicing
tuple, acts like repeated application of slicing using a single
non-<tt class="docutils literal"><span class="pre">:</span></tt> entry, where the non-<tt class="docutils literal"><span class="pre">:</span></tt> entries are successively taken
(with all other non-<tt class="docutils literal"><span class="pre">:</span></tt> entries replaced by <tt class="docutils literal"><span class="pre">:</span></tt>). Thus,
<tt class="docutils literal"><span class="pre">x[ind1,...,ind2,:]</span></tt> acts like <tt class="docutils literal"><span class="pre">x[ind1][...,ind2,:]</span></tt> under basic
slicing.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The above is <strong>not</strong> true for advanced indexing.</p>
</div>
</li>
<li><p class="first">You may use slicing to set values in the array, but (unlike lists) you
can never grow the array. The size of the value to be set in
<tt class="docutils literal"><span class="pre">x[obj]</span> <span class="pre">=</span> <span class="pre">value</span></tt> must be (broadcastable) to the same shape as
<tt class="docutils literal"><span class="pre">x[obj]</span></tt>.</p>
</li>
</ul>
<div class="admonition note" id="index-2">
<p class="first admonition-title">Note</p>
<p class="last">Remember that a slicing tuple can always be constructed as <em>obj</em>
and used in the <tt class="docutils literal"><span class="pre">x[obj]</span></tt> notation. Slice objects can be used in
the construction in place of the <tt class="docutils literal"><span class="pre">[start:stop:step]</span></tt>
notation. For example, <tt class="docutils literal"><span class="pre">x[1:10:5,::-1]</span></tt> can also be implemented
as <tt class="docutils literal"><span class="pre">obj</span> <span class="pre">=</span> <span class="pre">(slice(1,10,5),</span> <span class="pre">slice(None,None,-1));</span> <span class="pre">x[obj]</span></tt> . This
can be useful for constructing generic code that works on arrays
of arbitrary dimension.</p>
</div>
<dl class="data">
<a class="dashAnchor" name="//apple_ref/Method/numpy.newaxis"></a><dt id="numpy.newaxis">
<tt class="descclassname">numpy.</tt><tt class="descname">newaxis</tt><a class="headerlink" href="#numpy.newaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#numpy.newaxis" title="numpy.newaxis"><tt class="xref py py-const docutils literal"><span class="pre">newaxis</span></tt></a> object can be used in all slicing operations to
create an axis of length one. :const: <a class="reference internal" href="#numpy.newaxis" title="numpy.newaxis"><tt class="xref py py-const docutils literal"><span class="pre">newaxis</span></tt></a> is an alias for
‘None’, and ‘None’ can be used in place of this with the same result.</p>
</dd></dl>

</div>
<div class="section" id="advanced-indexing">
<h2>Advanced Indexing<a class="headerlink" href="#advanced-indexing" title="Permalink to this headline">¶</a></h2>
<p>Advanced indexing is triggered when the selection object, <em>obj</em>, is a
non-tuple sequence object, an <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarray</span></tt></a> (of data type integer or bool),
or a tuple with at least one sequence object or ndarray (of data type
integer or bool). There are two types of advanced indexing: integer
and Boolean.</p>
<p>Advanced indexing always returns a <em>copy</em> of the data (contrast with
basic slicing that returns a <a class="reference internal" href="../glossary.html#term-view"><em class="xref std std-term">view</em></a>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The definition of advanced indexing means that <tt class="docutils literal"><span class="pre">x[(1,2,3),]</span></tt> is
fundamentally different than <tt class="docutils literal"><span class="pre">x[(1,2,3)]</span></tt>. The latter is
equivalent to <tt class="docutils literal"><span class="pre">x[1,2,3]</span></tt> which will trigger basic selection while
the former will trigger advanced indexing. Be sure to understand
why this is occurs.</p>
<p class="last">Also recognize that <tt class="docutils literal"><span class="pre">x[[1,2,3]]</span></tt> will trigger advanced indexing,
whereas <tt class="docutils literal"><span class="pre">x[[1,2,slice(None)]]</span></tt> will trigger basic slicing.</p>
</div>
<div class="section" id="integer-array-indexing">
<h3>Integer array indexing<a class="headerlink" href="#integer-array-indexing" title="Permalink to this headline">¶</a></h3>
<p>Integer array indexing allows selection of arbitrary items in the array
based on their <em>N</em>-dimensional index. Each integer array represents a number
of indexes into that dimension.</p>
<div class="section" id="purely-integer-array-indexing">
<h4>Purely integer array indexing<a class="headerlink" href="#purely-integer-array-indexing" title="Permalink to this headline">¶</a></h4>
<p>When the index consists of as many integer arrays as the array being indexed
has dimensions, the indexing is straight forward, but different from slicing.</p>
<p>Advanced indexes always are <a class="reference internal" href="ufuncs.html#ufuncs-broadcasting"><em>broadcast</em></a> and
iterated as <em>one</em>:</p>
<div class="highlight-python"><div class="highlight"><pre>result[i_1, ..., i_M] == x[ind_1[i_1, ..., i_M], ind_2[i_1, ..., i_M],
                           ..., ind_N[i_1, ..., i_M]]
</pre></div>
</div>
<p>Note that the result shape is identical to the (broadcast) indexing array
shapes <tt class="docutils literal"><span class="pre">ind_1,</span> <span class="pre">...,</span> <span class="pre">ind_N</span></tt>.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p>From each row, a specific element should be selected. The row index is just
<tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></tt> and the column index specifies the element to choose for the
corresponding row, here <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></tt>. Using both together the task
can be solved using advanced indexing:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="go">array([1, 4, 5])</span>
</pre></div>
</div>
</div>
<p>To achieve a behaviour similar to the basic slicing above, broadcasting can be
used. The function <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><tt class="xref py py-func docutils literal"><span class="pre">ix_</span></tt></a> can help with this broadcasting. This is best
understood with an example.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p>From a 4x3 array the corner elements should be selected using advanced
indexing. Thus all elements for which the column is one of <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">2]</span></tt> and
the row is one of <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">3]</span></tt> need to be selected. To use advanced indexing
one needs to select all elements <em>explicitly</em>. Using the method explained
previously one could write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>           <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>           <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>           <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p>However, since the indexing arrays above just repeat themselves,
broadcasting can be used (compare operations such as
<tt class="docutils literal"><span class="pre">rows[:,</span> <span class="pre">np.newaxis]</span> <span class="pre">+</span> <span class="pre">columns</span></tt>) to simplify this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="go">array([[0],</span>
<span class="go">       [3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p>This broadcasting can also be achieved using the function <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><tt class="xref py py-func docutils literal"><span class="pre">ix_</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">)]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p class="last">Note that without the <tt class="docutils literal"><span class="pre">np.ix_</span></tt> call, only the diagonal elements would
be selected, as was used in the previous example. This difference is the
most important thing to remember about indexing with multiple advanced
indexes.</p>
</div>
</div>
<div class="section" id="combining-advanced-and-basic-indexing">
<h4>Combining advanced and basic indexing<a class="headerlink" href="#combining-advanced-and-basic-indexing" title="Permalink to this headline">¶</a></h4>
<p>When there is at least one slice (<tt class="docutils literal"><span class="pre">:</span></tt>), ellipsis (<tt class="docutils literal"><span class="pre">...</span></tt>) or <tt class="docutils literal"><span class="pre">np.newaxis</span></tt>
in the index (or the array has more dimensions than there are advanced indexes),
then the behaviour can be more complicated. It is like concatenating the
indexing result for each advanced index element</p>
<p>In the simplest case, there is only a <em>single</em> advanced index. A single
advanced index can for example replace a slice and the result array will be
the same, however, it is a copy and may have a different memory layout.
A slice is preferable when it is possible.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="go">array([[4, 5]])</span>
</pre></div>
</div>
</div>
<p>The easiest way to understand the situation may be to think in
terms of the result shape. There are two parts to the indexing operation,
the subspace defined by the basic indexing (excluding integers) and the
subspace from the advanced indexing part. Two cases of index combination
need to be distinguished:</p>
<ul class="simple">
<li>The advanced indexes are separated by a slice, ellipsis or newaxis.
For example <tt class="docutils literal"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">arr2]</span></tt>.</li>
<li>The advanced indexes are all next to each other.
For example <tt class="docutils literal"><span class="pre">x[...,</span> <span class="pre">arr1,</span> <span class="pre">arr2,</span> <span class="pre">:]</span></tt> but <em>not</em> <tt class="docutils literal"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">1]</span></tt>
since <tt class="docutils literal"><span class="pre">1</span></tt> is an advanced index in this regard.</li>
</ul>
<p>In the first case, the dimensions resulting from the advanced indexing
operation come first in the result array, and the subspace dimensions after
that.
In the second case, the dimensions from the advanced indexing operations
are inserted into the result array at the same spot as they were in the
initial array (the latter logic is what makes simple advanced indexing
behave just like slicing).</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p class="last">Suppose <tt class="docutils literal"><span class="pre">x.shape</span></tt> is (10,20,30) and <tt class="docutils literal"><span class="pre">ind</span></tt> is a (2,3,4)-shaped
indexing <tt class="xref py py-class docutils literal"><span class="pre">intp</span></tt> array, then <tt class="docutils literal"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">x[...,ind,:]</span></tt> has
shape (10,2,3,4,30) because the (20,)-shaped subspace has been
replaced with a (2,3,4)-shaped broadcasted indexing subspace. If
we let <em>i, j, k</em> loop over the (2,3,4)-shaped subspace then
<tt class="docutils literal"><span class="pre">result[...,i,j,k,:]</span> <span class="pre">=</span> <span class="pre">x[...,ind[i,j,k],:]</span></tt>. This example
produces the same result as <a class="reference internal" href="generated/numpy.ndarray.take.html#numpy.ndarray.take" title="numpy.ndarray.take"><tt class="xref py py-meth docutils literal"><span class="pre">x.take(ind,</span> <span class="pre">axis=-2)</span></tt></a>.</p>
</div>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p class="last">Let <tt class="docutils literal"><span class="pre">x.shape</span></tt> be (10,20,30,40,50) and suppose <tt class="docutils literal"><span class="pre">ind_1</span></tt>
and <tt class="docutils literal"><span class="pre">ind_2</span></tt> can be broadcast to the shape (2,3,4).  Then
<tt class="docutils literal"><span class="pre">x[:,ind_1,ind_2]</span></tt> has shape (10,2,3,4,40,50) because the
(20,30)-shaped subspace from X has been replaced with the
(2,3,4) subspace from the indices.  However,
<tt class="docutils literal"><span class="pre">x[:,ind_1,:,ind_2]</span></tt> has shape (2,3,4,10,30,50) because there
is no unambiguous place to drop in the indexing subspace, thus
it is tacked-on to the beginning. It is always possible to use
<a class="reference internal" href="generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose" title="numpy.ndarray.transpose"><tt class="xref py py-meth docutils literal"><span class="pre">.transpose()</span></tt></a> to move the subspace
anywhere desired. Note that this example cannot be replicated
using <a class="reference internal" href="generated/numpy.take.html#numpy.take" title="numpy.take"><tt class="xref py py-func docutils literal"><span class="pre">take</span></tt></a>.</p>
</div>
</div>
</div>
<div class="section" id="boolean-array-indexing">
<h3>Boolean array indexing<a class="headerlink" href="#boolean-array-indexing" title="Permalink to this headline">¶</a></h3>
<p>This advanced indexing occurs when obj is an array object of Boolean
type, such as may be returned from comparison operators. A single
boolean index array is practically identical to <tt class="docutils literal"><span class="pre">x[obj.nonzero()]</span></tt> where,
as described above, <a class="reference internal" href="generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero" title="numpy.ndarray.nonzero"><tt class="xref py py-meth docutils literal"><span class="pre">obj.nonzero()</span></tt></a> returns a
tuple (of length <a class="reference internal" href="generated/numpy.ndarray.ndim.html#numpy.ndarray.ndim" title="numpy.ndarray.ndim"><tt class="xref py py-attr docutils literal"><span class="pre">obj.ndim</span></tt></a>) of integer index
arrays showing the <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt> elements of <em>obj</em>. However, it is
faster when <tt class="docutils literal"><span class="pre">obj.shape</span> <span class="pre">==</span> <span class="pre">x.shape</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">obj.ndim</span> <span class="pre">==</span> <span class="pre">x.ndim</span></tt>, <tt class="docutils literal"><span class="pre">x[obj]</span></tt> returns a 1-dimensional array
filled with the elements of <em>x</em> corresponding to the <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt>
values of <em>obj</em>.  The search order will be <a class="reference internal" href="../glossary.html#term-row-major"><em class="xref std std-term">row-major</em></a>,
C-style. If <em>obj</em> has <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt> values at entries that are outside
of the bounds of <em>x</em>, then an index error will be raised. If <em>obj</em> is
smaller than <em>x</em> it is identical to filling it with <tt class="xref py py-const docutils literal"><span class="pre">False</span></tt>.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p>A common use case for this is filtering for desired element values.
For example one may wish to select all entries from an array which
are not NaN:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<p>Or wish to add a constant to all negative elements:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([  1.,  19.,  18.,   3.])</span>
</pre></div>
</div>
</div>
<p>In general if an index includes a Boolean array, the result will be
identical to inserting <tt class="docutils literal"><span class="pre">obj.nonzero()</span></tt> into the same position
and using the integer array indexing mechanism described above.
<tt class="docutils literal"><span class="pre">x[ind_1,</span> <span class="pre">boolean_array,</span> <span class="pre">ind_2]</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">x[(ind_1,)</span> <span class="pre">+</span> <span class="pre">boolean_array.nonzero()</span> <span class="pre">+</span> <span class="pre">(ind_2,)]</span></tt>.</p>
<p>If there is only one Boolean array and no integer indexing array present,
this is straight forward. Care must only be taken to make sure that the
boolean index has <em>exactly</em> as many dimensions as it is supposed to work
with.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p>From an array, select all rows which sum up to less or equal two:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rowsum</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rowsum</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 1]])</span>
</pre></div>
</div>
<p>But if <tt class="docutils literal"><span class="pre">rowsum</span></tt> would have two dimensions as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rowsum</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rowsum</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rowsum</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>    <span class="c"># fails</span>
<span class="go">IndexError: too many indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rowsum</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">]</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
<p class="last">The last one giving only the first elements because of the extra dimension.
Compare <tt class="docutils literal"><span class="pre">rowsum.nonzero()</span></tt> to understand this example.</p>
</div>
<p>Combining multiple Boolean indexing arrays or a Boolean with an integer
indexing array can best be understood with the
<a class="reference internal" href="generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero" title="numpy.ndarray.nonzero"><tt class="xref py py-meth docutils literal"><span class="pre">obj.nonzero()</span></tt></a> analogy. The function <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><tt class="xref py py-func docutils literal"><span class="pre">ix_</span></tt></a>
also supports boolean arrays and will work without any surprises.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<p>Use boolean indexing to select all rows adding up to an even
number. At the same time columns 0 and 2 should be selected with an
advanced integer index. Using the <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><tt class="xref py py-func docutils literal"><span class="pre">ix_</span></tt></a> function this can be done
with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>           <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>           <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>           <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span>
<span class="go">array([False,  True, False,  True], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">)]</span>
<span class="go">array([[ 3,  5],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p>Without the <tt class="docutils literal"><span class="pre">np.ix_</span></tt> call or only the diagonal elements would be
selected.</p>
<p>Or without <tt class="docutils literal"><span class="pre">np.ix_</span></tt> (compare the integer array examples):</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 3,  5],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="detailed-notes">
<h2>Detailed notes<a class="headerlink" href="#detailed-notes" title="Permalink to this headline">¶</a></h2>
<p>These are some detailed notes, which are not of importance for day to day
indexing (in no particular order):</p>
<ul class="simple">
<li>The native NumPy indexing type is <tt class="docutils literal"><span class="pre">intp</span></tt> and may differ from the
default integer array type. <tt class="docutils literal"><span class="pre">intp</span></tt> is the smallest data type
sufficient to safely index any array; for advanced indexing it may be
faster than other types.</li>
<li>For advanced assignments, there is in general no guarantee for the
iteration order. This means that if an element is set more than once,
it is not possible to predict the final result.</li>
<li>An empty (tuple) index is a full scalar index into a zero dimensional array.
<tt class="docutils literal"><span class="pre">x[()]</span></tt> returns a <em>scalar</em> if <tt class="docutils literal"><span class="pre">x</span></tt> is zero dimensional and a view
otherwise. On the other hand <tt class="docutils literal"><span class="pre">x[...]</span></tt> always returns a view.</li>
<li>If a zero dimensional array is present in the index <em>and</em> it is a full
integer index the result will be a <em>scalar</em> and not a zero dimensional array.
(Advanced indexing is not triggered.)</li>
<li>When an ellipsis (<tt class="docutils literal"><span class="pre">...</span></tt>) is present but has no size (i.e. replaces zero
<tt class="docutils literal"><span class="pre">:</span></tt>) the result will still always be an array. A view if no advanced index
is present, otherwise a copy.</li>
<li>the <tt class="docutils literal"><span class="pre">nonzero</span></tt> equivalence for Boolean arrays does not hold for zero
dimensional boolean arrays.</li>
<li>When the result of an advanced indexing operation has no elements but an
individual index is out of bounds, whether or not an <tt class="docutils literal"><span class="pre">IndexError</span></tt> is
raised is undefined (e.g. <tt class="docutils literal"><span class="pre">x[[],</span> <span class="pre">[123]]</span></tt> with <tt class="docutils literal"><span class="pre">123</span></tt> being out of bounds).</li>
<li>When a <em>casting</em> error occurs during assignment (for example updating a
numerical array using a sequence of strings), the array being assigned
to may end up in an unpredictable partially updated state.
However, if any other error (such as an out of bounds index) occurs, the
array will remain unchanged.</li>
<li>The memory layout of an advanced indexing result is optimized for each
indexing operation and no particular memory order can be assumed.</li>
<li>When using a subclass (especially one which manipulates its shape), the
default <tt class="docutils literal"><span class="pre">ndarray.__setitem__</span></tt> behaviour will call <tt class="docutils literal"><span class="pre">__getitem__</span></tt> for
<em>basic</em> indexing but not for <em>advanced</em> indexing. For such a subclass it may
be preferable to call <tt class="docutils literal"><span class="pre">ndarray.__setitem__</span></tt> with a <em>base class</em> ndarray
view on the data. This <em>must</em> be done if the subclasses <tt class="docutils literal"><span class="pre">__getitem__</span></tt> does
not return views.</li>
</ul>
</div>
<div class="section" id="field-access">
<span id="arrays-indexing-fields"></span><h2>Field Access<a class="headerlink" href="#field-access" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="arrays.dtypes.html#arrays-dtypes"><em>Data type objects (dtype)</em></a>, <a class="reference internal" href="arrays.scalars.html#arrays-scalars"><em>Scalars</em></a></p>
</div>
<p>If the <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><tt class="xref py py-class docutils literal"><span class="pre">ndarray</span></tt></a> object is a structured array the <em class="xref std std-term">fields</em>
of the array can be accessed by indexing the array with strings,
dictionary-like.</p>
<p>Indexing <tt class="docutils literal"><span class="pre">x['field-name']</span></tt> returns a new <a class="reference internal" href="../glossary.html#term-view"><em class="xref std std-term">view</em></a> to the array,
which is of the same shape as <em>x</em> (except when the field is a
sub-array) but of data type <tt class="docutils literal"><span class="pre">x.dtype['field-name']</span></tt> and contains
only the part of the data in the specified field. Also
<a class="reference internal" href="arrays.classes.html#arrays-classes-rec"><em>record array</em></a> scalars can be “indexed” this way.</p>
<p>Indexing into a structured array can also be done with a list of field names,
<em>e.g.</em> <tt class="docutils literal"><span class="pre">x[['field-name1','field-name2']]</span></tt>. Currently this returns a new
array containing a copy of the values in the fields specified in the list.
As of NumPy 1.7, returning a copy is being deprecated in favor of returning
a view. A copy will continue to be returned for now, but a FutureWarning
will be issued when writing to the copy. If you depend on the current
behavior, then we suggest copying the returned array explicitly, i.e. use
x[[‘field-name1’,’field-name2’]].copy(). This will work with both past and
future versions of NumPy.</p>
<p>If the accessed field is a sub-array, the dimensions of the sub-array
are appended to the shape of the result.</p>
<div class="admonition-example admonition">
<p class="first admonition-title">Example</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s">'a'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="p">(</span><span class="s">'b'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype('int32')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s">'b'</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s">'b'</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype('float64')</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="flat-iterator-indexing">
<h2>Flat Iterator indexing<a class="headerlink" href="#flat-iterator-indexing" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/numpy.ndarray.flat.html#numpy.ndarray.flat" title="numpy.ndarray.flat"><tt class="xref py py-attr docutils literal"><span class="pre">x.flat</span></tt></a> returns an iterator that will iterate
over the entire array (in C-contiguous style with the last index
varying the fastest). This iterator object can also be indexed using
basic slicing or advanced indexing as long as the selection object is
not a tuple. This should be clear from the fact that <a class="reference internal" href="generated/numpy.ndarray.flat.html#numpy.ndarray.flat" title="numpy.ndarray.flat"><tt class="xref py py-attr docutils literal"><span class="pre">x.flat</span></tt></a> is a 1-dimensional view. It can be used for integer
indexing with 1-dimensional C-style-flat indices. The shape of any
returned array is therefore the shape of the integer indexing object.</p>
<span class="target" id="index-3"></span></div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        © Copyright 2008-2009, The Scipy community.
      </li>
      <li>
      Last updated on Oct 18, 2015.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  
</body></html>