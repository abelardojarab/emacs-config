<html><!-- Mirrored from stat.ethz.ch/R-manual/R-patched/library/mgcv/html/smooth.construct.bs.smooth.spec.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 04 May 2016 16:38:00 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><!-- /Added by HTTrack -->
<title>Penalized B-splines in GAMs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for smooth.construct.bs.smooth.spec {mgcv}"><tbody><tr><td>smooth.construct.bs.smooth.spec {mgcv}</td><td style="text-align: right;">R Documentation</td></tr></tbody></table>

<h2>Penalized B-splines in GAMs</h2>

<h3>Description</h3>

<p><code><a href="gam.html">gam</a></code> can use smoothing splines based on univariate B-spline bases
with derivative based penalties, specified via terms like <code>s(x,bs="bs",m=c(3,2))</code>. <code>m[1]</code> controls the spline order, with <code>m[1]=3</code> being a cubic spline, <code>m[1]=2</code> being quadratic, and so on. The integrated square of the <code>m[2]</code>th derivative is used as the penalty. So <code>m=c(3,2)</code> is a convetional cubic spline. If <code>m</code> is supplied as a single number, then it is taken to be <code>m[1]</code> and <code>m[2]=m[1]-1</code>, which is only a conventional smoothing spline in the <code>m=3</code>, cubic spline case. Notice that the definition of the spline order in terms of <code>m[1]</code> is intuitive, but differs to that used with the <code><a href="smooth.construct.tp.smooth.spec.html">tprs</a></code> and <code><a href="smooth.construct.ps.smooth.spec.html">p.spline</a></code> bases. 
</p>


<h3>Usage</h3>

<pre>## S3 method for class 'bs.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'Bspline.smooth'
Predict.matrix(object, data)
</pre>


<h3>Arguments</h3>

 
<table summary="R argblock">
<tbody><tr valign="top"><td><code>object</code></td>
<td>
<p>a smooth specification object, usually generated by a term <code>s(x,bs="bs",...)</code></p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p>a list containing just the data (including any <code>by</code> variable) required by this term, 
with names corresponding to <code>object$term</code> (and <code>object$by</code>). The <code>by</code> variable 
is the last element.</p>
</td></tr> 
<tr valign="top"><td><code>knots</code></td>
<td>
<p>a list containing any knots supplied for basis setup â€” in same order and with same names as <code>data</code>. 
Can be <code>NULL</code>. See details for further information.</p>
</td></tr>
</tbody></table>


<h3>Details</h3>

<p> The basis and penalty are sparse (although sparse matrices are not used to represent them). <code>m[2]&gt;m[1]</code> will generate an error, since in that case the penalty would be based on an undefined derivative of the basis, which makes no sense.
</p>
<p>The default basis dimension, <code>k</code>, is the larger of 10 and <code>m</code>. <code>m[1]</code> is the lower limit on basis dimension. If knots are supplied, then  the number of supplied knots should be <code>k + m[1] + 1</code>, and the range of the middle <code>k-m[1]+1</code> knots should include all the covariate values. Alternatively, 2 knots can be supplied, denoting the 
lower and upper limits between which the spline can be evaluated (Don't make this range too wide, however, or you 
can end up with no information about some basis coefficients, because the corresponding basis functions have a 
span that includes no data!). Unlike P-splines, splines with derivative based penalties can have uneven knot spacing, without a problem. 
</p>
<p>Linear extrapolation is used for prediction that requires extrapolation 
(i.e. prediction outside the range of the interior <code>k-m[1]+1</code> knots). Such extrapolation is not
allowed in basis construction, but is when predicting.
</p>
<p>It is possible to set a <code>deriv</code> flag in a smooth specification or smooth object, so that a model or prediction matrix produces the requested derivative of the spline, rather than evaluating it. 
</p>


<h3>Value</h3>

<p> An object of class <code>"Bspline.smooth"</code>. See <code><a href="smooth.construct.html">smooth.construct</a></code>, 
for the elements that this object will contain.
</p>


<h3>WARNING</h3>

<p><code>m</code> directly controls the spline order here, which is intuitively sensible, but different to other bases.</p>


<h3>Author(s)</h3>

<p> Simon N. Wood simon.wood@r-project.org</p>


<h3>See Also</h3>

<p><code><a href="smooth.construct.ps.smooth.spec.html">p.spline</a></code></p>


<h3>Examples</h3>

<pre>  require(mgcv)
  set.seed(5)
  dat &lt;- gamSim(1,n=400,dist="normal",scale=2)
  bs &lt;- "bs"
  b &lt;- gam(y~s(x0,bs=bs,m=c(4,2))+s(x1,bs=bs)+s(x2,k=15,bs=bs,m=c(4,3))+
           s(x3,bs=bs,m=c(1,0)),data=dat,method="REML")
  plot(b,pages=1)

  ## construct smooth of x. Model matrix sm$X and penalty 
  ## matrix sm$S[[1]] will have many zero entries...
  x &lt;- seq(0,1,length=100)
  sm &lt;- smoothCon(s(x,bs="bs"),data.frame(x))[[1]]

  ## another example checking penalty numerically...
  m &lt;- c(4,2); k &lt;- 15; b &lt;- runif(k)
  sm &lt;- smoothCon(s(x,bs="bs",m=m,k=k),data.frame(x),scale.penalty=FALSE)[[1]]
  sm$deriv &lt;- m[2]
  h0 &lt;- 1e-3; xk &lt;- sm$knots[(m[1]+1):(k+1)]
  Xp &lt;- PredictMat(sm,data.frame(x=seq(xk[1]+h0/2,max(xk)-h0/2,h0)))
  sum((Xp%*%b)^2*h0) ## numerical approximation to penalty
  b%*%sm$S[[1]]%*%b  ## `exact' version
  
</pre>

<hr><div style="text-align: center;">[Package <em>mgcv</em> version 1.8-12 <a href="00Index.html">Index</a>]</div>

<!-- Mirrored from stat.ethz.ch/R-manual/R-patched/library/mgcv/html/smooth.construct.bs.smooth.spec.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 04 May 2016 16:38:00 GMT -->

</body></html>