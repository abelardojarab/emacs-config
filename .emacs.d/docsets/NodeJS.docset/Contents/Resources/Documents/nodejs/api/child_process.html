<html><head>
  <meta charset="utf-8">
  <title>Child Process</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic">
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="https://nodejs.org/api/child_process.html">
</head>
<body class="alt apidoc" id="api-section-child_process">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
          Node.js (1)
        </a>
      </div>
      <ul>
<li><a class="nav-documentation" href="documentation.html">About these Docs</a></li>
<li><a class="nav-synopsis" href="synopsis.html">Synopsis</a></li>
<li><a class="nav-assert" href="assert.html">Assertion Testing</a></li>
<li><a class="nav-buffer" href="buffer.html">Buffer</a></li>
<li><a class="nav-addons" href="addons.html">C/C++ Addons</a></li>
<li><a class="nav-child_process active" href="child_process.html">Child Processes</a></li>
<li><a class="nav-cluster" href="cluster.html">Cluster</a></li>
<li><a class="nav-console" href="console.html">Console</a></li>
<li><a class="nav-crypto" href="crypto.html">Crypto</a></li>
<li><a class="nav-debugger" href="debugger.html">Debugger</a></li>
<li><a class="nav-dns" href="dns.html">DNS</a></li>
<li><a class="nav-domain" href="domain.html">Domain</a></li>
<li><a class="nav-errors" href="errors.html">Errors</a></li>
<li><a class="nav-events" href="events.html">Events</a></li>
<li><a class="nav-fs" href="fs.html">File System</a></li>
<li><a class="nav-globals" href="globals.html">Globals</a></li>
<li><a class="nav-http" href="http.html">HTTP</a></li>
<li><a class="nav-https" href="https.html">HTTPS</a></li>
<li><a class="nav-modules" href="modules.html">Modules</a></li>
<li><a class="nav-net" href="net.html">Net</a></li>
<li><a class="nav-os" href="os.html">OS</a></li>
<li><a class="nav-path" href="path.html">Path</a></li>
<li><a class="nav-process" href="process.html">Process</a></li>
<li><a class="nav-punycode" href="punycode.html">Punycode</a></li>
<li><a class="nav-querystring" href="querystring.html">Query Strings</a></li>
<li><a class="nav-readline" href="readline.html">Readline</a></li>
<li><a class="nav-repl" href="repl.html">REPL</a></li>
<li><a class="nav-stream" href="stream.html">Stream</a></li>
<li><a class="nav-string_decoder" href="string_decoder.html">String Decoder</a></li>
<li><a class="nav-timers" href="timers.html">Timers</a></li>
<li><a class="nav-tls" href="tls.html">TLS/SSL</a></li>
<li><a class="nav-tty" href="tty.html">TTY</a></li>
<li><a class="nav-dgram" href="dgram.html">UDP/Datagram</a></li>
<li><a class="nav-url" href="url.html">URL</a></li>
<li><a class="nav-util" href="util.html">Utilities</a></li>
<li><a class="nav-v8" href="v8.html">V8</a></li>
<li><a class="nav-vm" href="vm.html">VM</a></li>
<li><a class="nav-zlib" href="zlib.html">ZLIB</a></li>
</ul>

    </div>

    <div id="column1" data-id="child_process" class="interior">
      <header>
        <h1>Node.js v4.2.1 Documentation</h1>
        <div id="gtoc">
          <p>
            <a href="index.html" name="toc">Index</a> |
            <a href="all.html">View on single page</a> |
            <a href="child_process.json">View as JSON</a>
          </p>
        </div>
        <hr>
      </header>

      <div id="toc">
        <h2>Table of Contents</h2>
        <ul>
<li><a href="#child_process_child_process">Child Process</a><ul>
<li><a href="#child_process_class_childprocess">Class: ChildProcess</a><ul>
<li><a href="#child_process_event_error">Event:  'error'</a></li>
<li><a href="#child_process_event_exit">Event:  'exit'</a></li>
<li><a href="#child_process_event_close">Event: 'close'</a></li>
<li><a href="#child_process_event_disconnect">Event: 'disconnect'</a></li>
<li><a href="#child_process_event_message">Event: 'message'</a></li>
<li><a href="#child_process_child_stdin">child.stdin</a></li>
<li><a href="#child_process_child_stdout">child.stdout</a></li>
<li><a href="#child_process_child_stderr">child.stderr</a></li>
<li><a href="#child_process_child_stdio">child.stdio</a></li>
<li><a href="#child_process_child_pid">child.pid</a></li>
<li><a href="#child_process_child_connected">child.connected</a></li>
<li><a href="#child_process_child_kill_signal">child.kill([signal])</a></li>
<li><a href="#child_process_child_send_message_sendhandle_callback">child.send(message[, sendHandle][, callback])</a><ul>
<li><a href="#child_process_example_sending_server_object">Example: sending server object</a></li>
<li><a href="#child_process_example_sending_socket_object">Example: sending socket object</a></li>
</ul>
</li>
<li><a href="#child_process_child_disconnect">child.disconnect()</a></li>
</ul>
</li>
<li><a href="#child_process_asynchronous_process_creation">Asynchronous Process Creation</a><ul>
<li><a href="#child_process_child_process_spawn_command_args_options">child_process.spawn(command[, args][, options])</a><ul>
<li><a href="#child_process_options_stdio">options.stdio</a></li>
<li><a href="#child_process_options_detached">options.detached</a></li>
</ul>
</li>
<li><a href="#child_process_child_process_exec_command_options_callback">child_process.exec(command[, options], callback)</a></li>
<li><a href="#child_process_child_process_execfile_file_args_options_callback">child_process.execFile(file[, args][, options][, callback])</a></li>
<li><a href="#child_process_child_process_fork_modulepath_args_options">child_process.fork(modulePath[, args][, options])</a></li>
</ul>
</li>
<li><a href="#child_process_synchronous_process_creation">Synchronous Process Creation</a><ul>
<li><a href="#child_process_child_process_spawnsync_command_args_options">child_process.spawnSync(command[, args][, options])</a></li>
<li><a href="#child_process_child_process_execsync_command_options">child_process.execSync(command[, options])</a></li>
<li><a href="#child_process_child_process_execfilesync_file_args_options">child_process.execFileSync(file[, args][, options])</a></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>

      <div id="apicontent">
        <h1>Child Process<span><a name="//apple_ref/Module/child_process"></a><a class="mark" href="#child_process_child_process" id="child_process_child_process">#</a></span></h1>
<pre class="api_stability_2">Stability: 2 - Stable</pre><p>Node.js provides a tri-directional <code>popen(3)</code> facility through the
<code>child_process</code> module.

</p>
<p>It is possible to stream data through a child's <code>stdin</code>, <code>stdout</code>, and
<code>stderr</code> in a fully non-blocking way.  (Note that some programs use
line-buffered I/O internally.  That doesn't affect Node.js but it means
data you send to the child process may not be immediately consumed.)

</p>
<p>To create a child process use <code>require('child_process').spawn()</code> or
<code>require('child_process').fork()</code>.  The semantics of each are slightly
different, and explained <a href="#child_process_asynchronous_process_creation">below</a>.

</p>
<p>For scripting purposes you may find the
<a href="#child_process_synchronous_process_creation">synchronous counterparts</a> more
convenient.

</p>
<h2>Class: ChildProcess<span><a name="//apple_ref/cl/ChildProcess"></a><a class="mark" href="#child_process_class_childprocess" id="child_process_class_childprocess">#</a></span></h2>
<p><code>ChildProcess</code> is an <a href="events.html#events_class_events_eventemitter">EventEmitter</a>.

</p>
<p>Child processes always have three streams associated with them. <code>child.stdin</code>,
<code>child.stdout</code>, and <code>child.stderr</code>.  These may be shared with the stdio
streams of the parent process, or they may be separate stream objects
which can be piped to and from.

</p>
<p>The ChildProcess class is not intended to be used directly.  Use the
<code>spawn()</code>, <code>exec()</code>, <code>execFile()</code>, or <code>fork()</code> methods to create a Child
Process instance.

</p>
<h3>Event:  'error'<span><a name="//apple_ref/Event/error"></a><a class="mark" href="#child_process_event_error" id="child_process_event_error">#</a></span></h3>
<div class="signature"><ul>
<li><code>err</code> <span class="type">Error Object</span> the error.</li>
</ul></div>
<p>Emitted when:

</p>
<ol>
<li>The process could not be spawned, or</li>
<li>The process could not be killed, or</li>
<li>Sending a message to the child process failed for whatever reason.</li>
</ol>
<p>Note that the <code>exit</code>-event may or may not fire after an error has occurred. If
you are listening on both events to fire a function, remember to guard against
calling your function twice.

</p>
<p>See also <a href="#child_process_child_kill_signal"><code>ChildProcess#kill()</code></a> and
<a href="#child_process_child_send_message_sendhandle_callback"><code>ChildProcess#send()</code></a>.

</p>
<h3>Event:  'exit'<span><a name="//apple_ref/Event/exit"></a><a class="mark" href="#child_process_event_exit" id="child_process_event_exit">#</a></span></h3>
<div class="signature"><ul>
<li><code>code</code> <span class="type">Number</span> the exit code, if it exited normally.</li>
<li><code>signal</code> <span class="type">String</span> the signal passed to kill the child process, if it
was killed by the parent.</li>
</ul></div>
<p>This event is emitted after the child process ends. If the process terminated
normally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If
the process terminated due to receipt of a signal, <code>signal</code> is the string name
of the signal, otherwise <code>null</code>.

</p>
<p>Note that the child process stdio streams might still be open.

</p>
<p>Also, note that Node.js establishes signal handlers for <code>'SIGINT'</code> and
<code>'SIGTERM</code>', so it will not terminate due to receipt of those signals,
it will exit.

</p>
<p>See <code>waitpid(2)</code>.

</p>
<h3>Event: 'close'<span><a name="//apple_ref/Event/close"></a><a class="mark" href="#child_process_event_close" id="child_process_event_close">#</a></span></h3>
<div class="signature"><ul>
<li><code>code</code> <span class="type">Number</span> the exit code, if it exited normally.</li>
<li><code>signal</code> <span class="type">String</span> the signal passed to kill the child process, if it
was killed by the parent.</li>
</ul></div>
<p>This event is emitted when the stdio streams of a child process have all
terminated.  This is distinct from 'exit', since multiple processes
might share the same stdio streams.

</p>
<h3>Event: 'disconnect'<span><a name="//apple_ref/Event/disconnect"></a><a class="mark" href="#child_process_event_disconnect" id="child_process_event_disconnect">#</a></span></h3>
<p>This event is emitted after calling the <code>.disconnect()</code> method in the parent
or in the child. After disconnecting it is no longer possible to send messages,
and the <code>.connected</code> property is false.

</p>
<h3>Event: 'message'<span><a name="//apple_ref/Event/message"></a><a class="mark" href="#child_process_event_message" id="child_process_event_message">#</a></span></h3>
<div class="signature"><ul>
<li><code>message</code> <span class="type">Object</span> a parsed JSON object or primitive value.</li>
<li><code>sendHandle</code> <span class="type">Handle object</span> a <a href="net.html#net_class_net_socket">net.Socket</a> or <a href="net.html#net_class_net_server">net.Server</a> object, or
undefined.</li>
</ul></div>
<p>Messages sent by <code>.send(message, [sendHandle])</code> are obtained using the
<code>message</code> event.

</p>
<h3>child.stdin<span><a name="//apple_ref/instp/stdin"></a><a class="mark" href="#child_process_child_stdin" id="child_process_child_stdin">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</ul></div>
<p>A <code>Writable Stream</code> that represents the child process's <code>stdin</code>.
If the child is waiting to read all its input, it will not continue until this
stream has been closed via <code>end()</code>.

</p>
<p>If the child was not spawned with <code>stdio[0]</code> set to <code>'pipe'</code>, then this will
not be set.

</p>
<p><code>child.stdin</code> is shorthand for <code>child.stdio[0]</code>. Both properties will refer
to the same object, or null.

</p>
<h3>child.stdout<span><a name="//apple_ref/instp/stdout"></a><a class="mark" href="#child_process_child_stdout" id="child_process_child_stdout">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</ul></div>
<p>A <code>Readable Stream</code> that represents the child process's <code>stdout</code>.

</p>
<p>If the child was not spawned with <code>stdio[1]</code> set to <code>'pipe'</code>, then this will
not be set.

</p>
<p><code>child.stdout</code> is shorthand for <code>child.stdio[1]</code>. Both properties will refer
to the same object, or null.

</p>
<h3>child.stderr<span><a name="//apple_ref/instp/stderr"></a><a class="mark" href="#child_process_child_stderr" id="child_process_child_stderr">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</ul></div>
<p>A <code>Readable Stream</code> that represents the child process's <code>stderr</code>.

</p>
<p>If the child was not spawned with <code>stdio[2]</code> set to <code>'pipe'</code>, then this will
not be set.

</p>
<p><code>child.stderr</code> is shorthand for <code>child.stdio[2]</code>. Both properties will refer
to the same object, or null.

</p>
<h3>child.stdio<span><a name="//apple_ref/instp/stdio"></a><a class="mark" href="#child_process_child_stdio" id="child_process_child_stdio">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Array</span></li>
</ul></div>
<p>A sparse array of pipes to the child process, corresponding with positions in
the <a href="#child_process_options_stdio">stdio</a> option to
<a href="#child_process_child_process_spawn_command_args_options">spawn</a> that have been
set to <code>'pipe'</code>.
Note that streams 0-2 are also available as ChildProcess.stdin,
ChildProcess.stdout, and ChildProcess.stderr, respectively.

</p>
<p>In the following example, only the child's fd <code>1</code> is setup as a pipe, so only
the parent's <code>child.stdio[1]</code> is a stream, all other values in the array are
<code>null</code>.

</p>
<pre><code>var assert = require('assert');
var fs = require('fs');
var child_process = require('child_process');

child = child_process.spawn('ls', {
    stdio: [
      0, // use parents stdin for child
      'pipe', // pipe child's stdout to parent
      fs.openSync('err.out', 'w') // direct child's stderr to a file
    ]
});

assert.equal(child.stdio[0], null);
assert.equal(child.stdio[0], child.stdin);

assert(child.stdout);
assert.equal(child.stdio[1], child.stdout);

assert.equal(child.stdio[2], null);
assert.equal(child.stdio[2], child.stderr);</code></pre>
<h3>child.pid<span><a name="//apple_ref/instp/pid"></a><a class="mark" href="#child_process_child_pid" id="child_process_child_pid">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Integer</span></li>
</ul></div>
<p>The PID of the child process.

</p>
<p>Example:

</p>
<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

console.log('Spawned child pid: ' + grep.pid);
grep.stdin.end();</code></pre>
<h3>child.connected<span><a name="//apple_ref/instp/connected"></a><a class="mark" href="#child_process_child_connected" id="child_process_child_connected">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span> Set to false after <code>.disconnect</code> is called</li>
</ul></div>
<p>If <code>.connected</code> is false, it is no longer possible to send messages.

</p>
<h3>child.kill([signal])<span><a name="//apple_ref/clm/child.kill"></a><a class="mark" href="#child_process_child_kill_signal" id="child_process_child_kill_signal">#</a></span></h3>
<div class="signature"><ul>
<li><code>signal</code> <span class="type">String</span></li>
</ul></div>
<p>Send a signal to the child process. If no argument is given, the process will
be sent <code>'SIGTERM'</code>. See <code>signal(7)</code> for a list of available signals.

</p>
<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

grep.on('close', function (code, signal) {
  console.log('child process terminated due to receipt of signal ' + signal);
});

// send SIGHUP to process
grep.kill('SIGHUP');</code></pre>
<p>May emit an <code>'error'</code> event when the signal cannot be delivered. Sending a
signal to a child process that has already exited is not an error but may
have unforeseen consequences: if the PID (the process ID) has been reassigned
to another process, the signal will be delivered to that process instead.
What happens next is anyone's guess.

</p>
<p>Note that while the function is called <code>kill</code>, the signal delivered to the
child process may not actually kill it.  <code>kill</code> really just sends a signal
to a process.

</p>
<p>See <code>kill(2)</code>

</p>
<h3>child.send(message[, sendHandle][, callback])<span><a name="//apple_ref/clm/child.send"></a><a class="mark" href="#child_process_child_send_message_sendhandle_callback" id="child_process_child_send_message_sendhandle_callback">#</a></span></h3>
<div class="signature"><ul>
<li><code>message</code> <span class="type">Object</span></li>
<li><code>sendHandle</code> <span class="type">Handle object</span></li>
<li><code>callback</code> <span class="type">Function</span></li>
<li>Return: Boolean</li>
</ul></div>
<p>When using <a href="#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a> you can write to the child using
<code>child.send(message[, sendHandle][, callback])</code> and messages are received by
a <code>'message'</code> event on the child.

</p>
<p>For example:

</p>
<pre><code>var cp = require('child_process');

var n = cp.fork(__dirname + '/sub.js');

n.on('message', function(m) {
  console.log('PARENT got message:', m);
});

n.send({ hello: 'world' });</code></pre>
<p>And then the child script, <code>'sub.js'</code> might look like this:

</p>
<pre><code>process.on('message', function(m) {
  console.log('CHILD got message:', m);
});

process.send({ foo: 'bar' });</code></pre>
<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
will emit objects each time it receives a message on its channel.

</p>
<p>There is a special case when sending a <code>{cmd: 'NODE_foo'}</code> message. All messages
containing a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in
the <code>message</code> event, since they are internal messages used by Node.js core.
Messages containing the prefix are emitted in the <code>internalMessage</code> event.
Avoid using this feature; it is subject to change without notice.

</p>
<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a TCP server or
socket object to another process. The child will receive the object as its
second argument to the <code>message</code> event.

</p>
<p>The <code>callback</code> option is a function that is invoked after the message is
sent but before the target may have received it.  It is called with a single
argument: <code>null</code> on success, or an <code>Error</code> object on failure.

</p>
<p><code>child.send()</code> emits an <code>'error'</code> event if no callback was given and the message
cannot be sent, for example because the child process has already exited.

</p>
<p>Returns <code>true</code> under normal circumstances or <code>false</code> when the backlog of
unsent messages exceeds a threshold that makes it unwise to send more.
Use the callback mechanism to implement flow control.

</p>
<h4>Example: sending server object<span><a class="mark" href="#child_process_example_sending_server_object" id="child_process_example_sending_server_object">#</a></span></h4>
<p>Here is an example of sending a server:

</p>
<pre><code>var child = require('child_process').fork('child.js');

// Open up the server object and send the handle.
var server = require('net').createServer();
server.on('connection', function (socket) {
  socket.end('handled by parent');
});
server.listen(1337, function() {
  child.send('server', server);
});</code></pre>
<p>And the child would then receive the server object as:

</p>
<pre><code>process.on('message', function(m, server) {
  if (m === 'server') {
    server.on('connection', function (socket) {
      socket.end('handled by child');
    });
  }
});</code></pre>
<p>Note that the server is now shared between the parent and child, this means
that some connections will be handled by the parent and some by the child.

</p>
<p>For <code>dgram</code> servers the workflow is exactly the same.  Here you listen on
a <code>message</code> event instead of <code>connection</code> and use <code>server.bind</code> instead of
<code>server.listen</code>.  (Currently only supported on UNIX platforms.)

</p>
<h4>Example: sending socket object<span><a class="mark" href="#child_process_example_sending_socket_object" id="child_process_example_sending_socket_object">#</a></span></h4>
<p>Here is an example of sending a socket. It will spawn two children and handle
connections with the remote address <code>74.125.127.100</code> as VIP by sending the
socket to a "special" child process. Other sockets will go to a "normal"
process.

</p>
<pre><code>var normal = require('child_process').fork('child.js', ['normal']);
var special = require('child_process').fork('child.js', ['special']);

// Open up the server and send sockets to child
var server = require('net').createServer();
server.on('connection', function (socket) {

  // if this is a VIP
  if (socket.remoteAddress === '74.125.127.100') {
    special.send('socket', socket);
    return;
  }
  // just the usual...
  normal.send('socket', socket);
});
server.listen(1337);</code></pre>
<p>The <code>child.js</code> could look like this:

</p>
<pre><code>process.on('message', function(m, socket) {
  if (m === 'socket') {
    socket.end('You were handled as a ' + process.argv[2] + ' person');
  }
});</code></pre>
<p>Note that once a single socket has been sent to a child the parent can no
longer keep track of when the socket is destroyed. To indicate this condition
the <code>.connections</code> property becomes <code>null</code>.
It is also recommended not to use <code>.maxConnections</code> in this condition.

</p>
<h3>child.disconnect()<span><a name="//apple_ref/clm/child.disconnect"></a><a class="mark" href="#child_process_child_disconnect" id="child_process_child_disconnect">#</a></span></h3>
<p>Close the IPC channel between parent and child, allowing the child to exit
gracefully once there are no other connections keeping it alive. After calling
this method the <code>.connected</code> flag will be set to <code>false</code> in both the parent and
child, and it is no longer possible to send messages.

</p>
<p>The 'disconnect' event will be emitted when there are no messages in the process
of being received, most likely immediately.

</p>
<p>Note that you can also call <code>process.disconnect()</code> in the child process when the
child process has any open IPC channels with the parent (i.e <code>fork()</code>).

</p>
<h2>Asynchronous Process Creation<span><a name="//apple_ref/Module/asynchronous_process_creation"></a><a class="mark" href="#child_process_asynchronous_process_creation" id="child_process_asynchronous_process_creation">#</a></span></h2>
<p>These methods follow the common async programming patterns (accepting a
callback or returning an EventEmitter).

</p>
<h3>child_process.spawn(command[, args][, options])<span><a name="//apple_ref/clm/child_process.spawn"></a><a class="mark" href="#child_process_child_process_spawn_command_args_options" id="child_process_child_process_spawn_command_args_options">#</a></span></h3>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> The command to run</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>stdio</code> <span class="type">Array|String</span> Child's stdio configuration. (See
<a href="#child_process_options_stdio">below</a>)</li>
<li><code>detached</code> <span class="type">Boolean</span> Prepare child to run independently of its parent
process. Specific behavior depends on the platform, see
<a href="#child_process_options_detached">below</a>)</li>
<li><code>uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li>return: <span class="type">ChildProcess object</span></li>
</ul></div>
<p>Launches a new process with the given <code>command</code>, with  command line arguments in
<code>args</code>. If omitted, <code>args</code> defaults to an empty Array.

</p>
<p>The third argument is used to specify additional options, with these defaults:

</p>
<pre><code>{ cwd: undefined,
  env: process.env
}</code></pre>
<p>Use <code>cwd</code> to specify the working directory from which the process is spawned.
If not given, the default is to inherit the current working directory.

</p>
<p>Use <code>env</code> to specify environment variables that will be visible to the new
process, the default is <code>process.env</code>.

</p>
<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:

</p>
<pre><code>var spawn = require('child_process').spawn,
    ls    = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', function (data) {
  console.log('stdout: ' + data);
});

ls.stderr.on('data', function (data) {
  console.log('stderr: ' + data);
});

ls.on('close', function (code) {
  console.log('child process exited with code ' + code);
});</code></pre>
<p>Example: A very elaborate way to run 'ps ax | grep ssh'

</p>
<pre><code>var spawn = require('child_process').spawn,
    ps    = spawn('ps', ['ax']),
    grep  = spawn('grep', ['ssh']);

ps.stdout.on('data', function (data) {
  grep.stdin.write(data);
});

ps.stderr.on('data', function (data) {
  console.log('ps stderr: ' + data);
});

ps.on('close', function (code) {
  if (code !== 0) {
    console.log('ps process exited with code ' + code);
  }
  grep.stdin.end();
});

grep.stdout.on('data', function (data) {
  console.log('' + data);
});

grep.stderr.on('data', function (data) {
  console.log('grep stderr: ' + data);
});

grep.on('close', function (code) {
  if (code !== 0) {
    console.log('grep process exited with code ' + code);
  }
});</code></pre>
<p>Example of checking for failed exec:

</p>
<pre><code>var spawn = require('child_process').spawn,
    child = spawn('bad_command');

child.on('error', function (err) {
  console.log('Failed to start child process.');
});</code></pre>
<h4>options.stdio<span><a name="//apple_ref/instp/options.stdio"></a><a class="mark" href="#child_process_options_stdio" id="child_process_options_stdio">#</a></span></h4>
<p>As a shorthand, the <code>stdio</code> argument may be one of the following strings:

</p>
<ul>
<li><code>'pipe'</code> - <code>['pipe', 'pipe', 'pipe']</code>, this is the default value</li>
<li><code>'ignore'</code> - <code>['ignore', 'ignore', 'ignore']</code></li>
<li><code>'inherit'</code> - <code>[process.stdin, process.stdout, process.stderr]</code> or <code>[0,1,2]</code></li>
</ul>
<p>Otherwise, the 'stdio' option to <code>child_process.spawn()</code> is an array where each
index corresponds to a fd in the child.  The value is one of the following:

</p>
<ol>
<li><code>'pipe'</code> - Create a pipe between the child process and the parent process.
The parent end of the pipe is exposed to the parent as a property on the
<code>child_process</code> object as <code>ChildProcess.stdio[fd]</code>. Pipes created for
fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout
and ChildProcess.stderr, respectively.</li>
<li><code>'ipc'</code> - Create an IPC channel for passing messages/file descriptors
between parent and child. A ChildProcess may have at most <em>one</em> IPC stdio
file descriptor. Setting this option enables the ChildProcess.send() method.
If the child writes JSON messages to this file descriptor, then this will
trigger ChildProcess.on('message').  If the child is an Node.js program, then
the presence of an IPC channel will enable process.send() and
process.on('message').</li>
<li><code>'ignore'</code> - Do not set this file descriptor in the child. Note that Node.js
will always open fd 0 - 2 for the processes it spawns. When any of these is
ignored Node.js will open <code>/dev/null</code> and attach it to the child's fd.</li>
<li><code>Stream</code> object - Share a readable or writable stream that refers to a tty,
file, socket, or a pipe with the child process. The stream's underlying
file descriptor is duplicated in the child process to the fd that
corresponds to the index in the <code>stdio</code> array. Note that the stream must
have an underlying descriptor (file streams do not until the <code>'open'</code>
event has occurred).</li>
<li>Positive integer - The integer value is interpreted as a file descriptor
that is is currently open in the parent process. It is shared with the child
process, similar to how <code>Stream</code> objects can be shared.</li>
<li><code>null</code>, <code>undefined</code> - Use default value. For stdio fds 0, 1 and 2 (in other
words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the
default is <code>'ignore'</code>.</li>
</ol>
<p>Example:

</p>
<pre><code>var spawn = require('child_process').spawn;

// Child will use parent's stdios
spawn('prg', [], { stdio: 'inherit' });

// Spawn child sharing only stderr
spawn('prg', [], { stdio: ['pipe', 'pipe', process.stderr] });

// Open an extra fd=4, to interact with programs present a
// startd-style interface.
spawn('prg', [], { stdio: ['pipe', null, null, null, 'pipe'] });</code></pre>
<h4>options.detached<span><a name="//apple_ref/instp/options.detached"></a><a class="mark" href="#child_process_options_detached" id="child_process_options_detached">#</a></span></h4>
<p>On Windows, this makes it possible for the child to continue running after the
parent exits. The child will have a new console window (this cannot be
disabled).

</p>
<p>On non-Windows, if the <code>detached</code> option is set, the child process will be made
the leader of a new process group and session. Note that child processes may
continue running after the parent exits whether they are detached or not.  See
<code>setsid(2)</code> for more information.

</p>
<p>By default, the parent will wait for the detached child to exit.  To prevent
the parent from waiting for a given <code>child</code>, use the <code>child.unref()</code> method,
and the parent's event loop will not include the child in its reference count.

</p>
<p>Example of detaching a long-running process and redirecting its output to a
file:

</p>
<pre><code> var fs = require('fs'),
     spawn = require('child_process').spawn,
     out = fs.openSync('./out.log', 'a'),
     err = fs.openSync('./out.log', 'a');

 var child = spawn('prg', [], {
   detached: true,
   stdio: [ 'ignore', out, err ]
 });

 child.unref();</code></pre>
<p>When using the <code>detached</code> option to start a long-running process, the process
will not stay running in the background unless it is provided with a <code>stdio</code>
configuration that is not connected to the parent.  If the parent's <code>stdio</code> is
inherited, the child will remain attached to the controlling terminal.

</p>
<p>See also: <a href="#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a> and <a href="#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a>

</p>
<h3>child_process.exec(command[, options], callback)<span><a name="//apple_ref/clm/child_process.exec"></a><a class="mark" href="#child_process_child_process_exec_command_options_callback" id="child_process_child_process_exec_command_options_callback">#</a></span></h3>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> The command to run, with space-separated arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span class="type">String</span> (Default: 'utf8')</li>
<li><code>shell</code> <span class="type">String</span> Shell to execute the command with
(Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows,  The shell should
 understand the <code>-c</code> switch on UNIX or <code>/s /c</code> on Windows. On Windows,
 command line parsing should be compatible with <code>cmd.exe</code>.)</li>
<li><code>timeout</code> <span class="type">Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span class="type">Number</span> largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed (Default: <code>200*1024</code>)</li>
<li><code>killSignal</code> <span class="type">String</span> (Default: 'SIGTERM')</li>
<li><code>uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code>error</code> <span class="type">Error</span></li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</ul></div>
<p>Runs a command in a shell and buffers the output.

</p>
<pre><code>var exec = require('child_process').exec,
    child;

child = exec('cat *.js bad_file | wc -l',
  function (error, stdout, stderr) {
    console.log('stdout: ' + stdout);
    console.log('stderr: ' + stderr);
    if (error !== null) {
      console.log('exec error: ' + error);
    }
});</code></pre>
<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>
will be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>error.code</code>
will be the exit code of the child process, and <code>error.signal</code> will be set to the
signal that terminated the process.

</p>
<p>There is a second optional argument to specify several options. The
default options are

</p>
<pre><code>{ encoding: 'utf8',
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: 'SIGTERM',
  cwd: null,
  env: null }</code></pre>
<p>If <code>timeout</code> is greater than 0, then it will kill the child process
if it runs longer than <code>timeout</code> milliseconds. The child process is killed with
<code>killSignal</code> (default: <code>'SIGTERM'</code>). <code>maxBuffer</code> specifies the largest
amount of data (in bytes) allowed on stdout or stderr - if this value is
exceeded then the child process is killed.

</p>
<p><em>Note: Unlike the <code>exec()</code> POSIX system call, <code>child_process.exec()</code> does not replace
the existing process and uses a shell to execute the command.</em>

</p>
<h3>child_process.execFile(file[, args][, options][, callback])<span><a name="//apple_ref/clm/child_process.execFile"></a><a class="mark" href="#child_process_child_process_execfile_file_args_options_callback" id="child_process_child_process_execfile_file_args_options_callback">#</a></span></h3>
<div class="signature"><ul>
<li><code>file</code> <span class="type">String</span> The filename of the program to run</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span class="type">String</span> (Default: 'utf8')</li>
<li><code>timeout</code> <span class="type">Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span class="type">Number</span> largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed (Default: 200*1024)</li>
<li><code>killSignal</code> <span class="type">String</span> (Default: 'SIGTERM')</li>
<li><code>uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code>error</code> <span class="type">Error</span></li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</ul></div>
<p>This is similar to <a href="#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a> except it does not execute a
subshell but rather the specified file directly. This makes it slightly
leaner than <a href="#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>. It has the same options.


</p>
<h3>child_process.fork(modulePath[, args][, options])<span><a name="//apple_ref/clm/child_process.fork"></a><a class="mark" href="#child_process_child_process_fork_modulepath_args_options" id="child_process_child_process_fork_modulepath_args_options">#</a></span></h3>
<div class="signature"><ul>
<li><code>modulePath</code> <span class="type">String</span> The module to run in the child</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>execPath</code> <span class="type">String</span> Executable used to create the child process</li>
<li><code>execArgv</code> <span class="type">Array</span> List of string arguments passed to the executable
(Default: <code>process.execArgv</code>)</li>
<li><code>silent</code> <span class="type">Boolean</span> If true, stdin, stdout, and stderr of the child will be
piped to the parent, otherwise they will be inherited from the parent, see
the "pipe" and "inherit" options for <code>spawn()</code>'s <code>stdio</code> for more details
(default is false)</li>
<li><code>uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</ul></div>
<p>This is a special case of the <a href="#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a> functionality for spawning Node.js
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. See
<a href="#child_process_child_send_message_sendhandle_callback"><code>child.send(message, [sendHandle])</code></a> for details.

</p>
<p>These child Node.js processes are still whole new instances of V8. Assume at
least 30ms startup and 10mb memory for each new Node.js. That is, you cannot
create many thousands of them.

</p>
<p>The <code>execPath</code> property in the <code>options</code> object allows for a process to be
created for the child rather than the current <code>node</code> executable. This should be
done with care and by default will talk over the fd represented an
environmental variable <code>NODE_CHANNEL_FD</code> on the child process. The input and
output on this fd is expected to be line delimited JSON objects.

</p>
<p><em>Note: Unlike the <code>fork()</code> POSIX system call, <code>child_process.fork()</code> does not clone the
current process.</em>

</p>
<h2>Synchronous Process Creation<span><a name="//apple_ref/Module/synchronous_process_creation"></a><a class="mark" href="#child_process_synchronous_process_creation" id="child_process_synchronous_process_creation">#</a></span></h2>
<p>These methods are <strong>synchronous</strong>, meaning they <strong>WILL</strong> block the event loop,
pausing execution of your code until the spawned process exits.

</p>
<p>Blocking calls like these are mostly useful for simplifying general purpose
scripting tasks and for simplifying the loading/processing of application
configuration at startup.

</p>
<h3>child_process.spawnSync(command[, args][, options])<span><a name="//apple_ref/clm/child_process.spawnSync"></a><a class="mark" href="#child_process_child_process_spawnsync_command_args_options" id="child_process_child_process_spawnsync_command_args_options">#</a></span></h3>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> The command to run</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>input</code> <span class="type">String|Buffer</span> The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code>stdio[0]</code></li>
</ul>
</li>
<li><code>stdio</code> <span class="type">Array</span> Child's stdio configuration.</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
<li><code>timeout</code> <span class="type">Number</span> In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code>killSignal</code> <span class="type">String</span> The signal value to be used when the spawned process will be killed. (Default: 'SIGTERM')</li>
<li><code>maxBuffer</code> <span class="type">Number</span> largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed</li>
<li><code>encoding</code> <span class="type">String</span> The encoding used for all stdio inputs and outputs. (Default: 'buffer')</li>
</ul>
</li>
<li>return: <span class="type">Object</span><ul>
<li><code>pid</code> <span class="type">Number</span> Pid of the child process</li>
<li><code>output</code> <span class="type">Array</span> Array of results from stdio output</li>
<li><code>stdout</code> <span class="type">Buffer|String</span> The contents of <code>output[1]</code></li>
<li><code>stderr</code> <span class="type">Buffer|String</span> The contents of <code>output[2]</code></li>
<li><code>status</code> <span class="type">Number</span> The exit code of the child process</li>
<li><code>signal</code> <span class="type">String</span> The signal used to kill the child process</li>
<li><code>error</code> <span class="type">Error</span> The error object if the child process failed or timed out</li>
</ul>
</li>
</ul></div>
<p><code>spawnSync</code> will not return until the child process has fully closed. When a
timeout has been encountered and <code>killSignal</code> is sent, the method won't return
until the process has completely exited. That is to say, if the process handles
the <code>SIGTERM</code> signal and doesn't exit, your process will wait until the child
process has exited.

</p>
<h3>child_process.execSync(command[, options])<span><a name="//apple_ref/clm/child_process.execSync"></a><a class="mark" href="#child_process_child_process_execsync_command_options" id="child_process_child_process_execsync_command_options">#</a></span></h3>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> The command to run</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>input</code> <span class="type">String|Buffer</span> The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code>stdio[0]</code></li>
</ul>
</li>
<li><code>stdio</code> <span class="type">Array</span> Child's stdio configuration. (Default: 'pipe')<ul>
<li><code>stderr</code> by default will be output to the parent process' stderr unless
<code>stdio</code> is specified</li>
</ul>
</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
<li><code>timeout</code> <span class="type">Number</span> In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code>killSignal</code> <span class="type">String</span> The signal value to be used when the spawned process will be killed. (Default: 'SIGTERM')</li>
<li><code>maxBuffer</code> <span class="type">Number</span> largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed</li>
<li><code>encoding</code> <span class="type">String</span> The encoding used for all stdio inputs and outputs. (Default: 'buffer')</li>
</ul>
</li>
<li>return: <span class="type">Buffer|String</span> The stdout from the command</li>
</ul></div>
<p><code>execSync</code> will not return until the child process has fully closed. When a
timeout has been encountered and <code>killSignal</code> is sent, the method won't return
until the process has completely exited. That is to say, if the process handles
the <code>SIGTERM</code> signal and doesn't exit, your process will wait until the child
process has exited.

</p>
<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>
throw.  The <code>Error</code> object will contain the entire result from
<a href="#child_process_child_process_spawnsync_command_args_options"><code>child_process.spawnSync()</code></a>

</p>
<h3>child_process.execFileSync(file[, args][, options])<span><a name="//apple_ref/clm/child_process.execFileSync"></a><a class="mark" href="#child_process_child_process_execfilesync_file_args_options" id="child_process_child_process_execfilesync_file_args_options">#</a></span></h3>
<div class="signature"><ul>
<li><code>file</code> <span class="type">String</span> The filename of the program to run</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>input</code> <span class="type">String|Buffer</span> The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code>stdio[0]</code></li>
</ul>
</li>
<li><code>stdio</code> <span class="type">Array</span> Child's stdio configuration. (Default: 'pipe')<ul>
<li><code>stderr</code> by default will be output to the parent process' stderr unless
<code>stdio</code> is specified</li>
</ul>
</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
<li><code>timeout</code> <span class="type">Number</span> In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code>killSignal</code> <span class="type">String</span> The signal value to be used when the spawned process will be killed. (Default: 'SIGTERM')</li>
<li><code>maxBuffer</code> <span class="type">Number</span> largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed</li>
<li><code>encoding</code> <span class="type">String</span> The encoding used for all stdio inputs and outputs. (Default: 'buffer')</li>
</ul>
</li>
<li>return: <span class="type">Buffer|String</span> The stdout from the command</li>
</ul></div>
<p><code>execFileSync</code> will not return until the child process has fully closed. When a
timeout has been encountered and <code>killSignal</code> is sent, the method won't return
until the process has completely exited. That is to say, if the process handles
the <code>SIGTERM</code> signal and doesn't exit, your process will wait until the child
process has exited.

</p>
<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>
throw.  The <code>Error</code> object will contain the entire result from
<a href="#child_process_child_process_spawnsync_command_args_options"><code>child_process.spawnSync()</code></a>

</p>

      </div>
    </div>
  </div>
  <div id="footer">
  </div>

  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>



</body></html>