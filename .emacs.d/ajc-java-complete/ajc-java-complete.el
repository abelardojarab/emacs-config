;;; ajc-java-complete.el --- Auto Java Completion for GNU Emacs

;; This file is NOT part of GNU Emacs
;; plesase send Bug reports and suggestions to 'Joseph at <jixiuf@gmail.com>

;;  License

;; Copyright (C) 2011  Joseph <jixiuf@gmail.com> Limited

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary

;;;this is "Auto Java Complete".

;;; Commands:
;;
;; Below are complete command list:
;;
;;  `ajc-reload'
;;    restart Auto Java Complete ,when your tag file changed,
;;  `ajc-import-all-unimported-class'
;;    import all unimported class .
;;  `ajc-import-class-under-point'
;;    import class under point.
;;
;;; Customizable Options:
;;
;; Below are customizable option list:
;;
;;  `ajc-tag-file'
;;    the tag file is  used for java complete ,it  is generate by a Tags.java ,
;;    default = "~/.java_base.tag"
;;  `ajc-default-length-of-class'
;;    the length of class name at dropdown-menu ,if the class
;;    default = 36
;;  `ajc-return-type-char'
;;    the char  before return type when
;;    default = ":"
;;  `ajc-throws-char'
;;    the char  before Exceptions  when completing
;;    default = "   #"

;;1. it depends on auto complete ,so it would complete
;;   everything by dropdowning a menu.

;;2. it is tag based . so before you used it on emacs ,you
;;   should generate a tag file by using Tags.java .
;;   about how to use it ,see the Install section.

;;3. it depends on yasnippet . when completing method and
;;   constructor it would generate a template dynamically
;;   so that you can jump from a paramter to another one .

;;; Features

;; 1. support importing.
;;    when you type in  import javax.s-|-
;;    it would drop down a menu like this
;;             import  javax.s
;;
;;                     javax.sql
;;                     javax.swing
;;                     javax.sound

;; 2. support import class with keybindings (even in jsp file)
;;         auto import all Class in source file
;;    (local-set-key (kbd "C-c i") (quote ajc-import-all-unimported-class))
;;         import Class where under point
;;    (local-set-key (kbd "C-c m") (quote ajc-import-class-under-point))
;;   included in ajc-complete-config.el

;; 3. support completing class name ,you just need  typing
;;    in a Word beginning with [A-Z] ,then it would auto find
;;    matched class and list it with dropdown menu.


;; 4. support complete method.
;;    for example
;;    List<Map<String,Object>> list = new ArrayList<Map<String,Object>>();
;;         list.

;;    it would list all method like this
;;         list.
;;              equals(Object)
;;              add(Object)
;;              clear()

;;    it can do more
;;         list.listIterator().next().
;;                                      toString()
;;                                      getClass()
;;                                      notify()

;; 5. support complete constructor
;;    after keyword 'new' it would try to complete constructor


;; 6. support completing in jsp files.

;;    If your want to enable  ajc-java-complete-mode when openning
;;    a jsp file. you can
;;        (add-hook 'jsp-mode 'ajc-java-complete-mode)
;;    if you has a jsp-mode;
;;    if not ,you can do it like this
;;        (add-hook 'find-file-hook 'ajc-4-jsp-find-file-hook)

;;    now it can complete class name,method ,constructor.
;;    it also support complete importing ,but it isn't auto completed,
;;    you must trigger it by a key binding
;;    for example (define-key ac-mode-map (kbd "M-1") 'auto-complete)
;;    <%@ page language="java" import="java.io.File,java.util.Map,javax.sw-|-"%>
;;    now you can  press M-1 to show the menu.
;;

;;; Install
;;   see Install file in this directory

;;; Code.

(require 'cl)

(defgroup auto-java-complete nil
  "Auto Java Completion."
  :group 'convenience
  :prefix "auto-java-complete")

(defcustom ajc-tag-file "~/.java_base.tag"
  "Pathname of the tag file. The tag file is used for java
completion and is generated by a Tags.java. So before you use
this tool, try to compile Tags.java and use the class to create a
tag file. It will tag all jars in classpath to tag file. To tag
specific classes under classpath, use the follwoing command: java
Tags com.whatever.* This will tag classes under com.whatever
packages."
  :type 'string
  :group 'auto-java-complete)

(defcustom ajc-tag-file-list nil
  "A list of absolute file names of tag files."
  :type 'list
  :group 'auto-java-complete)

(defcustom ajc-default-length-of-class 36
  "The length of class name at dropdown-menu. If the class name
is shorter than this value, then empty string is appended, and
return type are at position 37."
  :type 'integer
  :group 'auto-java-complete)

(defcustom ajc-return-type-char ":"
  "Character before return type when completing methods."
  :type 'string
  :group 'auto-java-complete
  )
(defcustom ajc-throws-char "   #"
  "Character before Exceptions when completing method."
  :type 'string
  :group 'auto-java-complete
  )

(defcustom ajc-method-table-cache-dir "~/.ajc"
  "Directory where cache files are stored."
  :type 'directory
  :group 'auto-java-complete)

;; private variables
(defvar ajc-is-running nil "After calling `ajc-init', this will become true.")

(defvar ajc-all-sorted-class-items nil
  "This is a list. All the element are sorted class-items. This
variable should work with ajc-two-char-list to make searching for
a class faster.")

(defvar ajc-two-char-list nil
  "This looks like '((Ab 1 3 ) (Ac 4 15)). All classes whose name
starts with Ab are in the position of 0~2 (because of 0-origin)
in `ajc-all-sorted-class-items'.")

(defvar ajc-two-char-tbl (make-hash-table :test #'equal)
  "Hash table in which to store two-char-items.
For example, \"Ab\" => ((0 Ab 1 3) (1 Ab 4 15)), \"Ac\" => ((0 Ac
4 10) (1 Ac 16 22)) and so on. (0 Ab 1 3) means that in the 0th
buffer of `ajc-tag-buffer-list' classnames which begin with
\"Ab\" reside between line 1 and 3.")

(defvar ajc-tmp-sorted-class-buffer-name " *ajc-tmp-sorted-class*")

(defvar ajc-sorted-class-buffer-name-list nil
  "A list of buffer names holding sorted classnames. Each buffer
in this list corresponds to tags file.")

(defvar ajc-tag-buffer-name nil "This is the name of tag buffer.")

(defvar ajc-tag-buffer-list nil
  "A list of tags buffer. Each buffer corresponds to a tag
file.")

(defvar ajc-package-first-ln 0
  "The first line number of the package section in tag file")

(defvar ajc-class-first-ln 0
  "The first line number of the class section in tag file.
It also is the end of package section line number.")

(defvar ajc-member-first-ln 0
  "The first line number of the member section in tag file.
It also is the end of package section line number.")

(defvar ajc-member-end-ln 0
  "The end line number of the member section in tag file.
It is the last line number in tag file.")

(defvar ajc-position-of-package-first-line 1)
(defvar ajc-position-of-class-first-line 1)
(defvar ajc-position-of-member-first-line 1)
(defvar ajc-position-of-member-end-line 1)

(defvar ajc-position-of-class-first-line-list nil)
(defvar ajc-position-of-member-first-line-list nil)

(defvar ajc-lines-and-positions-list nil
  "Holds the follwing info for each tag buffer, which means this
is a list of the follwing info. More concretely, info at index 0
of this list corresponds to a tag buffer at index 0 of
`ajc-tag-buffer-list.'
 (
  (package-first-line . position-of-package-first-line)
  (class-first-line . position-of-class-first-line)
  ((member-first-line . position-of-member-first-line) .
   (member-end-line . position-of-member-end-line))
 )")

(defvar ajc-matched-class-items-cache nil
  "When searching for class-prefix without package-name,
we have to search in thoudsands of lines in tags files. So this
manybe cache those for next match.")

(defvar ajc-previous-class-prefix nil "Cache last class-prefix")

(defvar ajc-matched-import-cache-list nil
  "Cache of pakcage names. When completing a import statement,
sometimes we can use the last completed items for next complete")

(defvar ajc-previous-matched-import-prefix nil
  "Previously matched prefix for import class statements at head
of source.")

(defvar ajc-current-class-prefix-4-complete-class nil
  "When `ajc-is-available-4-complete-class-p' returns true,
it will save current class-prefix in this variable, so
`ajc-complete-class-candidates' can reuse this.")

(defvar ajc-package-in-tags-cache-tbl nil
  "Hash table to be used as cache of package names in a tags
file.")

(defvar ajc-thing-after-varname-regexp "[,=;)[:space:]]"
  "Regular expression that matches the thing after variable name.")

(defvar ajc-plain-method-tables nil
  "A list of hashtables which we use as source of plain method
completion.")

(defcustom ajc-plain-method-candidates-limit 100
  "The number of candidates that come from
ac-source-ajc-plain-method-candidates"
  :type 'number
  :group 'auto-java-complete)

(defcustom ajc-use-plain-method-completion nil
  "Non-nil to use plain method completion. Be warned that
building plain method completion tables is very time-consuming."
  :type 'boolen
  :group 'auto-java-complete)

(defun ajc-get-package-first-line (ix lst)
  (car (nth 0 (nth ix lst))))
(defun ajc-get-package-first-line-position (ix lst)
  (cdr (nth 0 (nth ix lst))))

(defun ajc-get-class-first-line (ix lst)
  (car (nth 1 (nth ix lst))))
(defun ajc-get-class-first-line-position (ix lst)
  (cdr (nth 1 (nth ix lst))))

(defun ajc-get-member-first-line (ix lst)
  (caar (nth 2 (nth ix lst))))
(defun ajc-get-member-first-line-position (ix lst)
  (cdar (nth 2 (nth ix lst))))
(defun ajc-get-member-end-line (ix lst)
  (cadr (nth 2 (nth ix lst))))
(defun ajc-get-member-end-line-position (ix lst)
  (cddr (nth 2 (nth ix lst))))

(defun ajc-goto-line (line-num &optional buffer)
  (with-current-buffer (or buffer (current-buffer))
    (when (numberp line-num)
      (goto-char (point-min))
      (forward-line (1- line-num)))))

(defun ajc-read-line (line-number &optional buffer)
  "Read a line at LINE-NUMBER and return the string."
  (with-current-buffer (or buffer (current-buffer))
    (ajc-goto-line line-number)
    (buffer-substring-no-properties (line-beginning-position)
                                    (line-end-position))))

(defun ajc-split-string-with-separator (str regexp &optional replacement omit-nulls)
  "This function is a tool like split-string, but it treats separator
as an element of returned list. For example
 (ajc-split-string-with-separator abc.def.g \"\\.\" \".\") will return
'(\"abc\" \".\" \"def\" \".\" \"g\")"
  (when str
    (let (split-list substr match-end)
      (if (string-match regexp str)
          (progn
            (while (string-match regexp str)
              (setq match-end (match-end 0))
              (setq substr (substring-no-properties str 0 (- match-end 1)))
              (when (or (not omit-nulls) (> (length substr) 0))
                (setq split-list (append split-list (list substr))))
              (setq split-list (append split-list (list (or replacement regexp))))
              (setq str (substring-no-properties str match-end)))
            (when (or (not omit-nulls) (> (length str) 0))
              (setq split-list (append split-list (list str)))))
        (setq split-list (list str)))
      split-list)))

(defun ajc-split-pkg-item (pkg-line-string)
  "The format PKG-LINE-STRING is \"str`num`num\".
This function translates it to a list. For
example, (ajc-split-pkg-item \"`java.lang`222`333\") will return
'(\"java.lang\" 222 333) "
  (let ((pkg-item (split-string pkg-line-string "`" t)))
    (setcar (nthcdr 1 pkg-item) (string-to-number (nth 1 pkg-item)))
    (setcar (nthcdr 2 pkg-item) (string-to-number (nth 2 pkg-item)))
    pkg-item))

(defun ajc-split-pkg-item-by-pkg-ln (index pkg-line-number &optional buffer)
  "Return a list of translated package line at PKG-LINE-NUMBER."
  (ajc-split-pkg-item
   (ajc-read-line pkg-line-number
                  (nth index ajc-tag-buffer-list))))

(defun ajc-split-class-item (class-line-string)
  "The format of CLASS-LINE-STRING is
  \"classname`packageLineNum`memberStartLineNum`memberEndLineNum\".
This function translates it to a list."
  (let ((class-item (split-string class-line-string "`" t)))
    (append (list (car class-item))
            (mapcar #'string-to-number (cdr class-item)))))

(defun ajc-split-class-item-by-class-ln (class-line-number index)
  (ajc-make-class-item
   (ajc-read-line class-line-number
                  (nth index ajc-tag-buffer-list))
   index))

(defun ajc-split-constructor-by-line-num (constructor-line-num)
  (ajc-split-constructor
   (ajc-read-line constructor-line-num
                  (ajc-reload-tag-buffer-maybe))))

(defun ajc-split-field (field-line-string index)
  (when field-line-string
    (let* ((field-item)
           (field-line-string (substring-no-properties field-line-string 1))
           (split-list (split-string field-line-string "`"))
           (return-type (nth 1 split-list)))
      ;; handle field name
      (add-to-list 'field-item (car split-list) t)
      (if (string-match "^~" return-type)
          (add-to-list 'field-item (substring-no-properties return-type 1) t)
        (add-to-list 'field-item (ajc-split-class-item-by-class-ln
                                  (string-to-number return-type) index) t))
      field-item)))

(defun append-space-to-item (str)
  "Insert whitespace between classname and return type."
  (let ((len (length str)))
    (if (< len (- ajc-default-length-of-class 3))
        (setq str
              (concat str
                      (make-string (- (- ajc-default-length-of-class 3)
                                      len)
                                   ;;32 mean whitespace
                                   32)))
      (setq str (concat str "     ")))))

(defun ajc-field-to-string (field-item &optional with-return-type)
  (when field-item
    (if with-return-type
        (let ((field-string (car field-item))
              (return-type (nth 1 field-item)))
          (setq field-string (append-space-to-item field-string))
          (setq field-string (concat field-string ajc-return-type-char))
          (when (stringp return-type)
            (setq field-string (concat field-string return-type)))
          (when (listp return-type)
            (setq field-string (concat field-string (car return-type))))
          field-string)
      (car field-item))))

(defun ajc-method-to-string (method-item &optional with-return-type-and-throws)
  "This is a toString() like function.
When WITH-RETURN-TYPE-AND-THROWS is non nil, it will include
return type and exceptions. By default it only includes method
name and params."
  (when method-item
    (let ((method-string (car method-item))
          (return-type (nth 1 method-item))
          (params (nth 2 method-item))
          (exceptions (nth 3 method-item)))
      (if (stringp params)
          (setq method-string (concat method-string "()"))
        (setq method-string (concat method-string "("))
        (dolist (param params)
          (when (stringp param)
            (setq method-string (concat method-string param ", ")))
          (when (listp param)
            (setq method-string (concat method-string (car param) ", "))))
        (setq method-string
              (replace-regexp-in-string ", $" ")" method-string)))
      (when with-return-type-and-throws
        (setq method-string (append-space-to-item method-string))
        (cond ((stringp return-type)
               (setq method-string (concat method-string ajc-return-type-char return-type)))
              ((listp return-type)
               (setq method-string (concat method-string ajc-return-type-char (car return-type)))))
        (when (listp exceptions)
          (setq method-string (concat method-string ajc-throws-char))
          (dolist (exception exceptions)
            (when (stringp exception)
              (setq method-string (concat method-string exception ", ")))
            (when (listp exception)
              (setq method-string (concat method-string (car exception) ", "))))
          (setq method-string (replace-regexp-in-string ", $" "" method-string))))
      method-string)))

(defun ajc-class-to-string (class-item &optional with-package-name-append)
  (when class-item
    (let* ((class-string (car class-item)))
      (when with-package-name-append
        (setq class-string
              (concat (append-space-to-item class-string)
                      ajc-return-type-char
                      (car (ajc-split-pkg-item-by-pkg-ln (nth 1 class-item)
                                                         (nth 2 class-item))))))
      class-string)))

(defun ajc-method-to-yasnippet-template (method-item)
  (when method-item
    (let ((method-string (car method-item))
          (params (nth 2 method-item))
          (exceptions (nth 3 method-item))
          (index 0))
      (if (stringp params)
          (setq method-string (concat method-string "()"))
        (setq method-string (concat method-string "("))
        (dolist (param params)
          (when (stringp param)
            (setq method-string
                  (concat method-string "${" (number-to-string (+ index 1)) ":"
                          param "}, ")))
          (when (listp param)
            (setq method-string
                  (concat method-string "${" (number-to-string (+ 1 index)) ":"
                          (car param) "}, ")))
          (setq index (1+ index)))
        (setq method-string (replace-regexp-in-string ", $" ")$0" method-string)))
      method-string)))

(defun ajc-method-item-to-candidate (field-or-method-item)
  "Translate FIELD-OR-METHOD-ITEM to
candidate. FIELD-OR-METHOD-ITEM can be a method item, or a field
item."
  (when field-or-method-item
    (let ((candidate))
      (if (= 2 (length field-or-method-item))
          ;; lenth of field is 2 (only field and returntype)
          (let ((field-full-string (ajc-field-to-string field-or-method-item t))
                (field-short-string (ajc-field-to-string field-or-method-item nil)))
            (setq candidate (propertize field-short-string 'view field-full-string)))
        (let ((method-full-string (ajc-method-to-string field-or-method-item t))
              (method-short-string (ajc-method-to-string field-or-method-item nil)))
          ;; this is a method
          (setq candidate
                (propertize method-short-string
                            'view method-full-string
                            'template field-or-method-item
                            'template-type 'method))))
      candidate)))

(defun ajc-split-method (method-line-string index)
  "METHOD-LINE-STRING is as follows:
method-name`~return-type`parameters-type`exceptions.
INDEX is the index in `ajc-tag-buffer-list'."
  (when method-line-string
    (let ((method-item)
          (split-list)
          (return-type))
      (setq split-list (split-string method-line-string "`"))
      ;; handle method name
      (push (car split-list) method-item)
      ;; handle return-type
      (setq return-type (nth 1 split-list))
      (push (if (string-match "^~" return-type)
                (or (ajc-get-class-item-by-fqn
                     (substring-no-properties return-type 1))
                    (substring-no-properties return-type 1))
              ;; return-type is referred by line number
              (ajc-split-class-item-by-class-ln
               (string-to-number return-type) index))
            method-item)
      (append (nreverse method-item)
              ;; handle params if exists
              (ajc-split-items (nth 2 split-list) index)
              ;; handle exceptions
              (ajc-split-items (nth 3 split-list) index)))))

(defun ajc-get-class-item-by-fqn (fqn)
  "Return class-item that matches FQN or nil."
  (when (string-match "\\." fqn)
    (car (ajc-find-out-matched-class-item
          (substring-no-properties fqn 0 (ajc-rindex fqn ?.))
          (substring-no-properties fqn (1+ (ajc-rindex fqn ?.)))
          t))))

(defun ajc-rindex (string char)
  "Return the last index of CHAR in STRING."
  (loop for ch in (nreverse (coerce string 'list))
        for i from (1- (length string)) downto 0
        when (char-equal ch char)
        return i
        finally (return nil)))

(defun ajc-split-constructor (constructor-line-string index)
  (when constructor-line-string
    (let ((split-list
           (split-string
            (substring-no-properties constructor-line-string 2) "`")))
      ;; handle constructor name
      (append (list (car split-list))
              ;; handle params if exists
              (ajc-split-items (nth 1 split-list) index)
              ;; handle exceptions if exists
              (ajc-split-items (nth 2 split-list) index)))))

(defun ajc-split-items (items index)
  "Handle return-type, parameters-type, and exceptions in ITEMS."
  (if (string-equal "" items)
      (list "")
    (let ((elems nil)
          (elem-lst nil))
      (setq elem-lst (split-string items "," t))
      (dolist (e elem-lst)
        (if (string-match "^~" e)
            (setq elems (append elems (list (substring-no-properties e 1))))
          (setq elems (append elems (list (ajc-split-class-item-by-class-ln
                                           (string-to-number e)
                                           index))))))
      (list elems))))

(defun ajc-constructor-to-string (constructor-item &optional is-with-exceptions)
  (when constructor-item
    (let ((constructor-string (car constructor-item))
          (params (nth 1 constructor-item))
          (exceptions (nth 2 constructor-item)))
      (if (stringp params)
          (setq constructor-string (concat constructor-string "()"))
        (progn
          (setq constructor-string (concat constructor-string "("))
          (dolist (param params)
            (when (stringp param)
              (setq constructor-string (concat constructor-string param ", ")))
            (when (listp param)
              (setq constructor-string (concat constructor-string (car param) ", "))))
          (setq constructor-string (replace-regexp-in-string ", $" ")" constructor-string))))
      (when is-with-exceptions
        (when (listp exceptions)
          (setq constructor-string (concat constructor-string ajc-throws-char))
          (dolist (exception exceptions)
            (when (stringp exception)
              (setq constructor-string (concat constructor-string exception ", ")))
            (when (listp exception)
              (setq constructor-string (concat constructor-string (car exception) ", "))))
          (setq constructor-string (replace-regexp-in-string ", $" "" constructor-string))))
      constructor-string)))

(defun ajc-constructor-to-yasnippet-template (constructor-item)
  (when constructor-item
    (let ((constructor-string (car constructor-item))
          (params (nth 1 constructor-item))
          (exceptions (nth 2 constructor-item))
          (index 0))
      (if (stringp params)
          (setq constructor-string (concat constructor-string "()"))
        (setq constructor-string (concat constructor-string "("))
        (dolist (param params)
          (when (stringp param)
            (setq constructor-string
                  (concat constructor-string "${" (number-to-string (+ index 1)) ":"
                          param "}, ")))
          (when (listp param)
            (setq constructor-string (concat constructor-string
                                             "${"
                                             (number-to-string (+ 1 index))
                                             ":"
                                             (car param)
                                             "}, ")))
          (setq index (+ 1 index)))
        (setq constructor-string (replace-regexp-in-string ", $" ")$0" constructor-string)))
      (setq constructor-string constructor-string))))

(defun ajc-get-lines-and-positions (tag-buffer)
  "Return a list, which is like the following.
 (
  (package-first-line . position-of-package-first-line)
  (class-first-line . position-of-class-first-line)
  ((member-first-line . position-of-member-first-line) .
   (member-end-line . position-of-member-end-line))
 )"
  (list (ajc-get-package-line-and-position tag-buffer)
        (ajc-get-class-line-and-position tag-buffer)
        (ajc-get-member-lines-and-positions tag-buffer)))

(defun ajc-get-line-and-position (buffer line-number)
  "Return cons cell of number which is got by reading line at
LINE-NUMBER in BUFFER and position of that line."
  (let ((lnum (string-to-number (ajc-read-line line-number buffer))))
    (cons lnum (ajc-get-position-by-line lnum buffer))))

(defun ajc-get-package-line-and-position (buffer)
  "Return cons cell of (package-first-line . position-of-package-first-line)."
  (ajc-get-line-and-position buffer 3))

(defun ajc-get-class-line-and-position (buffer)
  "Return cons cell of (class-first-line . position-of-class-first-line)."
  (ajc-get-line-and-position buffer 4))

(defun ajc-get-member-lines-and-positions (buffer)
  "Return cons cell of
 ((member-first-line . position-of-member-first-line) .
  (member-end-line . position-of-member-end-line))."
  (cons (ajc-get-line-and-position buffer 5)
        (ajc-get-line-and-position buffer 6)))

(defun ajc-get-position-by-line (line buffer)
  (with-current-buffer buffer
    (goto-char (point-min))
    (forward-line (1- line))
    (point)))

(defun ajc-gen-tag-buffer-name (filename)
  (concat " *"
          (file-name-nondirectory filename)
          "*"))

;; find tag file
(defun ajc-init (&optional force)
  "Find java tag file and do some initial work like setting some
variables."
  (unless (and (not force) ajc-is-running)
    ;; reset global variables
    (setq ajc-tag-buffer-list nil)
    (setq ajc-lines-and-positions-list nil)
    (setq ajc-two-char-tbl nil)
    (setq ajc-package-in-tags-cache-tbl nil)
    (setq ajc-current-class-prefix-4-complete-class nil)
    (setq ajc-matched-class-items-cache nil)
    (setq ajc-previous-class-prefix nil)
    (setq ajc-package-in-tags-cache-tbl nil)
    (setq ajc-plain-method-tables nil)
    ;; extract info from each tag file in ajc-tag-file-list
    (mapcar (lambda (filename)
              (ajc-init-1 filename))
            ajc-tag-file-list)
    (setq ajc-two-char-tbl (ajc-sort-class ajc-tag-buffer-list))
    (setq ajc-package-in-tags-cache-tbl
          (ajc-build-package-in-tags-cache-tbl ajc-tag-buffer-list))
    (ajc-init-plain-method-tables force)
    (setq ajc-is-running t)))

(defun ajc-init-1 (filename)
  (let ((fname (file-truename (expand-file-name filename)))
        (bname nil))
    (if (file-exists-p fname)
        (with-current-buffer (find-file-noselect fname)
          ;; a buffer name starts with empth string,means hidden this buffer
          (rename-buffer (ajc-gen-tag-buffer-name fname))
          (setq bname (ajc-gen-tag-buffer-name fname))
          (add-to-list 'ajc-tag-buffer-list (get-buffer bname) t)
          (buffer-disable-undo)
          (setq buffer-read-only t)
          (fundamental-mode)
          (setq case-fold-search nil)
          (add-to-list 'ajc-lines-and-positions-list
                       (ajc-get-lines-and-positions (get-buffer bname))
                       t))
      (message (format "warning: tag file %s cannot be found" fname)))))

(defun ajc-init-plain-method-tables (&optional force)
  (when ajc-use-plain-method-completion
    (ajc-load-or-build-plain-method-tables force)
    (ajc-save-method-tables-cache)
    (add-to-list 'ac-sources 'ac-source-ajc-plain-method)))

(defun ajc-build-package-in-tags-cache-tbl (tag-buffer-list)
  "Return a hash table of package names in each tag buffer in TAG-BUFFER-LIST.
Key is package name and value is `t' if that package name is in a
tag file."
  (loop for tag-buf in tag-buffer-list
        for i from 0
        with ret = (make-hash-table :test #'equal)
        do (with-current-buffer tag-buf
             (goto-char (point-min))
             (forward-line (1- (ajc-get-package-first-line i ajc-lines-and-positions-list)))
             (beginning-of-line)
             (while (re-search-forward
                     "^\\([A-Za-z0-9_.]+\\)`"
                     (save-excursion
                       (ajc-goto-line
                        (ajc-get-class-first-line i
                                                  ajc-lines-and-positions-list))
                       (beginning-of-line)
                       (point))
                     t)
               (puthash (match-string-no-properties 1) t ret)))
        finally (return ret)))

(defun ajc-load-tag-file (filename)
  "Load tag file FILENAME.
The next completion is done with the current tag files and
FILENAME."
  (interactive "fTag file: ")
  (let ((file (file-truename (expand-file-name filename))))
    (when (and (file-exists-p file)
               (not (member file ajc-tag-file-list)))
      (push file ajc-tag-file-list)
      (ajc-init t)
      (push (or (ajc-load-method-table-cache file 0)
                (ajc-build-plain-method-table-1
                 (make-hash-table :test #'equal)
                 (car ajc-tag-buffer-list)
                 0))
            ajc-plain-method-tables))))

(defun ajc-unload-tag-file (filename)
  "Unload tag file FILENAME.
The next completion is done without tag file FILENAME."
  ;; We don't let a user unload a tag file if there is only one.
  (interactive (list (if (< (length ajc-tag-file-list) 2)
                         ""
                       (completing-read
                        "Tag file to unload: "
                        ajc-tag-file-list))))
  (when (> (length ajc-tag-file-list) 1)
    ;; let a user choose which tag file to unload
    (let* ((ix (position filename ajc-tag-file-list :test #'string=))
           (tag-buffer (nth ix ajc-tag-buffer-list))
           (sorted-class-buffer (get-buffer (nth ix ajc-sorted-class-buffer-name-list))))
      (and filename
           (setq ajc-plain-method-tables
                 (delete (nth ix ajc-plain-method-tables)
                         ajc-plain-method-tables))
           (kill-buffer tag-buffer)
           (kill-buffer sorted-class-buffer)
           (setq ajc-tag-file-list
                 (delete filename ajc-tag-file-list))
           (ajc-init t)))))

(defun ajc-update-tag-file (filename)
  "Update completion info from updated ajc tag file FILENAME."
  (interactive (list (completing-read "Updated tag file: "
                                      ajc-tag-file-list
                                      nil
                                      t)))
  (and (stringp filename)
       (ajc-init t)))

(defun ajc-build-plain-method-table (tag-buffer-list)
  (loop for tag-buffer in tag-buffer-list
        for ix from 0
        for table = (make-hash-table :test #'equal)
        collect (progn
                  (ajc-build-plain-method-table-1 table tag-buffer ix)
                  (loop for k being the hash-keys in table
                       for val = (gethash k table)
                       do (puthash k
                                   (sort val
                                         #'string<)
                                   table)
                       finally (return table)))))

(defun ajc-build-plain-method-table-1 (table tag-buffer index)
  "Insert method-items in TAG-BUFFER into TABLE."
  (let ((case-fold-search nil))
    (with-current-buffer tag-buffer
      (let ((reporter nil))
        (setq buffer-read-only t)
        (goto-char (point-min))
        ;; Move to the first line of members
        (forward-line (string-to-number
                       (save-excursion
                         (ajc-read-line 5 tag-buffer))))
        (beginning-of-line)
        (setq reporter (make-progress-reporter
                        (format "Building table from %s..."
                                (file-name-nondirectory (nth index ajc-tag-file-list)))
                        (point)
                        (point-max)))
        (while (re-search-forward "^[a-z].*$" nil t)
          (let* ((val (match-string-no-properties 0))
                 (key (substring val 0 3))
                 (hashvalue (gethash key table)))
            (add-to-list 'hashvalue
                         (save-excursion
                           (ajc-method-item-to-candidate
                            (ajc-split-method val index))))
            (puthash key hashvalue table)
            (progress-reporter-update reporter (point))))
        (progress-reporter-done reporter)))
    table))

(defun ajc-save-method-table-cache (tag-filename index)
  "Save method hash table corresponding to TAG-FILENAME into cache."
  (multiple-value-bind (filename pathname)
      (ajc-construct-cache-filepath tag-filename)
    (let ((table (nth index ajc-plain-method-tables)))
      (unless (file-directory-p ajc-method-table-cache-dir)
        (make-directory (expand-file-name ajc-method-table-cache-dir)))
      (cond
       ((file-exists-p pathname)
        (when (time-less-p (nth 5 (file-attributes pathname))
                           (nth 5 (file-attributes (expand-file-name tag-filename))))
          ;; if cache file is older than tag file, we update cache
          (with-temp-file pathname
            (let ((print-circle t))
              (prin1 table (current-buffer))))))
       ((file-directory-p ajc-method-table-cache-dir)
          (with-temp-file pathname
            (let ((print-circle t))
              (prin1 table (current-buffer)))))
       (t
        (message "ajc-write-method-table-cache, cache dir doesnt exist"))))))

(defun ajc-load-method-table-cache (tag-filename index)
  "Load and return a hash table from cache file if exists.
Otherwise return nil."
  (multiple-value-bind (filename pathname)
      (ajc-construct-cache-filepath tag-filename)
    (when (and (file-exists-p pathname)
               (time-less-p (nth 5 (file-attributes (expand-file-name tag-filename)))
                            (nth 5 (file-attributes (expand-file-name pathname)))))
      ;; Load from cache When it exists and its modification time is
      ;; newer than that of tag file.
      (let* ((table nil))
          (with-current-buffer (find-file-noselect pathname)
            (goto-char (point-min))
            (message "Loading cache from %s..." pathname)
            (setq table (read (current-buffer)))
            (kill-buffer))
          (message "Loading cache from %s...done" pathname)
          table))))

(defun ajc-construct-cache-filepath (tag-filename)
  "Return cache file name and its full pathname."
  (let* ((filename (ajc-get-cache-filename tag-filename))
         (full-pathname
          (expand-file-name
           (concat (directory-file-name ajc-method-table-cache-dir)
                   "/"
                   filename))))
    (values filename full-pathname)))

(defun ajc-get-cache-filename (tag-filename)
  "Return cache filename for TAG-FILENAME. Returned filename is
NOT an absolute pathname."
  (concat (file-name-sans-extension
           (file-name-nondirectory
            tag-filename))
          ".ajc.cache"))

(defun ajc-load-or-build-plain-method-tables (&optional force)
  "Load table from cache if exist or build one otherwise."
  (when (or force
            (and ajc-use-plain-method-completion
                 (null ajc-plain-method-tables)))
    (setq ajc-plain-method-tables nil)
    ;; Iterate from the last so that we don't have to reverse the
    ;; result.
    (loop for ix from (1- (length ajc-tag-file-list)) downto 0
          for tag-filename in (reverse ajc-tag-file-list)
          do (push (or (ajc-load-method-table-cache tag-filename ix)
                       (ajc-build-plain-method-table-1
                        (make-hash-table :test #'equal)
                        (nth ix ajc-tag-buffer-list)
                        ix))
                   ajc-plain-method-tables))))

(defun ajc-save-method-tables-cache ()
  "Save each hash table in TABLES into cache."
  (loop for i from 0 below (length ajc-tag-file-list)
        for tag-filename in ajc-tag-file-list
        do (ajc-save-method-table-cache tag-filename i)))

;;;###autoload
(defun ajc-reload ()
  "Restart Auto Java Complete. When your tag file has changed,
you can use this function to restart AutoJavaComplete."
  (interactive)
  (setq ajc-is-running nil)
  (ajc-init))
;;;###autoload
(defalias 'auto-java-complete-reload 'ajc-reload)

(defun ajc-reload-tag-buffer-maybe (&optional buffer)
  "Check if `ajc-tag-buffer-name' is still alive. If not, reload it."
  (unless (or buffer ajc-tag-buffer-name)
    (ajc-init))
  (or buffer ajc-tag-buffer-name))

(defun ajc-find-out-matched-pkg-item (pkg-prefix &optional exactly_match buffer)
  "Find out all matched packages whose prefix is `pkg-prefix'.
For example, (ajc-find-out-matched-pkg-item \"javax.xm\") should
return ((\"javax.xml.bind\" 2741 2767) (\"javax.xml.bind.attachment\" 2776 2778)).
If EXACTLY_MATCH is non nil, then PKG-PREFIX will be seen as full
package name, and we will suppose you are searching for a package name
that is PKG-PREFIX. If exactly_match is non nil, then one or zero item
will be returned. So we will try to convert '((packageName 12 33 )) to
'(packageName 12 33 )."
  (loop for buf in ajc-tag-buffer-list
        for i from 0
        with ret = nil
        with l = nil
        ;; TODO we have to deal with the case where the number of
        ;; exactly-matched package items is more than 1.
        append (with-current-buffer buf
                 (let ((regexp-pkg-prefix (concat "^" (regexp-quote pkg-prefix)))
                       (matched-packages nil))
                   (when exactly_match ;; I use ` char as the separator in tag file
                     (setq regexp-pkg-prefix (concat "^" (regexp-quote pkg-prefix) "`")))
                   (goto-char (ajc-get-package-first-line-position
                               i ajc-lines-and-positions-list))
                   (while (re-search-forward
                           regexp-pkg-prefix
                           (ajc-get-class-first-line-position i ajc-lines-and-positions-list)
                           t)
                     (add-to-list 'matched-packages
                                  (ajc-make-package-item
                                   (buffer-substring-no-properties (line-beginning-position)
                                                                   (line-end-position))
                                   i)))
                   matched-packages))))

(defun ajc-make-package-item (line index)
  (let ((l (ajc-split-pkg-item line)))
    (append (list (car l) index) (cdr l))))

;; (ajc-shrunk-matched-pkgs "java.aw") == java.awt
(defun ajc-shrunk-matched-pkgs (pkg-prefix)
  "Return a list of packages whose name begins with PKG-PREFIX.
When you import a package at the head of your java source file,
and when you type in 'jav-|-', then it will list 'java javax'
instead of 'java.lang java.lang.rel javax.xml javax.xml.ws'."
  (let ((matched-pkg-items (ajc-find-out-matched-pkg-item pkg-prefix))
        (index-of-first-dot 0)
        (return-list)
        (length-of-pkg-prefix (length pkg-prefix)))
    (dolist (current-item matched-pkg-items)
      (if (setq index-of-first-dot
                (string-match "\\." (car current-item) length-of-pkg-prefix))
          (add-to-list 'return-list (substring-no-properties
                                     (car current-item) 0 index-of-first-dot))
        (add-to-list 'return-list (car current-item))))
    return-list))

(defun ajc-find-class-first-check-imported (class-name)
  "Return class-item that matches CLASS-NAME.
If it cannot find it from imported classes, then find from the
tag file. If there are more than one class item matching
CLASS-NAME in tag file, import one of them first."
  (cond
   ((string-match ".*\\[\\]$" class-name)
    ;; TODO how to deal with arrays?
    nil)
   (t
    (let* ((imported-classes (ajc-calculate-all-imported-class-items))
           (matched-class-item
            (catch 'found
              (dolist (item imported-classes)
                (when (string-equal class-name (car item))
                  (throw 'found item))))))
      (unless matched-class-item
        ;; if not found from imported section
        (let ((matched-class-items
               (ajc-find-out-matched-class-item-without-package-prefix class-name t)))
          ;;(message "Debug: class-name=%s, matched-class-items=%s" class-name matched-class-items)
          (when matched-class-items
            (if (= (length matched-class-items) 1)
                (setq matched-class-item (car matched-class-items))
              (setq matched-class-item
                    (car matched-class-items))))))
      ;;(message "Debug: class-name=%s, matched-class-item=%s" class-name matched-class-item)
      matched-class-item))))

(defun ajc-find-out-matched-class-item
  (package-name class-prefix &optional exactly_match)
  "Find out all classes which start with CLASS-PREFIX, and whose
package name is PACKAGE-NAME. If PACKAGE-NAME is nil, then try to
find out all classes whose classnames start with CLASS-PREFIX. If
CLASS-PREFIX is nil or empty string, it will try to find out all
classes in package PACKAGE-NAME. If both PACKAGE-NAME and
CLASS-PREFIX are nil, then return nil. EXACTLY_MATCH means that
only class name which exactly matches CLASS-PREFIX will be
returned."
  (let* ((class-prefix (or class-prefix ""))
         (regexp-class-prefix
          (if exactly_match
              (concat "^" (regexp-quote class-prefix) "`")
            (concat "^" (regexp-quote class-prefix))))
         (matched-pkg-items (and package-name (ajc-find-out-matched-pkg-item package-name t))))
    (cond
     ((and (> (length class-prefix) 0) (not package-name))
      ;; case where package-name is null and class-prefix is specified
      (ajc-find-out-matched-class-item-without-package-prefix class-prefix exactly_match))
     (matched-pkg-items
      (loop for matched-pkg-item in matched-pkg-items
            for index = (nth 1 matched-pkg-item)
            for line-num = (nth 2 matched-pkg-item)
            for end-line = (nth 3 matched-pkg-item)
            with current-line-string = nil
            with return-list = nil
            ;; (message "Debug: package-name=%s, matched-pkg-item=%s, class-prefix=%s"
            ;;          package-name
            ;;          matched-pkg-item
            ;;          class-prefix)
            do (with-current-buffer (nth (nth 1 matched-pkg-item) ajc-tag-buffer-list)
                 ;; package-item is of form (pkgname index start-line end-line)
                 ;; We only need to search for classes whose package name is in tags file.
                 (when (gethash package-name ajc-package-in-tags-cache-tbl)
                   (while (< line-num end-line)
                     (setq current-line-string (ajc-read-line line-num))
                     (when (string-match regexp-class-prefix current-line-string)
                       (push (ajc-make-class-item current-line-string (nth 1 matched-pkg-item))
                             return-list))
                     (incf line-num))))
            finally (return (nreverse return-list))))
     (t
      nil))))

(defun ajc-make-class-item (line-string index)
  "Return class item of form (classname index start-line end-line) by splitting LINE-STRING."
  (let ((l (ajc-split-class-item line-string)))
    (append (list (car l) index) (cdr l))))

;;(ajc-sort-class)
;;(ajc-get-two-char-item "Sy")
(defun ajc-get-two-char-item (two-char-string)
  (gethash two-char-string ajc-two-char-tbl))

;;(ajc-find-out-matched-class-item-without-package-prefix "System" t)
;; (ajc-find-out-matched-class-item-without-package-prefix "_ServantLocatorStub")
(defun ajc-find-out-matched-class-item-without-package-prefix
  (class-prefix &optional exactly_match)
  "Return class-items that begin with CLASS-PREFIX."
  (loop for i from 0 below (length ajc-sorted-class-buffer-name-list)
        append (ajc-find-out-matched-class-item-without-package-prefix-1
                class-prefix i exactly_match)))

(defun ajc-find-out-matched-class-item-without-package-prefix-1
  (class-prefix index &optional exactly_match)
  (with-current-buffer (nth index ajc-sorted-class-buffer-name-list)
    (let ((matched-class-items nil)
          (case-fold-search nil)
          (regexp-class-prefix (if exactly_match
                                   (concat "^" class-prefix "`")
                                 (concat "^" class-prefix)))
          (two-char-item
           (assoc index
                  (or (and (> (length class-prefix) 1)
                           (ajc-get-two-char-item (substring-no-properties class-prefix 0 2)))
                      `((,index ,(point-min) ,(point-max)))))))
      (when two-char-item
        (goto-char (nth 1 two-char-item))
        (while (re-search-forward regexp-class-prefix (nth 2 two-char-item) t)
          (push (ajc-make-class-item (buffer-substring-no-properties
                                      (line-beginning-position) (line-end-position))
                                     index)
                matched-class-items)))
      (nreverse matched-class-items))))

(defun ajc-sort-class (tag-buffer-list)
  "Sort class part of tag-buffer in another buffer, and return a
hash table mapping two-char to two-char-item. Also set
`ajc-sorted-class-buffer-name-list'."
  (loop with tbl = (make-hash-table :test #'equal)
        for buf in tag-buffer-list
        for i from 0
        for class-bname = (ajc-make-sorted-class-buffer-name (buffer-name buf))
        with sorted-class-buffer-list = nil
        do (setq tbl (ajc-sort-class-1 i
                                       class-bname
                                       buf
                                       tbl))
        do (push class-bname sorted-class-buffer-list)
        finally (progn (setq ajc-sorted-class-buffer-name-list
                             (nreverse sorted-class-buffer-list))
                       (return tbl))))

(defun ajc-make-sorted-class-buffer-name (buffer-name)
  (concat " *sorted-class-" (substring-no-properties buffer-name 2)))

(defun ajc-sort-class-1 (ix class-buffer-name tag-buffer two-char-item-tbl)
  "Sort in buffer CLASS-BUFFER-NAME class-items in TAG-BUFFER, and
return the resultant TWO-CHAR-ITEM-TBL.

IX is an index of TAG-BUFFER in
`ajc-tag-buffer-list'. CLASS-BUFFER-NAME is the name of buffer
containing sorted class-items. two-char-item-tbl is a hash
table."
  (let ((case-fold-search nil))
    (with-current-buffer (get-buffer-create class-buffer-name)
      (erase-buffer)
      ;; insert class part of tag-buffer
      (insert (ajc-get-class-part ix tag-buffer))
      (sort-lines nil 1 (point-max))
      (let ((end ?Z) (index ?A) (index2 ?A) (two-char)
            (two-char-item) (next-start-search-postion))
        (setq ajc-two-char-list nil)
        (while (<= index end)
          (setq index2 ?A)
          (while (<= index2 ?z)
            (setq two-char (concat (char-to-string index) (char-to-string index2)))
            (setq two-char-item
                  (ajc-create-two-char-item
                   two-char class-buffer-name (or next-start-search-postion 1) ix))
            (if two-char-item
                (puthash two-char
                         (push two-char-item
                               (gethash two-char two-char-item-tbl nil))
                         two-char-item-tbl)
              (setq next-start-search-postion (nth 2 two-char-item)))
            (if (= index2 ?Z) (setq index2 ?a) (setq index2 (+ index2 1))))
          (setq index (+ index 1)))))
    two-char-item-tbl))

(defun ajc-get-class-part (ix tag-buffer)
  (with-current-buffer tag-buffer
    (buffer-substring-no-properties
     (ajc-get-class-first-line-position ix ajc-lines-and-positions-list)
     (ajc-get-member-first-line-position ix ajc-lines-and-positions-list))))

(defun ajc-create-two-char-item (two-char-prefix
                                 class-buffer-name
                                 start-search-postion
                                 index)
  "Return a list of form (two-char-prefix start end): start is
the position where a classname which begins with TWO-CHAR-PREFIX
is first found, and end is the position where classnames are no
longer found. Suppose TWO-CHAR-PREFIX is 'Ab' and
`ajc-tmp-sorted-class-buffer-name' is the buffer. All lines in
this buffer are alphabetically-sorted classnames. These are cut
from tag file between `ajc-class-first-ln' and
`ajc-member-first-ln', and sorted by `sort-lines' This function
tries to find out classnames which begin with TWO-CHAR-PREFIX,
get the start position and end position, and record them in a
list. When searching for a classname which begin with
two-char-prefix, we just need to do search from the start
position to the end position. This is faster than directly
searching in the unsorted tag buffer file."
  (with-current-buffer class-buffer-name
    (goto-char start-search-postion)
    (let ((char1 (string-to-char (substring-no-properties two-char-prefix 0 1)))
          (char2 (string-to-char (substring-no-properties two-char-prefix 1 2)))
          (case-fold-search nil)
          start end has-found-first return-item end-position end-prefix-regexp)
      (when (or (= char1 ?Z) (= char2 ?z) (= char2 ?Z))
        (setq end-position (line-number-at-pos (point-max)))
        (if (< char2 ?a)
            (setq end-prefix-regexp (concat "^" (char-to-string char1)
                                            "[a-z"
                                            (char-to-string (+ 1 char2)) "-Z]\\|^"
                                            (char-to-string (+ char1 1)) "[a-zA-Z]"))
          (setq end-prefix-regexp (concat "^" (char-to-string char1)
                                          "[" (char-to-string (+ 1 char2))
                                          "-z]\\|^" (char-to-string (+ char1 1)) "[a-zA-Z]")))
        (goto-char start-search-postion)
        (if (re-search-forward end-prefix-regexp (point-max) t)
            (setq end-position (point))
          (setq end-position (point-max))))
      (goto-char start-search-postion)
      (while (re-search-forward (concat "^" two-char-prefix) end-position t)
        (when (not has-found-first)
          (setq has-found-first t)
          (setq start (line-beginning-position)))
        (setq end (line-end-position)))
      (when (numberp start)
        (setq return-item (list index start end)))
      return-item)))

(defun ajc-import-package-candidates ()
  "Return package candidates.
This should return, for example, (\"java.lang\" \"java.ref\")."
  (save-excursion
    (let ((prefix-string nil)
          (matched-pkg-strings nil)
          (case-fold-search nil))
      (when
          ;; search for import string in java file or jsp file. Now support jsp
          (re-search-backward
           (concat
            "\\(?:import=\"\\(?:.*[ \t\n]*,[ \t\n]*\\)*\\)" ; for jsp
            "\\|"
            "\\(^import[ \t]+\\)\\(static[ \t]\\)?"         ; for java
            "\\([a-zA-Z0-9_\\.]+\\)"
            )
           nil t)
        (setq prefix-string (match-string-no-properties 3))
        (when (and ajc-matched-import-cache-list
                   (stringp prefix-string)
                   (string-match (concat "^" ajc-previous-matched-import-prefix) prefix-string))
          (setq matched-pkg-strings (all-completions prefix-string ajc-matched-import-cache-list)))
        (when (zerop (length matched-pkg-strings))
          ;;(message "Debug: prefix-string=%s" prefix-string)
          ;; first try completion from cache
          (setq matched-pkg-strings (ajc-package-candidates prefix-string))
          (unless (zerop (length matched-pkg-strings))
            ;; when found matched names, we set global variable
            (setq ajc-previous-matched-import-prefix prefix-string)
            (setq ajc-matched-import-cache-list matched-pkg-strings))))
      matched-pkg-strings)))

(defun ajc-package-candidates (prefix-string)
  "Retrun a list of fully-qualified package names which begin
with PREFIX-STRING."
  (let ((ret nil)
        (case-fold-search nil))
    ;;(message "DEBUG: ajc-package-candidates called with prefix=%s" prefix-string)
    ;; add packages
    (setq ret (ajc-shrunk-matched-pkgs prefix-string))
    (let ((index_of_last_dot (string-match "\\.[a-zA-Z_0-9]*$" prefix-string))
          (package-prefix nil)
          (class-prefix nil))
      ;; add classes
      (when index_of_last_dot
        (setq package-prefix (substring-no-properties prefix-string 0 index_of_last_dot))
        (setq class-prefix (substring-no-properties prefix-string (+ 1 index_of_last_dot)))
        (dolist (element (ajc-find-out-matched-class-item package-prefix class-prefix))
          (push (concat package-prefix "." (car element)) ret))))
    ret))

(defun ajc-fqn-candidates ()
  "Return candidates for FQN like prefix."
  ;;(message "DEBUG: ajc-fqn-candidates, ac-prefix=%s" ac-prefix)
  (let ((ret nil))
    (when (and ac-prefix (string-match "^[a-zA-Z][a-zA-Z0-9._]+" ac-prefix))
      (or (ajc-package-candidates ac-prefix)
          (mapcar (lambda (e)
                    ;; e is a non-fqn name,
                    ;; i.e. "assertTrue" not "org.junit.Assert.assertThat"
                    (let ((cand (concat
                                 (replace-regexp-in-string "[^.]+\\.\\([^.]+\\)$"
                                                           ""
                                                           ac-prefix
                                                           nil
                                                           nil
                                                           1)
                                 e)))
                      (set-text-properties 0 (length cand) (text-properties-at 0 e) cand)
                      (add-text-properties 0 (length cand) '(fqn t) cand)
                      cand))
                  (mapcar #'ajc-method-item-to-candidate
                          (ajc-fqn-candidates-1 ac-prefix)))))))

(defun ajc-fqn-candidates-1 (prefix)
  "Return candidates which begin with PREFIX.

For example, if PREFIX is \"java.lang.Math.P\", then this should
return \"PI\"."
  ;; (message "DEBUG: ajc-fqn-candidates-1, prefix=%s" prefix)
  ;; We assume the word before the last dot is class name, so we
  ;; search for members of that class.
  (let* ((package-name
          (and prefix
               (string-match "\\(.*\\)\\.\\([A-Z][a-zA-Z_0-9]+\\)\\.\\([^.]*\\)$"
                             prefix)
               (match-string-no-properties 1 prefix)))
         (class-name (and prefix
                          (match-string-no-properties 2 prefix)))
         (member-prefix (and prefix
                             (match-string-no-properties 3 prefix)))
         (class-item (car (and package-name
                               class-name
                               (ajc-find-out-matched-class-item
                                package-name
                                class-name
                                t)))))
    (unless class-item
      (when (string-match "[A-Z][a-zA-Z_0-9]+\\.class\\.\\([^.]*\\)" prefix)
        ;; PREFIX is like "SomeClass.class.", so we use the class-item
        ;; of java.lang.Class
        (setq class-item (car (ajc-find-out-matched-class-item "java.lang" "Class" t))
              member-prefix (match-string-no-properties 1 prefix))))
    ;; (message "DEBUG: ajc-fqn-candidates-1, prefix=%s" prefix)
    ;; (message "DEBUG: ajc-fqn-candidates-1, package-name=%s" package-name)
    ;; (message "DEBUG: ajc-fqn-candidates-1, class-name=%s" class-name)
    ;; (message "DEBUG: ajc-fqn-candidates-1, member-prefix=%s" member-prefix)
    (and class-item
         (ajc-find-members class-item member-prefix))))

(defun ajc-find-out-class-by-parse-source ()
  "Find out class in current java source file, then import them if
they haven't been imported."
  (save-excursion
    (save-match-data
      (let ((matched-class-strings)
            (case-fold-search nil)
            (return-type-regexp "\\(\\([a-zA-Z0-9_]\\| *\t*< *\t*\\| *\t*>\\| *\t*, *\t*\\| *\t*\\[ *\t*]\\)+\\)")
            ;; a list of split char like ", \t<>[]"
            (split-char-regexp "\\(,\\|<\\|>\\|]\\|\\[\\| \\|\t\\|\n\\)"))
        (goto-char (point-min))
        ;; search for `new' statements
        (while (search-forward-regexp (concat "\\bnew[ \t]+" return-type-regexp) (point-max) 't)
          (setq matched-class-strings
                (append matched-class-strings
                        (split-string (match-string-no-properties 1) split-char-regexp t))))
        (goto-char (point-min))
        ;; search for static members
        (while (search-forward-regexp "\\b\\([A-Z][a-zA-Z0-9_]*\\)\\.[a-zA-Z0-9_]+[ \t]*(?"
                                      (point-max)
                                      't)
          (setq matched-class-strings
                (append matched-class-strings
                        (list (match-string-no-properties 1)))))
        (goto-char (point-min))
        ;; search for classes being instantiated by getInstace
        (while (search-forward-regexp "\\([a-zA-Z0-9_]+\\)\\.getInstance[ \t]*(" (point-max) 't)
          (add-to-list 'matched-class-strings (match-string-no-properties 1)))
        (goto-char (point-min))
        ;; find out all statements of variable, for example
        ;; String name;      Map<String,<String,Ojbect>>[] map=
        (while (search-forward-regexp
                (concat
                 "^[ \t]*"
                 "(?"
                 "\\(public\\|private\\|static\\|final\\|native\\|synchronized\\|"
                 "transient\\|volatile\\|strictfp\\| \\|\t\\)*"
                 ;; type name
                 "\\([A-Z][a-zA-Z0-9_]+"
                 ;; type parameters
                 "\\(<[^;=()]+>\\)?"
                 ;; square brackets for array type
                 "\\(\\[]\\)*"
                 "\\)"
                 "[ \t]+"
                 ;; variable name
                 "\\([a-zA-Z0-9_]+[, ;=]+\\)+")
                (point-max)
                't)
          (setq matched-class-strings
                (append matched-class-strings
                        (split-string (match-string-no-properties 2) split-char-regexp t))))
        (goto-char (point-min))
        ;; search for parenthesized type names, i.e.,
        ;; search for `Iterator' in `for (Iterator<Elt> i = _var.iterator(); ...)'
        (while (search-forward-regexp
                (concat
                 "("
                 ;; type name
                 "\\([A-Z][a-zA-Z0-9_]+"
                 ;; type parameters
                 "\\(<[^;=()]+>\\)?"
                 ;; square brackets for array type
                 "\\(\\[]\\)*"
                 "\\)"
                 "[ \t]+"
                 ;; variable name
                 "\\([a-zA-Z0-9_]+[, ;=]+\\)+")
                (point-max)
                't)
          (setq matched-class-strings
                (append matched-class-strings
                        (split-string (match-string-no-properties 1) split-char-regexp t))))
        (goto-char (point-min))
        ;; find ClassName after "catch" keywords  for example :catch(IOException e)
        (while (search-forward-regexp "catch[ \t]*(\\([a-zA-Z0-9_]+\\)[ \t]+" (point-max) 't)
          (add-to-list 'matched-class-strings (match-string-no-properties 1)))
        (goto-char (point-min))
        ;; find method statement
        (while (search-forward-regexp
                (concat "^[ \t]*"
                        "\\(public\\|protected\\|private\\|static\\|final"
                        "\\|native\\|synchronized\\|transient\\|volatile"
                        "\\|strictfp\\| \\|\t\\)*"
                        "[ \t]+"
                        ;; return type
                        "\\(\\([a-zA-Z0-9_]\\|\\( *\t*< *\t*\\)"
                        "\\|\\( *\t*> *\t*\\)\\|\\( *\t*, *\t*\\)"
                        "\\|\\( *\t*\\[ *\t*\\)\\|\\(]\\)\\)+\\)"
                        ;; method name and parameters
                        "[ \t\n\r]+[a-zA-Z0-9_]+[ \t]*(\\([^)]*\\))"
                        "[ \t\n\r]*"
                        "\\(throws[ \t]+\\([a-zA-Z0-9_, \t\n]*\\)\\)?"
                        "[ \t\n]*[{;]"
                        )
                        (point-max)
                        't)
          (let ((exception (match-string-no-properties 11))
                (returns (match-string-no-properties 2))
                (params (match-string-no-properties 9)))
            ;; handle return type
            (setq matched-class-strings
                  (append matched-class-strings
                          (split-string returns "\\(,\\|<\\|>\\|]\\|\\[\\| \\|\t\\)" t)))
            ;; handle methods parameters
            ;; find out 'Map String Ojbect User' from "Map<String,Object> map,User user"
            (when (stringp params)
              (nconc matched-class-strings
                     (ajc-parse-param-string params)))
            ;; handle throws Exception1,Exception2,
            ;; we will exatract Exception1 Exception2 from throws sentence
            (when exception
              (setq matched-class-strings
                    (append matched-class-strings
                            (split-string exception split-char-regexp t))))))
        ;; search for interfaces
        (setq matched-class-strings
              (append matched-class-strings
                      (ajc-find-out-implemented-interfaces)))
        ;; search for annotation like @Test
        (setq matched-class-strings
              (append matched-class-strings
                      (ajc-find-out-class-by-annotation)))
        ;; search for .class notation, i.e. "java.util.Vector.class" and etc.
        (setq matched-class-strings
              (append matched-class-strings
                      (ajc-find-out-class-by-dot-class-notation)))
        ;; search for extends Classname
        (setq matched-class-strings
              (append matched-class-strings
                      (ajc-find-out-class-by-extends-notation)))
        ;; search for classname used in cast
        (setq matched-class-strings
              (append matched-class-strings
                      (ajc-find-out-class-by-cast-notation)))
        ;; remove primitive type and remove duplicate item
        (delete-dups matched-class-strings)
        (setq matched-class-strings (delete "" matched-class-strings))
        (setq matched-class-strings
              (remove-if
               (lambda (ele)
                 (string-match "^\\(int\\|float\\|double\\|long\\|short\\|char\\|byte\\|void\\|boolean\\|return\\|public\\|static\\|private\\|protected\\|abstract\\|final\\|native\\|package\\|new\\)$" ele))
               matched-class-strings))
        matched-class-strings))))

(defun ajc-parse-param-string (string)
  "Parse method-parameter STRING and return a list of class names in STRING.
Ignore primitive types and fully-qualified class names."
  (let ((case-fold-search nil))
    (remove-if-not (lambda (elt) (string-match "^[A-Z]" elt))
                   (split-string string "[][,<> ]" t))))

(defun ajc-find-out-class-by-cast-notation ()
  "Find out class names used in cast statements."
  (let ((case-fold-search nil)
        (cast-regexp "(\\([A-Z][A-Za-z0-9_<>]+\\))")
        (ret nil))
    (save-excursion
      (save-match-data
        (goto-char (point-min))
        (while (re-search-forward cast-regexp nil t)
          (setq ret
                (append (split-string (match-string-no-properties 1)
                                      "[,<> \t\n\r]+" t)
                        ret)))))
    ret))

(defun ajc-find-out-implemented-interfaces ()
  (let ((case-fold-search nil)
        (intf-regexp (concat "\\b[A-Z][A-Za-z0-9_]+" ; class name
                             "[ \t\n\r]+"
                             "implements"
                             "[ \t\n\r]+"
                             "\\([A-Z][A-Za-z0-9_<>, \t\n\r]+\\)" ; interface name
                             "{"
                             ))
        (ret nil))
    (save-excursion
      (save-match-data
        (goto-char (point-min))
        (while (re-search-forward intf-regexp nil t)
          (setq ret
                (append (split-string (match-string-no-properties 1)
                                      "[,<> \t\n\r]+" t)
                        ret)))))
    ret))

(defun ajc-find-out-class-by-extends-notation ()
  (let ((extends-class-regexp "extends[[:space:][:punct:]]\\([[:upper:]][[:alpha:]]+\\)\\b")
        (classes nil)
        (case-fold-search nil))
    (save-excursion
      (save-match-data
        (goto-char (point-min))
        (while (re-search-forward extends-class-regexp nil t)
          (push (match-string-no-properties 1) classes))))
    classes))

(defun ajc-find-out-class-by-dot-class-notation ()
  (let ((dot-class-regexp "[[:space:][:punct:]]\\([[:upper:]][[:alpha:]]+\\)\\.class\\b")
        (classes nil)
        (case-fold-search nil))
    (save-excursion
      (save-match-data
        (goto-char (point-min))
        (while (re-search-forward dot-class-regexp nil t)
          (push (match-string-no-properties 1) classes))))
    classes))

(defun ajc-find-out-class-by-annotation ()
  "Find out annotations and return a list of annotations."
  (let ((annot-regexp "[:space:]*@\\([A-Z][a-zA-Z]+\\)")
        (annotations nil)
        (case-fold-search nil))
    (save-excursion
      (save-match-data
        (goto-char (point-min))
        (while (re-search-forward annot-regexp nil t)
          (push (match-string-no-properties 1) annotations))))
    annotations))

(defun ajc-calculate-all-unimported-class-items ()
  "Find out all unimported Class itmes.
It just do subtraction:
 (ajc-find-out-class-by-parse-source) - (ajc-calculate-all-imported-class-items).
What you need to do next is just import the unimported classes."
  (let ((imported-class-names (mapcar 'car (ajc-calculate-all-imported-class-items)))
        (class-names-in-source (ajc-find-out-class-by-parse-source))
        (unimported-class-items))
    (print class-names-in-source)
    (dolist (ele class-names-in-source)
      (unless (member ele imported-class-names)
        (setq unimported-class-items
              (append unimported-class-items
                      (ajc-find-out-matched-class-item-without-package-prefix ele t)))))
    unimported-class-items))

(defun ajc-import-all-unimported-class ()
  "Import all unimported class."
  (interactive)
  (ajc-insert-import-at-head-of-source-file
   (ajc-calculate-all-unimported-class-items)))

(defun ajc-import-class-under-point ()
  "Import class under point."
  (interactive)
  (let ((cur-word (current-word)))
    (when (and cur-word (> (length cur-word) 0))
      (when (string-match "[^a-zA-Z0-9_]\\([a-zA-Z0-9_]+\\)$" cur-word)
        (setq cur-word (match-string-no-properties 1 cur-word)))
      (when (string-match "^\\([a-zA-Z0-9_]+\\)[^a-zA-Z0-9_]" cur-word)
        (setq cur-word (match-string-no-properties 1 cur-word)))
      (ajc-insert-import-at-head-of-source-file
       (ajc-find-out-matched-class-item-without-package-prefix cur-word t)))))

(defun ajc-insert-import-at-head-of-source-file (import-class-items-list)
  "Insert 'import sentence' at the head of java source file
using `y-or-n-p' to ask user to confirm."
  (let ((import-class-buffer "*ajc-import-java-class*")
        (import-class-window)
        (user-confirmed-class-items-list)
        (java-buffer (current-buffer))
        (java-window)
        (use-dialog-box nil)
        (last-nonmenu-event nil)
        (case-fold-search nil))
    (save-window-excursion
      (cond ((and import-class-items-list (> (length import-class-items-list) 0))
             (setq import-class-buffer (switch-to-buffer-other-window import-class-buffer t))
             (setq java-window (get-buffer-window java-buffer))
             (setq import-class-window (get-buffer-window import-class-buffer))
             ;; show maybe imported Class in a new buffer
             (with-current-buffer import-class-buffer
               (delete-region (point-min) (point-max))
               (dolist (ele import-class-items-list)
                 (insert (concat "[ ]  "
                                 (car (ajc-split-pkg-item-by-pkg-ln (nth 1 ele)
                                                                    (nth 2 ele)))
                                 "."
                                 (car ele)
                                 "\n")))
               (insert "  ")         ; insert empty line at end of buffer
               (goto-char (1+ (point-min)))
               (dolist (ele import-class-items-list)
                 ;; ask user whether to import the Class
                 (beginning-of-line)
                 (forward-char 1)
                 (when (y-or-n-p (concat "import " (car ele) "? "))
                   (add-to-list 'user-confirmed-class-items-list ele)
                   (delete-char 1)
                   (insert "*"))
                 (forward-line 1)
                 (forward-char 1)))
             ;; delete *import-java-class* buffer and window
             (delete-window import-class-window)
             (kill-buffer import-class-buffer)
             (when user-confirmed-class-items-list
               (with-current-buffer java-buffer
                 (ajc-insert-import-at-head-of-source-file-without-confirm
                  user-confirmed-class-items-list))
               (message "Finished importing.")
               (ajc-sort-import-lines))
             user-confirmed-class-items-list)
            ((null import-class-items-list)
             ;; do nothing
             )
            (t
             (message "No class need import."))))))

(defun ajc-search-java-source-keyword ()
  "Return position where java keyword is found, or nil if "
  (save-excursion
    (goto-char (point-min))
    (re-search-forward
     (concat "\\(\\b\\(class\\|interface\\|enum\\)[ \t]+[a-zA-Z0-9_<>]+[ \t\n]*"
             "\\({\\|extends\\|implements\\)\\)")
     nil
     t)))

(defun ajc-insert-import-into-jsp-source (class-items)
  (let ((all-class-strings ""))
    (dolist (class-item class-items)
      (setq all-class-strings
            (concat all-class-strings
                    (car (ajc-split-pkg-item-by-pkg-ln (nth 1 class-item)
                                                       (nth 2 class-item)))
                    "."
                    (car class-item)
                    ",")))
    (unless (string-equal "" all-class-strings)
      ;; delete last char ","
      (setq all-class-strings
            (substring all-class-strings 0 (1- (string-width all-class-strings)))))
    (goto-char (point-min))
    (insert (concat "<%@ page import=\"" all-class-strings "\" %>\n"))))

(defun ajc-make-import-line (class-item)
  (concat "import "
          (car (ajc-split-pkg-item-by-pkg-ln (nth 1 class-item)
                                             (nth 2 class-item)))
          "." (car class-item) ";\n"))

(defun ajc-insert-import-at-head-of-source-file-without-confirm (class-items)
  (let ((case-fold-search nil)
        (class-start (ajc-search-java-source-keyword)))
    ;; insert at head of java source
    (save-match-data
      (save-excursion
        (cond
         ((not class-start)
          ;; this is a jsp file
          (ajc-insert-import-into-jsp-source class-items))
         (t
          ;; this is a java source file
          (ajc-insert-import-into-java-source class-items class-start)))))))

(defun ajc-insert-import-into-java-source (class-items class-start)
  (goto-char (point-min))
  (cond
   ((re-search-forward "^[ \t]*import[ \t]+[a-zA-Z0-9_\\.\\*]+[ \t]*;"
                       class-start
                       t)
    ;; If found import line, insert before it
    (beginning-of-line)
    (forward-line -1)
    (dolist (ele class-items)
      (insert (ajc-make-import-line ele))))
   (t
    ;; if hasn't found 'import; then insert after 'package ' statement
    (goto-char (point-min))
    (if (re-search-forward "^[ \t]*package[ \t]+[a-z0-9_\\.]+[ \t]*;"
                           class-start
                           t)
        ;; If there is package line, move point to the next line of it.
        (progn (forward-line 1)
                     (beginning-of-line)
                     (newline))
      (goto-char (point-min)))
    (dolist (ele class-items)
      (insert (ajc-make-import-line ele))))))

(defun ajc-sort-import-lines ()
  "Sort import statements alphabetically."
  (let ((beg-pos nil)
        (end-pos nil)
        (sort-fold-case nil))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^import.*" nil t)
        (or beg-pos (setq beg-pos (line-beginning-position)))
        (setq end-pos (line-end-position))))
    (ajc-sort-region-preserving-empty-lines beg-pos end-pos)
    ;; if there is no empty line between import lines and the following code,
    ;; we insert an empty line there.
    (save-excursion
      (goto-char end-pos)
      (forward-line 1)
      (unless (re-search-forward "^$" (line-end-position) t)
        (open-line 1)))))

(defun ajc-sort-region-preserving-empty-lines (beg end)
  "Sort region preserving empty lines"
  (if (save-excursion
        (goto-char beg)
        (not (re-search-forward "^$" end t)))
      ;; no empty line between beg and end
      (sort-lines nil beg end)
    (let ((beg-pos beg))
      (save-excursion
        (goto-char beg)
        (while (re-search-forward "^$" end t)
          (sort-lines nil beg-pos (point))
          (goto-char (1+ (point)))
          (setq beg-pos (point)))
        (sort-lines nil beg-pos (point))))))

(defun ajc-find-out-import-line ()
  "Return a list of import statement lines.
Make a regex to match the packages in the import statements and
return a list of each line string excluding keyword 'import'."
  (save-match-data
    (save-excursion
      (goto-char (point-min))
      (let ((case-fold-search nil)
            (imported-lines nil)
            (class-start
             (save-excursion
               (re-search-forward
                (concat
                 "\\("
                 "\\b\\(class\\|interface\\)[ \t]+[a-zA-Z0-9_]+\\(<[0-9A-Za-z_<> ]+>\\)?[\n \t]*"
                 "\\({\\|extends\\|implements\\)"
                 "\\)")
                nil
                't))))
        (if class-start
            ;; if found class or interface key words,
            ;; then this is a java file, if not it is a jsp file
            (while (re-search-forward
                    "^[ \t]*import[ \t]+\\(static[ \t]+\\)?\\([a-zA-Z0-9_\\.\\*]+\\)[ \t]*;"
                    class-start
                    't)
              (add-to-list 'imported-lines (match-string-no-properties 2))
              (end-of-line))
          ;; maybe this is a jsp file
          (while (re-search-forward "\\bimport=\"\\(.*?\\)[ \t]*\"[ \t]+" (point-max) 't)
            (setq imported-lines (append imported-lines
                                         (split-string (match-string-no-properties 1) "[ \t,]" t)))
            (end-of-line)))
        imported-lines))))

(defun ajc-calculate-all-imported-class-items (&optional exclude_java_lang)
  "Find out all imported classes.
By default it includes classes in java.lang.*."
  (let ((import-lines (ajc-find-out-import-line))
        (element)
        (index)
        (return-class-items)
        (case-fold-search nil))
    (dolist (element import-lines)
      (setq index (string-match "\\.\\*$" element))
      (cond
       (index
        ;; this is like 'import org.junit.*;' statement
        (setq return-class-items
              (append return-class-items
                      (ajc-find-out-matched-class-item
                       (substring-no-properties element 0 index)
                       nil))))
        ((string-match "^\\(.+\\)\\.\\([A-Z][a-zA-Z0-9_]+\\)\\(\\.[a-z].+\\)?$" element)
         ;; This is a FQN classname
         ;; The last parenthesized part is method name,
         ;; i.e., static import.
         (setq return-class-items
               (append return-class-items
                       (ajc-find-out-matched-class-item
                        (match-string-no-properties 1 element)
                        (match-string-no-properties 2 element)
                        t))))
         (t
          )))
    (if exclude_java_lang
        return-class-items
      (append return-class-items
              (ajc-find-out-matched-class-item "java.lang" nil)))))

(defun ajc-complete-constructor-candidates ()
  "Return construtor candidates by analyzing new statement to
find out the type name."
  ;;(message "DEBUG: ajc-complete-constructor-candidates called")
  (let ((candidates nil)
        (class-items nil)
        (case-fold-search nil)
        (package-name nil))
    ;;(message "DEBUG: ajc-complete-constructor-candidates, ac-prefix=%s" ac-prefix)
    ;; if we find new keyword, then do constructor completion
    ;; otherwise do classname completion.
    (when (and ac-prefix
               (string-match (concat "\\([a-z.]+\\)?" ; package name if exists
                                     "\\([A-Z][a-zA-Z0-9_]+\\)"  ; class name
                                     "("                         ; open paren
                                     ")?") ; close paren
                             ac-prefix))
      ;; (message "ajc-complete-constructor-candidates, classname=%s"
      ;;          (match-string-no-properties 2 ac-prefix))
      ;; remove the last dot
      (setq package-name (and (match-string-no-properties 1 ac-prefix)
                              (substring (match-string-no-properties 1 ac-prefix)
                                         0
                                         (1- (length (match-string-no-properties 1 ac-prefix))))))
      (setq class-items
            (ajc-complete-class-with-cache (match-string-no-properties 2 ac-prefix)))
      ;;(message "DEBUG: ajc-complete-constructor-candidates, class-items=%s" class-items)
      (dolist (class-item class-items)
        ;(message "Debug: ajc-complete-constructor-candidates, class-item=%s" class-item)
        (setq candidates
              (append candidates (ajc-complete-constructor (car class-item) package-name))))
      candidates)))

(defun ajc-complete-constructor (class-prefix &optional package-name)
  (let ((matched-class-items
         (if package-name
             (ajc-find-out-matched-class-item package-name class-prefix t)
           (ajc-find-out-matched-class-item-without-package-prefix class-prefix t)))
        (matched-constructor-items nil)
        (return-complete-list nil))
    ;; When the num of matched class is greater than 1,
    ;; we ask user if they import one of them.
    ;; Then we can get the imported class item,
    ;; we complete its constructor
    ;; (message "DEBUG: ajc-complete-constructor, class-prefix=%s" class-prefix)
    ;; (message "DEBUG: ajc-complete-constructor, package-name=%s" package-name)
    ;; (message "DEBUG: ajc-complete-constructor, matched-class-items=%s" matched-class-items)
    (dolist (matched-class-item matched-class-items)
      (let ((line-num (nth 3 matched-class-item))
            (end-line (nth 4 matched-class-item))
            (ix (nth 1 matched-class-item))
            (matching-constructor t)
            (current-line nil))
        (while (and matching-constructor (< line-num end-line))
          (setq current-line (ajc-read-line line-num (nth ix ajc-tag-buffer-list)))
          (if (string-match "^  " current-line)
              (add-to-list 'matched-constructor-items (ajc-split-constructor current-line ix))
            (setq matching-constructor nil))
          (incf line-num))
        (dolist (constructor matched-constructor-items)
          (let ((constructor-full-string
                 (concat package-name
                         (and package-name ".")
                         (ajc-constructor-to-string constructor t)))
                (constructor-short-string
                 (concat package-name
                         (and package-name ".")
                         (ajc-constructor-to-string constructor nil))))
            (add-to-list 'return-complete-list
                         (propertize constructor-short-string
                                     'view constructor-full-string
                                     'template-type 'constructor
                                     'template constructor))))))
    ;; (message "Debug: ajc-complete-constructor, return-complete-list=%s"
    ;;          return-complete-list)
    return-complete-list))

(defun ajc-is-available-4-complete-class-p ()
  "Return t if current-word begins like classname and set
`ajc-current-class-prefix-4-complete-class'."
  (let ((class-prefix ac-prefix)
        (is-available)
        (case-fold-search nil))
    (when (and (stringp class-prefix)
               (> (length class-prefix) 0)
               (string-match "^[A-Z][a-zA-Z0-9_]*$" class-prefix))
      (setq ajc-current-class-prefix-4-complete-class class-prefix)
      t)))

(defun ajc-complete-class-candidates ()
  "Return class name candidates whose class names begin with the
value of `current-word'."
  (when (ajc-is-available-4-complete-class-p)
    (mapcar #'ajc-propertize-class-item
            (ajc-complete-class-with-cache ajc-current-class-prefix-4-complete-class))))

(defun ajc-propertize-class-item (class-item)
  "Return a propertized class name string."
  (propertize (car class-item) 'view (ajc-class-to-string class-item t)))

(defun ajc-complete-class-with-cache (class-prefix &optional package-name)
  "Return a list of class-items which start with CLASS-PREFIX.
Before searching in tag file, first check out
`ajc-matched-class-items-cache' to see if there is a matched
class."
  (let ((return-list)
        (case-fold-search nil))
    (when (and class-prefix
               (string-match "[A-Z][a-zA-Z0-9_]*" class-prefix))
      (if (and ajc-previous-class-prefix
               (string-match (concat "^" ajc-previous-class-prefix) class-prefix))
          (dolist (class-item ajc-matched-class-items-cache)
            (if (string-match (concat "^" class-prefix) (car class-item))
                (push class-item return-list))
            (setq return-list (nreverse return-list)))
        (setq return-list
              (if package-name
                  (ajc-find-out-matched-class-item class-prefix package-name)
                (ajc-find-out-matched-class-item-without-package-prefix class-prefix))))
      (when (> (length return-list) 0)
        ;; if find matched names, update cache
        (setq ajc-previous-class-prefix class-prefix)
        (setq ajc-matched-class-items-cache return-list)))
    return-list))

(defun ajc-find-members (class-item &optional member-prefix exactly_match)
  "Find members (field, method) under CLASS-ITEM which match MEMBER-PREFIX.
If MEMBER-PREFIX is nil or empty string, it will return all
members under class-item. CLASS-ITEM is of form (classname index
pkg-line start-line end-line)."
  (when (listp class-item)
    (let ((line-num (nth 3 class-item))
          (end-line (nth 4 class-item))
          (return-member-items nil)
          (regexp-method-prefix nil)
          (regexp-field-prefix nil)
          (current-line-string nil)
          (index (nth 1 class-item)))
      (if exactly_match
          (setq regexp-method-prefix (concat "^" member-prefix "`")
                regexp-field-prefix (concat "^ " member-prefix "`"))
        (if (or (not member-prefix) (string-equal "" member-prefix))
            (setq regexp-method-prefix "^[a-zA-Z0-9_]" regexp-field-prefix "^ [^ ]")
          (setq regexp-method-prefix (concat "^" member-prefix)
                regexp-field-prefix (concat "^ " member-prefix))))
      (with-current-buffer (nth index ajc-tag-buffer-list)
        (while (< line-num end-line)
          (setq current-line-string (ajc-read-line line-num))
          (cond
           ((string-match regexp-method-prefix current-line-string)
            (push (ajc-split-method current-line-string index)
                  return-member-items))
           ((string-match regexp-field-prefix current-line-string)
            (push (ajc-split-field current-line-string index) return-member-items)))
          (incf line-num)))
      (nreverse return-member-items))))

(defun ajc-calculate-class-name-by-variable (variable-name)
  "Find class name of VARIBALE-NAME.
Suppose that VARIABLE-NAME is str. If a statement 'String str' exists
in a source file, String will be returned."
  (let ((variable-line-string)
        (index-of-var-in-line)
        (var-stack)
        (origin-pos (point))
        (needle (concat "[[:space:],]+"
                        variable-name
                        ajc-thing-after-varname-regexp))
        (case-fold-search nil))
    ;;(message "DEBUG: ajc-calculate-class-name-by-variable, variable-name=%s" variable-name)
    (save-excursion
      (catch 'found
        ;; Searching in the former part
        (while (re-search-backward needle (point-min) t)
          (when (ajc-line-has-typeinfo-p variable-name
                                         (buffer-substring-no-properties
                                          (line-beginning-position)
                                          (line-end-position)))
            (setq variable-line-string
                  (buffer-substring-no-properties (line-beginning-position)
                                                  (line-end-position)))
            (throw 'found t)))
        ;; Searching in the latter part
        (goto-char (1+ origin-pos))
        (while (re-search-forward needle (point-max) t)
          (when (ajc-line-has-typeinfo-p variable-name
                                         (buffer-substring-no-properties
                                          (line-beginning-position)
                                          (line-end-position)))
            (setq variable-line-string
                  (buffer-substring-no-properties (line-beginning-position)
                                                  (line-end-position)))
            (throw 'found t)))))
    ;;(message "DEBUG: variable-line-string=%s" variable-line-string)
    (and (stringp variable-line-string)
         (ajc-parse-variable-line-string variable-name variable-line-string))))

(defun ajc-last-string-match (regexp string)
  "Return index of last occurrence of REGEXP in STRING, or nil."
  (loop with ix = -1
        with ret = nil
        while (setq ix (string-match regexp string (1+ ix)))
        do (setq ret ix)
        finally (return ret)))

(defun ajc-parse-variable-line-string (variable-name variable-line-string)
  "Return type-name of VARIABLE-NAME by parsing VARIABLE-LINE-STRING.
Ignores primitive typename such as int, double, etc."
  (let ((index-of-var-in-line nil)
        (var-stack nil)
        (matched-class-name nil)
        (case-fold-search nil))
    (setq index-of-var-in-line
          (ajc-last-string-match (concat "[, \t]+" variable-name "\\b") variable-line-string))
    ;; extract the string before variable name
    (setq variable-line-string
          (substring-no-properties variable-line-string 0 index-of-var-in-line))
    (setq var-stack (split-string variable-line-string "[,( \t.]" t))
    ;;(message "DEBUG: ajc-parse-variable-line-string, var-stack=%s" var-stack)
    (let ((tmp-list))
      (dolist (ele var-stack)
        (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "<" "<" t))))
      (setq var-stack tmp-list))
    (let ((tmp-list))
      (dolist (ele var-stack)
        (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele ">" ">" t))))
      (setq var-stack tmp-list))
    (setq var-stack (nreverse var-stack))
    (let ((top (pop var-stack))
          (parse-finished nil))
      (while (and top (not parse-finished))
        (when (string-match "^\\([a-z0-9.]+\\)*\\([A-Z][a-zA-Z0-9_]*\\)\\(\\[\\]\\)*$" top)
          (setq matched-class-name top)
          ;; parse finished, exit the loop
          (setq parse-finished t))
        (when (string-equal ">" top)
          ;; loop until the matchging "<" is popped from var-stack.
          (let ((e)
                (right-stack))
            (push top right-stack)
            (setq e (pop var-stack))
            (while (and e (> (length right-stack) 0))
              (cond
               ((string-equal "<" e)
                (pop right-stack))
               ((string-equal ">" e)
                (push e right-stack)))
              (setq e (pop var-stack)))
            (when e (push e var-stack))))
        (setq top (pop var-stack))))
    ;;(message "DEBUG: ajc-parse-variable-line-string, class-name=%s" matched-class-name)
    matched-class-name))

(defun ajc-line-has-typeinfo-p (varname line)
  "Return t if this LINE contains type name, or nil."
  (let ((case-fold-search nil)
        (type-regexp (concat
                      "\\([A-Z][[:alnum:]]+[.]?\\)+"
                      "\\(<[^=]*>\\)*"
                      "\\(\\[\\]\\)*"
                      "[[:space:]]+"
                      ))
        (exclude-regexp "return"))
    (and (string-match-p (concat type-regexp
                                 "[[:alnum:][:space:],_=]*"
                                 varname
                                 ajc-thing-after-varname-regexp
                                 )
                         line)
         (not (string-match-p exclude-regexp line))
         (not (string-match-p "^[[:space:]]*//" line)))))

(defun ajc-plain-method-candidates ()
  (let ((case-fold-search nil))
    (when (and (stringp ac-prefix)
               (string-match "^[a-z][a-z]..*$" ac-prefix))
      (loop for table in ajc-plain-method-tables
            with each-limits = (/ ajc-plain-method-candidates-limit
                                  (length ajc-plain-method-tables))
            append (ajc-plain-method-candidates-1 ac-prefix
                                                  table
                                                  each-limits)))))

(defun ajc-plain-method-candidates-1 (prefix table nlimits)
  (let* ((candidates
          (all-completions prefix
                           (gethash (substring-no-properties prefix 0 3) table)))
         (len (length candidates)))
    (if (<= len nlimits)
        candidates
      ;; We use the first nlimits of candidates as to avoid
      ;; performance latency
      (nbutlast
       candidates
       (- len nlimits)))))

;;TODO: add cache support for method candidates
;; if it failed ,then don't try, to waste time.

;;(ajc-concat-list-as-string '("a" "b"))=="ab"
(defun ajc-concat-list-as-string (list)
  "(ajc-concat-list-as-string '(\"a\" \"b\"))==\"ab\""
  (reduce #'concat list))

(defvar ajc-complete-method-candidates-cache nil)
(defvar ajc-complete-method-candidates-cache-stack-list nil)

(defun ajc-complete-method-is-available (line-string)
  "Check whether method completion is available or not.
Suppose previous (current-line)==\"Systema.aaa\" but it failed to get
any candidates, and now (current-line)==\"Systema.aaab\" It would not
get any candidates too, we needn't try to complete it."
  ;;(message "DEBUG: ajc-complete-method-is-available, line-string=%s" line-string)
  (let ((stack-list (ajc-get-validated-stack-list-or-nil-4-method-complete
                     (ajc-parse-splited-line-4-complete-method line-string)))
        (is-available t))
    ;; stack-list is, for example, '("System" "." "out" "." "p"),
    ;; and ajc-complete-method-candidates-cache-stack-list is
    ;; '("System" "." "out" ".")
    ;(message "DEBUG: ajc-complete-method-is-available, line-string=%s" line-string)
    ;(message "DEBUG: ajc-complete-method-is-available, stack-list=%s" stack-list)
    (when (and ajc-complete-method-candidates-cache-stack-list
               (string-match (concat "^"
                                     (regexp-quote
                                      (ajc-concat-list-as-string
                                       ajc-complete-method-candidates-cache-stack-list)))
                              (ajc-concat-list-as-string stack-list))
                (not ajc-complete-method-candidates-cache))
      ;; If ajc-complete-method-candidates-cache is nil, it means that
      ;; completion was not possible on the previous input. So the
      ;; next completion is also not possible.
      (setq is-available nil))
    (setq ajc-complete-method-candidates-cache-stack-list stack-list)
    ;;(message "DEBUG: is-available=%s" is-available)
    is-available))

(defun ajc-complete-method-candidates ()
  "Get method completion candidates."
  (when (ajc-complete-method-is-available (buffer-substring-no-properties
                                           (line-beginning-position)
                                           (point)))
    (setq ajc-complete-method-candidates-cache
          (ajc-complete-method-candidates-1 ajc-complete-method-candidates-cache-stack-list))))

(defun ajc-complete-method-candidates-1 (stack-list)
  "Get method candidates depending on stack-list. To see what
stack-list is, check out
`ajc-parse-splited-line-4-complete-method'"
  ;;(message "DEBUG: ajc-complete-method-candidates-1, stack-list=%s" stack-list)
  (when stack-list
    (let ((is-dot-last (string= "." (car (last stack-list))))
          top
          return-list
          return-string-list
          (case-fold-search nil))
      (setq stack-list (remove "." stack-list))
      (setq top (pop stack-list))
      (let ((class-item nil))
        (if (string-match "^[A-Z][a-zA-Z0-9_]*$" top)
            ;; If this is class name, we do searching from imported
            ;; classes.
            (setq class-item (ajc-find-class-first-check-imported top))
          ;; Else find out classname before doing search.
          (let ((typename (ajc-calculate-class-name-by-variable top)))
            (setq class-item (and typename
                                  (ajc-find-class-first-check-imported
                                   typename)))))
        ;; following while sexp maybe has bug
        ;; because ajc-find-members doesnt return class-item.
        (while (and class-item (> (length stack-list) 1))
          ;; (nth 1 member-item) is type-name
          (setq class-item (nth 1 (car (ajc-find-members class-item (pop stack-list) t)))))
        (when class-item
          (if is-dot-last
              (let ((member-string (pop stack-list)))
                (if member-string
                    (setq class-item (nth 1 (car (ajc-find-members class-item member-string t)))))
                (setq return-list (ajc-find-members class-item)))
            (setq return-list (ajc-find-members class-item (pop stack-list))))))
      ;; (message "DEBUG: ajc-complete-method-candidates-1, return-list=%s"
      ;;          return-list)
      (and return-list
           (mapcar 'ajc-method-item-to-candidate return-list)))))

(defun ajc-get-validated-stack-list-or-nil-4-method-complete (stack-list)
  "If stack-list is validated, return itself, else return nil."
  ;; (message "DEBUG: ajc-get-validated-stack-list-or-nil-4-method-complete, stack-list=%s"
  ;;          stack-list)
  (cond ((or (< (length stack-list) 2)
             (not (string-match "^[a-zA-Z0-9_]+$" (car stack-list))))
         nil)
        (t
         (loop for current-item in stack-list
               for next-item in (cdr stack-list)
               with regexp = "^[a-zA-Z0-9_]+$"
               if (string-match regexp current-item)
               do (unless (string-equal "." next-item)
                    (return nil))
               else if (string-equal "." current-item)
               do (unless (string-match regexp next-item)
                    (return nil))
               else do (return nil)
               finally (return stack-list)))))

(defun ajc-parse-splited-line-4-complete-method (line-string)
  "Parse current line for complete method.
Suppose current line is System.getProperty(str.substring(3)).to.
First `ajc-split-line-4-complete-method' will split this line to
'System' '.' 'getProperty' '(' 'str' '.' 'substring' '(' '3' ')'
')' '.' 'to'.  `ajc-remove-unnecessary-items-4-complete-method'
will remove anything between ( and ), so only 'System' '.'
'getProperty' '.' 'to' are left."
  (let ((ret (ajc-remove-unnecessary-items-4-complete-method
              (ajc-split-line-4-complete-method line-string))))
    (if (and (> (length ret) 3)
             (string= "(" (car ret))
             (equal '(")" ".")
                    (nthcdr (- (length ret) 2) ret)))
        ;; If the ret is like '("a" + "b").', then we guess the type
        ;; of this parenthesized expression.
        (let ((type (ajc-guess-type-of-factor ret)))
          (and type (list type ".")))
      ret)))

(defun ajc-remove-unnecessary-items-4-complete-method (splited-line-items)
  " System.getProperty(str.substring(3)).to
first ajc-split-line-4-complete-method will split this line to
'System' '.' 'getProperty' '(' 'str' '.' 'substring' '(' '3' ')' ')' '.' 'to'
this function will remove anything between ( and )  ,so only
'System'  '.' 'getProperty'  '.'  'to'  is left "
  (if (and (> (length splited-line-items) 2)
           (string= "." (car (last splited-line-items)))
           (string= "(" (car splited-line-items))
           (string= ")" (cadr (reverse splited-line-items))))
      ;; then no need to remove
      splited-line-items
    (let* ((stack-list)
           (ele)
           (reverse-current-line-split-list (reverse splited-line-items))
           (parse-finished))
      (setq ele (pop reverse-current-line-split-list))
      (while (and ele (not parse-finished))
        (if (or (string-equal ";" ele) (string-equal "(" ele))
            ;; parse finished ,exit the  loop
            (setq parse-finished t)
          (if (string-equal ")" ele)
              (let ((e) (right-stack))
                (push ele right-stack)
                (setq e (pop reverse-current-line-split-list))
                (while (and e (> (length right-stack) 0))
                  (if (string-equal "(" e)
                      (pop right-stack))
                  (if (string-equal ")" e)
                      (push e right-stack))
                  (setq e (pop reverse-current-line-split-list)))
                (if e
                    (push e reverse-current-line-split-list)))
            (push ele stack-list)))
        (setq ele (pop reverse-current-line-split-list)))
      (setq stack-list (ajc-remove-java-keywords stack-list)))))

(defun ajc-remove-java-keywords (lst)
  (let ((keywords (ajc-java-keywords-candidates)))
    (remove-if (lambda (s)
                 (member s keywords))
               lst)))

(defun ajc-split-line-4-complete-method (line-string)
  "Split LINE-STRING to small items. For example,
'System.getProperty(str.substring(3)).to' to 'System' '.'
'getProperty' '(' 'str' '.' 'substring' '(' '3' ')' ')' '.'
'to'."
  (save-excursion
    (let* ((stack-list nil)
           (case-fold-search nil)
           (ix nil))
      ;; \" => '
      (setq line-string (replace-regexp-in-string "\\\\\"" "'" line-string))
      ;; "foo" => String
      (setq line-string (replace-regexp-in-string "\".*?\"" "String" line-string))
      ;; remove new keyword
      (setq line-string (replace-regexp-in-string "\\bnew\\b" "" line-string))
      ;; remove return keyword
      (setq line-string (replace-regexp-in-string "\\breturn\\b" "" line-string))
      ;; remove this keyword
      (setq line-string (replace-regexp-in-string "\\bthis\\b" "" line-string))
      ;; remove case keyword
      (setq line-string (replace-regexp-in-string "\\bcase\\b" "" line-string))
      ;; remove unary operators
      (setq line-string (replace-regexp-in-string "\\(\\+\\+\\|--\\|!\\)"
                                                  " "
                                                  line-string))
      ;; remove heading spaces
      (setq line-string
            (replace-regexp-in-string "^[[:space:]]+" "" line-string))
      ;; remove the heading dot
      (setq line-string
            (replace-regexp-in-string "^\\." "" line-string))
      ;; remove the part before ':'
      ;; we consider the following situations.
      ;; "for (String s : str.time().)" or
      ;; "ret = cond ? a : b."
      (when (string-match ":" line-string)
        (setq line-string (substring-no-properties line-string
                                                   (1+ (match-beginning 0)))))
      (while (string-match "=\\(.*\\)" line-string)
        (setq line-string (match-string-no-properties 1 line-string)))
      ;; split line-string by ".", but add "." as an element at its position in list
      (setq stack-list (ajc-split-string-with-separator line-string "[ \t]*\\.[ \t]*" "." t))
      ;; split each element with "(", but add "(" as an element at its position in list
      ;; and merge all the list in a list
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "(" "(" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele ")" ")" t))))
        (setq stack-list tmp-list))
      (let ((ele)(tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "\\[" "(" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "]" ")" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "{" "(" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "}" ")" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "<" "(" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele ">" ")" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele "," ";" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (ajc-split-string-with-separator ele ";" ";" t))))
        (setq stack-list tmp-list))
      (let ((ele) (tmp-list))
        (dolist (ele stack-list)
          (setq tmp-list (append tmp-list (split-string ele "[ \t]+" t))))
        (setq stack-list tmp-list))
      (setq stack-list (ajc-extract-parenthesized-part-maybe stack-list))
      (ajc-remove-unnecessary-heading-part stack-list))))

(defun ajc-extract-parenthesized-part-maybe (lst)
  "Return a parenthesized expression if the last part of LST
is \"\).\"."
  (if (and (> (length lst) 2)
             (string= "." (car (last lst)))
             (string= ")" (cadr (reverse lst)))
             (not (= (count ")" lst :test #'string=)
                     (count "(" lst :test #'string=))))
      (loop with ret = nil
            with case-fold-search = nil
            with close-paren-cnt = 1
            for elt in (if (equal '("(" ")" ".")
                                  (nthcdr (- (length lst) 3) lst))
                           (nthcdr 3 (reverse lst))
                         (nthcdr 2 (reverse lst)))
            for cnt from 2
            if (zerop close-paren-cnt)
            do (return
                ;; If the item before this open paren is like classname,
                ;; then we assume this parenthesized part is part of constructor.
                ;; so we return the classname + parenthesized part.
                ;; Otherwise just return parenthesized part.
                (nthcdr (- (length lst)
                           (if (string-match "^[A-Z][a-zA-Z0-9_]+"
                                             (car (nreverse
                                                   (butlast lst cnt))))
                               (1+ cnt)
                             cnt))
                        lst))
            else if (string= ")" elt)
            do (incf close-paren-cnt)
            else if (string= "(" elt)
            do (decf close-paren-cnt))
    lst))

(defun ajc-remove-unnecessary-heading-part (lst)
  ;; If lst is like "(expression).", we return lst as is
  (if (and (cadr (reverse lst))
           (string= ")" (cadr (reverse lst))))
      lst
    (loop for i from (1- (length lst)) downto 0
          for elt in (reverse lst)
          with operators = '("&" "&&" "|" "^" "||"
                             "+" "-" "*" "/" "%"
                             "<" ">" "<<" ">>" ">>>" "==" "!="
                             "+=" "-=" "*=" "/=" "%=" "&=" "^=" "|=" "<<=" ">>="
                             ":")
          when (member elt operators)
          return (nthcdr (1+ i) lst)
          finally (return (if (string= "." (car lst))
                              (cdr lst)
                            lst)))))

(defun ajc-guess-type-of-factor (lst)
  "LST must be of form '(expression)'."
  (ajc-find-out-type-of-factors
   (ajc-split-and-concat-list-by-operators lst)))

(defun ajc-find-out-type-of-factors (lst)
  (let ((l (remove nil
                   (mapcar #'ajc-find-out-type-of-factor
                           lst))))
    (if (every (lambda (e)
                 (string= e (car l)))
               l)
        (car l)
      nil)))

(defun ajc-find-out-type-of-factor (factor)
  ""
  (cond
   ((string-match "^[A-Z][A-Za-z0-9_]+$" factor)
    ;; this is presumable a type name
    factor)
   ((string-match "[.()]" factor)
    ;; We assume this is a method invocation or field access.
    ;; Find out the type of return value or that field, which means
    ;; If factor is "System.getProperty", then return "String".
    (loop with splitted-line = (remove "." (ajc-parse-splited-line-4-complete-method factor))
          for current in splitted-line
          ;; TODO What if exactly-matched class items is NOT one?
          for class-item = (car (ajc-find-out-matched-class-item-without-package-prefix
                                 current
                                 t))
          then (and class-item
                    (nth 1 (car (ajc-find-members class-item current t))))
          finally (return (cond
                           ((stringp class-item)
                            class-item)
                           ((listp class-item)
                            (car class-item))))))
   ((string-match "^[A-Za-z0-9_]+$" factor)
    ;; We assume this is a variable name or a primitive type.
    ;; For now just return it.
    factor)
   (t
    nil)))

(defun ajc-split-and-concat-list-by-operators (lst)
  "Split LST by java binary operators."
  (when (string= "." (car (last lst)))
    (ajc-split-and-concat-list-by-operators-1 (butlast lst 1)
                                              nil)))

(defun ajc-split-and-concat-list-by-operators-1 (lst factor-acc)
  (cond
   ((null lst)
    nil)
   ((string-match "^[A-Za-z0-9_]+$" (car lst))
    (ajc-split-and-concat-list-by-operators-1
     (cdr lst) (concat factor-acc (car lst))))
   ((string-match "^[+()]$" (car lst))
    (if factor-acc
        (cons factor-acc (ajc-split-and-concat-list-by-operators-1 (cdr lst)
                                                                   nil))
      (ajc-split-and-concat-list-by-operators-1 (cdr lst) nil)))
   ((string-match "^[.]$" (car lst))
    (ajc-split-and-concat-list-by-operators-1 (cdr lst)
                                              (concat factor-acc ".")))))

(defun ajc-java-keywords-candidates ()
  (let ((keywords))
    (setq keywords (list "public" "protected" "private" "native"
                         "final" "synchronized" "transient" "abstract"
                         "static" "import" "this" "if" "else"
                         "else if" "break" "case" "switch"
                         "continue" "class" "interface" "package"
                         "new" "try" "catch" "finally"
                         "super" "void" "int" "float"
                         "double" "short" "char" "byte"
                         "long" "boolean" "enum" "instanceof"
                         "for" "while" "throw" "throws"
                         "extends" "implements"))))

(provide 'ajc-java-complete)
;; End.